void (vector a, vector b) SpawnMeatSpray;
void(entity targ, entity inflictor, entity attacker, float damage, float T_flags, float T_AttackType) TF_T_Damage;
float crandom();
void(float att_delay) Attack_Finished;
void () Player_Menu;
void() StingerElec;
void () MirvGrenadeExplode; //calling an extra instance just in case of runaway loop errors. -arg
void() NapalmGrenadeExplode;
void() GasGrenadeExplode;
void() GrenadeExplode;
void (string gibname, float dm) beartrap_throwGib;
void() beartrapDie;
void() drop_gravity;
void() copb_eatCan;
void() copb_checkFart;
void (entity inflictor, entity attacker, float damage, entity ignore, float radius) T_BeanDamage;
void () AC_ChangeWeapon;
void () Sub_ChangeWeapon;
void () Aircraft_Attack;
void () Sub_Attack;
void () W_FireLTB;		// LTB
void () LTB_Pain;
void () LTB_Explode;
void () LTB_Detonate;
void () Throw_Health;		// throw health package		// check medic.pqc
void () DropGoalItems;
#ifdef NEW_CLASS1
void () W_FireThumper;
void () W_FireCrossbowArrow;
#endif
void (float _p_10136) TeamFortress_ItemStatus;
void () HealSelf
void (string put) votemap_start;
void () lay;
void () unlay;
void () DropFlag;
void () Det_Disp;
void () Det_Sent;
void () TeamFortress_Timeleft;
void () Prox_Disarm;
void () ProxiDie;
entity (float head) MakeLink;
void() TeamFortress_AmmoboxTouch;
void () TeamFortress_Spotlight;
void() MushroomFlame;
void() DroneJet;
void(float tno) RemoveOldAmmobox;
string(float num) NumberToString1000;
void () W_FireBigAss;
void() make_explosion;
void () DroneDie;
string(float pc) TeamFortress_GetClassName;
void(float tno) increment_team_ammoboxes;
void (vector org) spawn_tfog;
void () Drone;
void () Prox;
void() button_fire;
void() ConcussionGrenadeTimer;
void() PipebombTouch;
void (entity targ, entity inflictor, entity attacker, float damage, float T_flags, float T_AttackType) TF_T_Damage;
void () player_run;
void(entity bomb, entity attacker, float rad, entity ignore) T_RadiusDamage;
void() TeamFortress_DisplayDetectionItems;
float(vector veca, vector vecb) crossproduct;
void(vector org, float damage) SpawnBlood;
void(entity rhook) Reset_Grapple;
void() SuperDamageSound;
void() ConcussionGrenadeTimer;
void() W_PrintWeaponMessage;
void() button_touch;
void() button_fire;
void() TeamFortress_ChangeClass;
void() TeamFortress_DisplayLegalClasses;
void() TeamFortress_Inventory;
void() TeamFortress_SaveMe;
void() TeamFortress_ID;
void() TeamFortress_ShowTF;
void() TeamFortress_SniperWeapon;
void() TeamFortress_IncendiaryCannon;
void() TeamFortress_FlameThrower;
void() TeamFortress_PrimeGrenade;
void() TeamFortress_ThrowGrenade;
void() TeamFortress_Discard;
void(entity p) TeamFortress_SetSpeed;
void() TeamFortress_DetonatePipebombs;
void() PipebombTouch;
void() TeamFortress_DetpackStop;
void() SniperSight_Create;
void(float zoom_level) TF_zoom;
void() TeamFortress_ReloadCurrentWeapon;
void() TeamFortress_AutoZoomToggle;
void() TeamFortress_StatusQuery;
void() TeamFortress_SpyGoUndercover;
void (float _p_9330) TeamFortress_SpyFeignDeath;
void() TeamFortress_EngineerBuild;
void() UseSpecialSkill;
void(float scanrange) TeamFortress_Scan;
void(float timer) TeamFortress_SetDetpack;
float(float tno) TeamFortress_TeamSet;
void(entity Player) TeamFortress_TeamShowMemberClasses;
void() CamLock;
void() CamDistLock;
void() CamVecLock; 
void() CamAngleLock;
void() CamRevAngleLock;
void() CamProjectileLock;
void() CamProjectileZoom;
void() CamProjectileLockOn;
void() CamProjectileLockOff;
void() CamOffset;
void() CamDrop;
void() fadetoblack;
void() fadefromblack;
void() fadetowhite;
void() fadefromwhite;
void(entity disp) Engineer_UseDispenser;
void(entity gun) Engineer_UseSentryGun;
void (entity gun) Engineer_UseTesla;
void(entity tele) Engineer_UseTeleporter;
void(entity cam) Engineer_UseCamera;
void (entity fieldgen) Engineer_UseFieldGen;
void(entity spy) Spy_RemoveDisguise;
void() TeamFortress_MOTD;
void() TeamFortress_HelpMap;
void(float res) StatusRes;
void() BioInfection_Decay;
void() BioInfection_MonsterDecay;
void() W_FireFlame;
void() W_FireIncendiaryCannon;
void() W_FireTranq;
void (float chargeDmg) W_FireLaser;
void() HallucinationTimer;
void() TranquiliserTimer;
void() TeamFortress_CTF_FlagInfo;
void() TF_MovePlayer;
void() W_Precache = 
{
	precache_model ("progs/toaster.mdl");	//A real toaster from After Dark ? -arg
	missing_precaches();	//precache the stuff missing or overlooked or called all the time -arg
	if (mapname == "hip1m4")
	{
		precache_model2("progs/b_s_key.mdl");
		precache_model2("progs/b_g_key.mdl");
	}
	if (mapname == "hip2m2")
	{
		precache_model2("progs/knight.mdl");
		precache_model2("progs/shambler.mdl");
	precache_model2("progs/shalrath.mdl");
	precache_model2("progs/demon.mdl");
	precache_model2("progs/ogre.mdl");
	precache_model2("progs/wizard.mdl");
	}
	if (mapname == "hip2m4")
	{
	precache_model2("progs/zombie.mdl");
	precache_model2("progs/shambler.mdl");
	precache_model2("progs/spikmine.mdl");
	}
	if (mapname == "hipend")
	{
		precache_model2("progs/lasrspik.mdl");
	}
	precache_sound2 ("bigbomo/wokup.wav");
	precache_sound2 ("speech/needlite.wav");
	precache_sound("effects/bodyhit1.wav");
	precache_sound("effects/bodyhit2.wav");
	precache_sound("zombie/z_miss.wav");
	precache_sound("weapons/drone.wav");
	precache_sound("weapons/knifedrw.wav");
	precache_sound2("ambient/100hzhum.wav");
	precache_sound("weapons/jetjump.wav");
	precache_sound2 ("enforcer/enfire.wav");
	precache_sound("shambler/smack.wav");
	precache_sound("weapons/r_exp3.wav");
	precache_sound("shambler/sboom.wav");
	precache_sound("weapons/sniper.wav");
	precache_sound("doors/ddoor2.wav");
	precache_sound("doors/airdoor2.wav");
	precache_sound("weapons/sgun1.wav");
	precache_sound("weapons/unreel.wav");
	precache_sound("weapons/retract.wav");
	precache_sound("weapons/rocklr1a.wav");
	precache_sound("weapons/railgr1a.wav");
	precache_sound("weapons/shotgr1a.wav");
	precache_sound("weapons/guncock.wav");
	precache_sound("weapons/ric1.wav");
	precache_sound("weapons/ric2.wav");
	precache_sound("weapons/ric3.wav");
	precache_sound2 ("weapons/spike2.wav");
	precache_sound("weapons/tink1.wav");
	precache_sound("weapons/tink2.wav");
	precache_sound("weapons/shell2.wav");
	precache_sound("weapons/launch.wav");
	precache_sound("effects/mortar.wav");
	precache_sound("weapons/bounce.wav");
	precache_sound("weapons/shotgn2.wav");
	precache_sound("items/r_item1.wav");
	precache_sound("items/r_item2.wav");
	precache_sound("items/flare1.wav");
	precache_model2("progs/s_expl.spr");
	precache_model2("progs/beam.mdl");		// LTB
	precache_model2("progs/spikebal.mdl");
	precache_model2("progs/flare.spr");
	precache_model2("progs/lsrdrone.mdl");
	precache_model2("progs/shell2.mdl");
	precache_model2("progs/20mmcase.mdl");
	precache_model2("progs/air-mirv.mdl");
	precache_model("progs/flame2.mdl");
	precache_model2("progs/syringe.mdl");
	precache_sound2 ("ambience/fire1.wav");
	precache_model2("progs/v_spike.mdl");
	precache_sound("hknight/hit.wav");
	precache_sound("hknight/slash1.wav");
	precache_sound("doors/meduse.wav");
	precache_sound("weapons/tnkatck4.wav");
	precache_sound("weapons/pain.wav");
	precache_sound("weapons/gunidle1.wav");
	precache_sound("weapons/rifle.wav");
	precache_sound("weapons/plaser.wav");
	precache_sound("weapons/flmfire2.wav");
	precache_sound("misc/vapeur2.wav");
	precache_sound("weapons/chngnu1a.wav");
	precache_sound("weapons/asscan2.wav");
	precache_sound("weapons/chngnd1a.wav");
	precache_sound("weapons/dartgun.wav");
	precache_sound("weapons/lavapool.wav");
	precache_sound("misc/null.wav");
	precache_sound ("misc/secret.wav");
	precache_sound ("weapons/grenade.wav");
	precache_sound ("weapons/mini_set.wav");
	precache_model2 ("progs/turret.mdl");
	precache_model2 ("progs/turtop.mdl");
	precache_model2 ("progs/turstand.mdl");
	precache_model2 ("progs/nail.mdl");
	precache_sound ("weapons/sentry/turrt_3.wav");
	precache_sound ("weapons/sentry/turcl_2b.wav");
	precache_sound ("weapons/rocket1i.wav");
	precache_sound ("weapons/copb/copb_4.wav");
	precache_sound ("weapons/btrap/bdrop_1.wav");
	precache_model ("progs/beartrap.mdl");
	precache_sound ("weapons/btrap/btrap_1.wav");
	precache_sound ("weapons/btrap/btrap_3.wav");
	precache_model2 ("progs/bearbld.mdl");
	precache_model2 ("progs/beargib1.mdl");
	precache_model2 ("progs/beargib2.mdl");	
	precache_model2 ("progs/beargib3.mdl");
	precache_model2 ("progs/beargib4.mdl");
	precache_model2 ("progs/cubel.mdl");
	precache_model2 ("progs/cube.mdl");
	precache_sound ("misc/grav/grav_ergo.wav");
	precache_sound ("weapons/railgun.wav");
	precache_model2("progs/newtesla.mdl");
	precache_sound ("weapons/guerilla_blip.wav");
	precache_sound ("weapons/guerilla_set.wav");
	precache_model2("progs/telepad.mdl");
	precache_sound ("weapons/guerset.wav");
	precache_sound ("misc/runekey.wav");
	precache_sound ("weapons/cambeep.wav");
	precache_model("progs/camera.mdl");
	if ((infokey (world, "spycam") == "on" || infokey (world, "spycam") == "1"))
	{
		precache_model2 ("progs/spycamb.mdl");
		precache_model2 ("progs/spycamc.mdl");
	}
	precache_model2(#MODEL_CHAINSAW);
	precache_sound(#SOUND_CHAINSAW);
	precache_sound("items/backpack.wav");
	precache_sound2 ("speech/needlite.wav");
	precache_sound ("utils/paraland.wav");
	precache_sound ("utils/pullcord.wav");
	if (infokey (world, "btf_stuff") == "1" || infokey (world, "btf_stuff") == "on")
	{
		precache_model("progs/bullet.mdl");
		precache_sound ("helo/achit.wav");
		precache_sound ("helo/acpain1.wav");
		precache_sound ("helo/acpain2.wav");
		precache_sound ("helo/acpain3.wav");
		precache_sound ("helo/voice1.wav");
		precache_sound ("helo/voice2.wav");
		precache_sound ("helo/voice3.wav");
		precache_sound ("helo/voice4.wav");
		precache_sound ("helo/fuellow.wav");
		precache_sound ("helo/eject2.wav");
		precache_sound ("engines/chopper.wav");
		precache_sound ("weapons/ffar2.wav");
		precache_sound2 ("weapons/gat2.wav");
		precache_sound2 ("weapons/bombdrop.wav");
		precache_sound ("misc/metal2.wav");
		precache_model("progs/cockpit.mdl");
		precache_model("progs/ffar.mdl");
		precache_model2 ("progs/acgib1.mdl");
		precache_model2 ("progs/acgib2.mdl");
		precache_model2 ("progs/acgib3.mdl");
		precache_model2 ("progs/acgib4.mdl");
		precache_model2 ("progs/acgib5.mdl");
		precache_model2 ("progs/acgib6.mdl");
		precache_model2 ("progs/acgib7.mdl");
		precache_model2 ("progs/acgib8.mdl");
		precache_model2 ("progs/bomb.mdl");
		precache_model2 ("progs/rocket2.mdl");
		precache_model2 ("progs/torpedo.mdl");
		precache_model2 ("progs/subpit.mdl");
		precache_model2 ("progs/sight.mdl");
		precache_sound ("sub/throttle.wav");
		precache_sound ("sub/ping.wav");
		precache_sound ("damage/subpain.wav");
		precache_sound ("utils/hoveron.wav");
		precache_sound ("weapons/torpedo.wav");
		precache_sound ("sub/locked.wav");
		precache_sound ("sub/lockon.wav");
	}
//	precache_sound ("player/mdeath6.wav");
	precache_model ("progs/h_demon.mdl");
	precache_sound ("demon/ddeath.wav");
	precache_sound ("demon/dhit2.wav");
	precache_sound ("demon/djump.wav");
	precache_sound ("demon/dpain1.wav");
	precache_sound ("demon/idle1.wav");
	precache_sound ("demon/sight2.wav");
	precache_model ("progs/tripbeam.mdl");		// New beam model
	precache_model ("progs/charge.mdl");
	precache_sound ("weapons/deploy.wav");
	precache_sound ("weapons/tlaser.wav");
	precache_sound ("weapons/tarbeep.wav");
	precache_model ("progs/v_bat.mdl");		// bat weapon ala qfusion mod
//	precache_sound ("player/mdeath7.wav");
	precache_sound2  ("sets/set2_4.wav");
	precache_sound ("weapons/asscan4.wav");
	precache_sound ("items/protect3.wav");
	precache_model(#MODEL_HEALTH_TEN);	// medpack model
	precache_model(#MODEL_QUAD);
	precache_model("progs/invisibl.mdl");
	precache_model(#MODEL_HEALTH_HUNDRED);
	precache_model("maps/b_bh25.bsp");
	precache_model("progs/armor.mdl");
#ifdef mtf_coop_halloween
	precache_model ("progs/potion2.mdl");
#endif
#ifdef mtf_coop_birthday
	precache_model (#MODEL_CAKE);
#endif
	precache_model2 ("progs/grenade3.mdl");
#ifdef mtf_coop_bloodmod
	precache_model ("progs/bdrop.mdl");
#endif
#ifdef mtf_coop_tgiving
	precache_model2 ("progs/duck1.mdl");
	precache_model2 ("progs/cnade3.mdl");
#endif
};
void(float att_delay) Attack_Finished = 
{
	if (self.current_weapon != 64 && self.current_weapon != 512 && self.current_weapon != 1024)	// no automatic
		if (self.current_weapon != 16 && self.current_weapon != 8 && self.current_weapon != 4 && self.current_weapon != 2) 				// no melee
			if (self.current_weapon != #WEAP_ZEROGRAVITY)
				if ( !(self.mtf_items & #MTFITEM_LIGHTGUN && self.current_weapon == 128) )
					att_delay = att_delay / MTF_Coop_AttribGain(self, #ATTRIB_QUICKSHOT);
	self.attack_finished = time + att_delay / 4;
	if ( self.#rune_time > time )
	{
		if (self.#rune_type == #RUNE_BERSERKER)
		{
			if (self.current_weapon == 16 || self.current_weapon == 8 || self.current_weapon == 4 || self.current_weapon == 2)
			{
				att_delay = .2;
			}
		}
	}
	if (self.tfstate & 32768)
	{
		self.attack_finished = time + att_delay * 3;
	}
	else
	{
		self.attack_finished = time + att_delay;
	}
};
float ( float t_wep ) GetClipSize =
{
	local float rt_amt;
	if (t_wep == 128)
{
		rt_amt = 8;
	}
	else
	if (t_wep == 256)
	{
		rt_amt = 16;
	}
	else
	if (t_wep == 2048)
	{
		rt_amt = 6;
	}
	else
	if (t_wep == 8192)
	{
		rt_amt = 4;
	}
	else
	if (t_wep == 524288)
	{
		rt_amt = 10;
	}
	if (self.clipex_attr)
		rt_amt = rt_amt + ceil(rt_amt*MTF_Coop_AttribGain(self, #ATTRIB_CLIPEX));
	return rt_amt;
};
void() ShellHit = 
{
	if (self.skin == TF_FLARE_OFF)
	{
		sound(self, 3, "weapons/shell2.wav", 0.5, TF_FLARE_OFF);
	}
	else
	{
		if (random() < 0.5)
		{
			sound(self, 3, "weapons/tink1.wav", 0.5, TF_FLARE_OFF);
		}
		else
		{
			sound(self, 3, "weapons/tink2.wav", 0.6, TF_FLARE_OFF);
		}
	}
	return;
};
void() EjectShell = 
{
	newmis = spawn();
	newmis.movetype = 10;
	newmis.solid = TF_FLARE_OFF;
	newmis.team_no = self.team_no;
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		if (self.current_weapon == 32)
		{
			newmis.velocity = v_forward * 70 + v_up * 90 + random() * v_right * -150;
		}
		else
		{
			newmis.velocity = v_forward * 70 + v_up * 90 + random() * v_right * 150;
		}
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		if (self.current_weapon == 32)
		{
			newmis.velocity = newmis.velocity * 70 + random() * v_right * -150;
		}
		else
		{
			newmis.velocity = newmis.velocity * 70 + random() * v_right * 150;
		}
		newmis.velocity_z = random() * 90;
	}
	if (random() < 0.3)
	{
		newmis.avelocity = '2000 3000 4000';
	}
	else
	{
		if (random() < 0.6)
		{
			newmis.avelocity = '4000 2000 3000';
		}
		else
		{
			newmis.avelocity = '7000 5000 1000';
		}
	}
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin + v_forward * 10 + '0 0 20');
	if (self.playerclass == 6)
	{
		newmis.nextthink = time + 1.5;
		setmodel(newmis, "progs/20mmcase.mdl");
	}
	else
	{
		newmis.nextthink = time + 3;
		setmodel(newmis, "progs/shell2.mdl");
	}
	newmis.think = SUB_Remove;
	newmis.touch = ShellHit;
	if (self.current_weapon == 128 || self.current_weapon == 256)
	{
		newmis.skin = TF_FLARE_LIT;
	}
	else
	{
		newmis.skin = TF_FLARE_OFF;
	}
};
void() StingerTouch = 
{
	if (other.takedamage)
	{
		sound(self, 3, "shambler/smack.wav", 0.8, TF_FLARE_OFF);
		return;
	}
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};
void() StingerElec = 
{
	local entity te;
	local float maxelec;
	maxelec = 0;
	self.effects = 4;
	sound(self, TF_FLARE_OFF, "weapons/lhit.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.waterlevel > TF_FLARE_LIT)
	{
		te = findradius(self.origin, 950);
		while (te)
		{
			if (Coop_IsMonster(te, #MONSTERTYPE_NORMAL) && te.waterlevel > TF_FLARE_LIT && maxelec < 8)
			{
				deathmsg = 7;
				TF_T_Damage(te, self, self.owner, 350, 2, TF_FLARE_LIT);
					
				maxelec++;
			}
			else
			if (te.classname == "player" && te.waterlevel > TF_FLARE_LIT)
			{
				if (!(te.radsuit_finished > time))
				{
					deathmsg = 7;
					TF_T_Damage(te, self, self.owner, 350, 2, TF_FLARE_LIT);
				}
			}
			te = te.chain;
		}
		remove(self);
		return;
	}
	else
	{
		remove(self);
		return;
	}
};
void() W_LaunchStinger = 
{
	local entity missile;
	if (self.no_grenades_2 < 2)
	{
		sprint(self, 2, "Not enough type 2 grenades... get more.\n");
		return;
	}
	if (!drop2)
	{
		sprint (self, 2.000000, "Toasters have been disabled by the admin!(lame)\n");
		return;
	}
	self.no_grenades_2 = self.no_grenades_2 - 2;
	sound(self, TF_FLARE_OFF, "misc/power.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	missile = spawn();
	missile.owner = self;
	missile.movetype = 10;
	missile.solid = 2;
	missile.classname = "grenade";
	missile.effects = 8;
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		missile.velocity = v_forward * 600 + v_up * 200 + crandom() * v_right * 10 + crandom() * v_up * 10;
	}
	else
	{
		missile.velocity = aim(self, 10000);
		missile.velocity = missile.velocity * 600;
		missile.velocity_z = 200;
	}
	missile.avelocity = '300 300 300';
	missile.angles = vectoangles(missile.velocity);
	missile.touch = StingerTouch;
	missile.nextthink = time + 3;
	missile.think = StingerElec;
	setmodel(missile, "progs/toaster.mdl");
	setsize(missile, '0 0 0', '0 0 0');
	setorigin(missile, self.origin);
};
void() SpyPackRemove = 
{
	sprint(self.owner, 2, "Your Ammo Trap failed...\n");
	dremove(self);
};
void () SpyPackTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if ((other.team_no == self.team_no))
	{
		return;
	}
	if ((other.bugger > 0.000000))
	{
		return;
	}
	if ((other.classname == "player"))
	{
		other.ammo_shells = 0.000000;
		other.ammo_nails = 0.000000;
		other.ammo_rockets = 0.000000;
		other.ammo_cells = 0.000000;
		other.currentammo = 0.000000;
		other.no_grenades_1 = 0.000000;
		other.no_grenades_2 = 0.000000;
		other.pk_canpabammo = 0; //rob them of their pk items. -arg
		other.pk_turretammo = 0;
		other.pk_beartrapammo = 0;
		sprint (other, 2.000000, "Your ammo has been robbed!\n");
		sound (self, 3.000000, "weapons/lock4.wav", 1.000000, 1.000000);
		sprint (self.owner, 2.000000, "Your ammo trap worked!\n");
		dremove (self);
	}
};
void() SpyPack = 
{
	local entity te;
	te = find(world, classname, "drop1");
	while (te)
	{
		if (te.owner == self)
		{
			sprint(self, 2, "1 ammo trap at a time!\n");
			return;
		}
		te = find(te, classname, "drop1");
	}
	sprint(self, 2, "You set an Ammo Trap! With caltrop sprinkles.\n");
	ScatterCaltrops(); //requires 1 type 1 grenade, self terminating. -arg death msg 48 for it.
	sound(self, 3, "weapons/lock4.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis = spawn();
	newmis.owner = self;
	newmis.enemy = self;
	newmis.health = time;
	newmis.weapon = TF_FLARE_LIT;
	newmis.movetype = 6;
	newmis.solid = TF_FLARE_OFF;
	newmis.team_no = self.team_no;
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = v_forward * 100 + v_up * 200;
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		newmis.velocity = newmis.velocity * 100;
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '0 300 0';
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin);
	newmis.nextthink = time + 180;
	newmis.think = SpyPackRemove;
	newmis.touch = SpyPackTouch;
	newmis.classname = "drop1";
	setmodel(newmis, "progs/backpack.mdl");
};
void() RemoveLavaPool = 
{
	sprint(self.owner, 2, "Your Lava has cooled...\n");
	sound(self, 4, "misc/null.wav", TF_FLARE_LIT, TF_FLARE_OFF);
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove(self);
};
void() LavaTouch = 
{
	if (other.classname != "player" && other.classname != "bot" && !Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
	{
		return;
	}
	if (other.health <= TF_FLARE_LIT)
	{
		return;
	}
	if (other.team_no < TF_FLARE_OFF && !Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
	{
		return;
	}
	if (other.takedamage)
	{
		deathmsg = 15;
		if (Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
			TF_T_Damage(other, self.owner, self.owner, 75, TF_FLARE_LIT, 16); //was 50 dmg -arg
		else
		TF_T_Damage(other, self.owner, self.owner, 6, TF_FLARE_LIT, 16); // was 2 dmg -arg
		if (random() < 0.1)
		{
			sound(other, TF_FLARE_LIT, "misc/vapeur2.wav", 0.4, TF_FLARE_OFF);
		}
		else
		{
			if (random() > 0.6)
			{
				sound(other, TF_FLARE_LIT, "player/inh2o.wav", 0.8, TF_FLARE_OFF);
			}
		}
		if (other.is_monster != 1)
		{
		if (other.classname != "bot")
		{
			stuffcmd(other, "bf\n");
		}
		if (other.team_no == self.owner.team_no)
		{
			return;
		}
		other.origin_x = self.origin_x;
		other.origin_y = self.origin_y;
		}
	}
};
void() LavaBallTouch = 
{
	if (other == self.owner)
	{
		return;
	}
	sound(self, TF_FLARE_OFF, "zombie/z_miss.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (other.takedamage)
	{
		if (!Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
		{
		if (other.classname != "player")
		{
			return;
		}
		if (other.health <= TF_FLARE_LIT)
		{
			return;
		}
		if (other.team_no < TF_FLARE_OFF)
		{
			return;
		}
		if (other.team_no == self.owner.team_no)
		{
			return;
		}
		}
		deathmsg = 15;
		TF_T_Damage(other, self, self.owner, 20, TF_FLARE_LIT, 32); // was 16 damage -arg
	}
};
void() LavaBecome = 
{
	if (self.waterlevel > TF_FLARE_OFF)
	{
		dremove(self);
	}
	setmodel(self, "progs/lavapool.mdl");
	self.avelocity = '0 0 0';
	self.effects = 8;
	deathmsg = 15;
	self.classname = "timer";
	sound(self, 4, "weapons/lavapool.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	self.angles_y = TF_FLARE_LIT;
	self.angles_x = TF_FLARE_LIT;
	self.angles_z = TF_FLARE_LIT;
	setsize(self, '-24 -24 0', '24 24 2'); // size was 12/-12 -arg
	self.nextthink = time + 30;
	self.think = RemoveLavaPool;
	self.touch = LavaTouch;
};
void() LavaPool = 
{
	if (self.has_syringe != TF_FLARE_OFF)
	{
		sprint(self, 2, "You get 1 Lava Pool at a time!\n");
		return;
	}
	self.has_syringe = TF_FLARE_LIT;
	sound(self, 3, "weapons/throw.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis = spawn();
	newmis.classname = "timer";
	newmis.owner = self;
	newmis.team_no = self.team_no;
	newmis.health = time;
	newmis.weapon = TF_FLARE_LIT;
	newmis.movetype = 6;
	newmis.solid = TF_FLARE_OFF;
	newmis.team_no = self.team_no;
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = v_forward * 400 + v_up * 200;
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		newmis.velocity = newmis.velocity * 400;
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '300 300 300';
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin);
	newmis.nextthink = time + 2;
	newmis.think = LavaBecome;
	newmis.touch = LavaBallTouch;
	setmodel(newmis, "progs/lavaball.mdl");
};
float(float tno) num_team_pipebombs = 
{
	if (tno == TF_FLARE_OFF)
	{
		return num_team_pipebombs_1;
	}
	else
	{
		if (tno == 2)
		{
			return num_team_pipebombs_2;
		}
		else
		{
			if (tno == 3)
			{
				return num_team_pipebombs_3;
			}
			else
			{
				if (tno == 4)
				{
					return num_team_pipebombs_4;
				}
			}
		}
	}
	return TF_FLARE_LIT;
};
void(float tno) ExplodeOldPipebomb = 
{
	local entity old;
	local float index;
	if (tno != TF_FLARE_LIT)
	{
		index = num_team_pipebombs(tno);
		index = index - 30 / number_of_teams;
	}
	else
	{
		index = num_world_pipebombs - 30;
	}
	old = find(world, classname, "pipebomb");
	while (index > TF_FLARE_LIT)
	{
		if (old == world)
		{
			dprint("*** ERROR: ExplodeOldPipebomb. ***\n");
			dprint("*** Please report this.        ***\n");
			num_world_pipebombs = TF_FLARE_LIT;
			num_team_pipebombs_1 = TF_FLARE_LIT;
			num_team_pipebombs_2 = TF_FLARE_LIT;
			num_team_pipebombs_3 = TF_FLARE_LIT;
			num_team_pipebombs_4 = TF_FLARE_LIT;
			return;
		}
		if (old.owner.team_no == tno || tno == TF_FLARE_LIT)
		{
			old.nextthink = time + 0.5;
			index = index - TF_FLARE_OFF;
		}
		old = find(old, classname, "pipebomb");
	}
};
void(float tno) increment_team_pipebombs = 
{
	if (tno == TF_FLARE_OFF)
	{
		num_team_pipebombs_1 = num_team_pipebombs_1 + TF_FLARE_OFF;
	}
	else
	{
		if (tno == 2)
		{
			num_team_pipebombs_2 = num_team_pipebombs_2 + TF_FLARE_OFF;
		}
		else
		{
			if (tno == 3)
			{
				num_team_pipebombs_3 = num_team_pipebombs_3 + TF_FLARE_OFF;
			}
			else
			{
				if (tno == 4)
				{
					num_team_pipebombs_4 = num_team_pipebombs_4 + TF_FLARE_OFF;
				}
			}
		}
	}
};
void() W_FireGrenade = 
{
	if (self.option == TF_FLARE_OFF)
	{
		self.currentammo = self.ammo_rockets = self.ammo_rockets - 2;
	}
	else
	{
		if (self.option4 == 1.000000)
		{
			self.currentammo = self.ammo_rockets = self.ammo_rockets - 2;
		}
		else
		{
			self.currentammo = self.ammo_rockets = self.ammo_rockets - TF_FLARE_OFF;
		}
	}
	sound(self, TF_FLARE_OFF, "weapons/launch.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	KickPlayer(-2, self);
	newmis = spawn();
	newmis.owner = self;
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "pipebomb";	// so sticky pipebombs can get exploded by EMPs
	if (self.weaponmode == TF_FLARE_LIT)
	{
		newmis.weapon = 5;
		newmis.classname = "grenade";
		newmis.skin = TF_FLARE_OFF;
		newmis.touch = GrenadeTouch;
		newmis.nextthink = time + 2.5;
	}
	else
	{
		if (self.team_no != TF_FLARE_LIT)
		{
			increment_team_pipebombs(self.team_no);
			if (num_team_pipebombs(self.team_no) > 30 / number_of_teams)
			{
				ExplodeOldPipebomb(self.team_no);
			}
		}
		else
		{
			num_world_pipebombs = num_world_pipebombs + TF_FLARE_OFF;
			if (num_world_pipebombs > 30)
			{
				ExplodeOldPipebomb(TF_FLARE_LIT);
			}
		}
		newmis.skin = 2;
		newmis.touch = PipebombTouch;
		newmis.nextthink = time + 120;
		newmis.weapon = 11;
	}
	makevectors(self.v_angle);
	if (self.v_angle_x)
	{
		if (self.option == TF_FLARE_OFF)
		{
			newmis.velocity = v_forward * 1200 + v_up * 200 + crandom() * v_right * 10 + crandom() * v_up * 10;
			newmis.option = 1;
		}
		else
		{
			newmis.velocity = v_forward * 600 + v_up * 200 + crandom() * v_right * 10 + crandom() * v_up * 10;
		}
	}
	else
	{
		newmis.velocity = aim(self, 10000);
		if (self.option == TF_FLARE_OFF)
		{
			newmis.velocity = newmis.velocity * 1200;
		}
		else
		{
			newmis.velocity = newmis.velocity * 600;
		}
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '300 300 300';
	newmis.angles = vectoangles(newmis.velocity);
	newmis.think = GrenadeExplode;
	setmodel(newmis, "progs/grenade2.mdl");
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.origin);
};
void() HoloHumm = 
{
	self.playerclass = self.playerclass + TF_FLARE_OFF;
	self.nextthink = time + TF_FLARE_OFF;
	sound(self, TF_FLARE_LIT, "ambient/100hzhum.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.playerclass > 4)
	{
		WriteByte(4, 23);
		WriteByte(4, 11);
		WriteCoord(4, self.origin_x);
		WriteCoord(4, self.origin_y);
		WriteCoord(4, self.origin_z);
		multicast(self.origin, TF_FLARE_OFF);
		if (self.playerclass > 4)
		{
			self.owner.has_holo = TF_FLARE_OFF;
			self.think = SUB_Remove;
		}
	}
};
void() HoloDood = 
{
	local entity holo;
	sound(self, TF_FLARE_OFF, "weapons/railgr1a.wav", 0.6, TF_FLARE_OFF);
	holo = spawn();
	holo.owner = self;
	holo.origin = self.origin + '0 0 24';
	holo.angles_y = self.angles_y;
	holo.angles_x = self.angles_x;
	holo.skin = self.skin;
	holo.frame = self.frame;
	holo.colormap = self.colormap;
	holo.flags = 256;
	holo.solid = TF_FLARE_OFF;
	holo.effects = 8;
	holo.movetype = 6;
	holo.team_no = self.team_no; //assign a team number for this item. make monsters "see" it an attack it.  -arg
#ifdef PL_FEM
	setmodel (holo, GetPlayerModel(self));
#else
	setmodel(holo, "progs/player.mdl");
#endif
	setsize(holo, '-16 -16 -24', '16 16 32');
	holo.classname = "player"; // what if one changes that to "player" would monsters see it ? -arg
	holo.playerclass = 0;  
	holo.nextthink = time + TF_FLARE_OFF;
	holo.think = HoloHumm;
	WriteByte(4, 23);
	WriteByte(4, 11);
	WriteCoord(4, holo.origin_x);
	WriteCoord(4, holo.origin_y);
	WriteCoord(4, holo.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
};
void() SuperLeap = 
{
	if (!airscout)
	{
		sprint(self, 2, "JetPack disabled by Admin!\n");
		return;
	}
	if (self.ammo_cells < 11)
	{
		sprint(self, 2, "Insufficient power... get more cells.\n");
		return;
	}
	if (self.tfstate & 65536)
	{
		return;
	}
	sound(self, 3, "weapons/jetjump.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	W_FireFlame();
	muzzleflash();
	self.velocity = v_forward * 900 + '0 0 250' + v_up * 100;
	self.ammo_cells = self.ammo_cells - 11;
	self.impulse = TF_FLARE_LIT;
};
void () MagTimer =
{
	local entity _l_2374;
	local string _l_2375;
	_l_2374 = self.owner;
	_l_2374.option5 = (_l_2374.option5 - 0.500000);
	_l_2375 = ftos (_l_2374.option5);
	sound (_l_2374, 0.000000, "ambient/100hzhum.wav", 1.000000, 1.000000);
	_l_2374.origin = self.origin;
	CenterPrint2 (_l_2374, "You are stuck on a mag mine!\n", _l_2375);
	if ((_l_2374.option5 < 2.000000))
	{
		_l_2374.option5 = 0.000000;
		sprint (_l_2374.enemy, 2.000000, "Your Mag Mine died...\n");
		_l_2374.enemy.has_syringe = 1.000000;
		remove (self);
		return;
	}
	self.nextthink = (time + 0.500000);
};
void () MagMineActivate =
{
	if ((other.option == 0.000000))
	{
		self.owner.has_syringe = 1.000000;
		newmis = spawn ();
		newmis.classname = "timer";
		newmis.netname = " FlashTimer";
		newmis.team_no = self.owner.team_no;
		newmis.owner = other;
		other.enemy = self.owner;
		newmis.think = MagTimer;
		newmis.nextthink = (time + 1.000000);
		newmis.origin = other.origin;
		other.is_squating = 0.000000;
	}
	other.option5 = (floor ((other.armorvalue * 0.250000)) + 3.000000);
	if ((other.option5 > 15.000000))
	{
		other.option5 = 15.000000;
	}
};
void () FlashTimer2 =
{
	local entity _l_2398;
	local string _l_2399;
	_l_2398 = self.owner;
	_l_2398.FlashTime = (_l_2398.FlashTime - 0.100000);
	if ((_l_2398.FlashTime < 0.000000))
	{
		_l_2398.FlashTime = 0.000000;
		stuffcmd (_l_2398, "v_cshift 0\n");
		remove (self);
		return;
	}
	if ((_l_2398.FlashTime < 1.700000))
	{
		_l_2399 = ftos ((_l_2398.FlashTime * 150.000000));
		stuffcmd (_l_2398, "v_cshift ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, " ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, " ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, " ");
		stuffcmd (_l_2398, _l_2399);
		stuffcmd (_l_2398, "\n");
	}
	if ((_l_2398.FlashTime >= 1.700000))
	{
		stuffcmd (_l_2398, "v_cshift 255 255 255 255\n");
	}
	if (((_l_2398.client != "zquake") && (_l_2398.client != "fuhquake")))
	{
		stuffcmd (_l_2398, "gl_polyblend 1\n");
	}
	if ((_l_2398.client == "moreqw"))
	{
		stuffcmd (_l_2398, "gl_cshiftpercent 100\n");
	}
	self.nextthink = (time + 0.100000);
};
void () FlashGrenadeExplode2 =
{
	self.owner.has_syringe = 1.000000;
	self.effects = (self.effects | 4.000000);
	WriteByte (4.000000, 23.000000);
	WriteByte (4.000000, 4.000000);
	WriteCoord (4.000000, self.origin_x);
	WriteCoord (4.000000, self.origin_y);
	WriteCoord (4.000000, self.origin_z);
	multicast (self.origin, 1.000000);
	if ((other.FlashTime == 0.000000))
	{
		newmis = spawn ();
		newmis.classname = "timer";
		newmis.netname = "FlashTimer2";
		newmis.team_no = self.owner.team_no;
		newmis.owner = other;
		newmis.think = FlashTimer2;
		newmis.nextthink = (time + 0.100000);
	}
	other.FlashTime = 2.500000;
	stuffcmd (other, "v_cshift 255 255 255 255\n");
};
void () W_FireSaw =
{
	local vector source;
	local vector org, x, y, v;
	local float r_num;
	sound (self, CHAN_WEAPON, #SOUND_CHAINSAW, true, ATTN_NORM);
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	if (trace_ent.takedamage)
	{
		deathmsg = 449;
		trace_ent.axhitme = 1;
		SpawnBlood (org, 20);
		x = '1 0 0';
		y = '0 1 0';
		v = ((x * (50 - (random () * 100))) + (y * (50 - (random () * 100))));
		r_num = random ();
		SpawnMeatSpray (org, v);
		if (trace_ent.classname == "monster_zombie")
			TF_T_Damage (trace_ent, self, self, 86, 2, 0.000000);
		else
			if (self.ammo_nails > 0)
				TF_T_Damage (trace_ent, self, self, 54, 2, 0.000000);
			else
			{
				TF_T_Damage (trace_ent, self, self, 25, 2, 0.000000);
			}
	}
	else
	{
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
	if (self.ammo_nails > 0)
		self.ammo_nails = (self.ammo_nails - 3);
	else
		self.ammo_nails = 0;
	self.currentammo = (self.ammo_nails);
};
void () W_FireAxe =
{
	local vector source;
	local vector org;
	local vector def;
	if (self.weaponmodel == #MODEL_CHAINSAW)
		return;
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	if (trace_ent.takedamage)
	{
		trace_ent.axhitme = 1;
		SpawnBlood (org, 20);
if (allow_bat == 1)
{
		if (self.playerclass == 1)
		{
			makevectors (trace_ent.v_angle);
			def = v_right;
			makevectors (self.v_angle);
	local float dist, strength;
	local vector delta;
			if ((crossproduct (def, v_forward) > 0.000000))
			{
				if (trace_ent.team_no != self.team_no && trace_ent.classname == "player")
				{
					newmis = spawn ();
					newmis.classname = "timer";
					newmis.netname = "flashtimer";
					newmis.team_no = self.owner.team_no;
					newmis.owner = trace_ent;
					newmis.think = FlashTimer;
					newmis.nextthink = (time + 0.100000);
					if (trace_ent.FlashTime < 2.25)
						trace_ent.FlashTime = 2.25;
				}
				deathmsg = 447;
				if (trace_ent.is_monster == 1)
				{
					delta = trace_ent.origin - self.origin + self.view_ofs;
					if (delta_z < 0)
						delta_z = delta_z / -2;
						delta = delta * 0.7;
	if (delta_z < 100)
	delta_z = 100;
	trace_ent.flags = trace_ent.flags - FL_ONGROUND;
	dist = vlen(delta);
	strength = 800;
	delta = normalize(delta);
	delta = delta * strength;
	delta_z *= .3;
	trace_ent.velocity = trace_ent.velocity + delta;
	TF_T_Damage (trace_ent, self, self, 185, 2, 0.000000);
	}
	else
				TF_T_Damage (trace_ent, self, self, 65, 2, 0.000000);
	}
			else
			{
				deathmsg = 446;
				if (trace_ent.is_monster == 1)
				{
					delta = trace_ent.origin - self.origin + self.view_ofs;
					if (delta_z < 0)
						delta_z = delta_z / -2;
					delta = delta * 0.7;
					if (delta_z < 100)
						delta_z = 100;
					trace_ent.flags = trace_ent.flags - FL_ONGROUND;
					dist = vlen(delta);
					strength = 800;
					delta = normalize(delta);
					delta = delta * strength;
					delta_z *= .3;
					trace_ent.velocity = trace_ent.velocity + delta;
					TF_T_Damage (trace_ent, self, self, 105, 2, 0.000000);
				}
				else
					TF_T_Damage (trace_ent, self, self, 30, 2, 0.000000);
			}
			sound(trace_ent, 3, "zombie/z_miss.wav", TF_FLARE_OFF, TF_FLARE_OFF);
			return;
	}
}
		if (((self.playerclass != 8) || (trace_ent.classname != "player" && trace_ent.is_monster != 1)))
		{
			deathmsg = 17;
			TF_T_Damage (trace_ent, self, self, 20, 2, 0.000000);
		}
		else
		{
			self.weaponmode = 1;
			self.weaponmodel = "progs/v_knife2.mdl";
			self.vw_index = 13;
			if (trace_ent.is_monster == 1)
				makevectors (trace_ent.angles);
			else
			makevectors (trace_ent.v_angle);

			def = v_right;
			makevectors (self.v_angle);
			if ((crossproduct (def, v_forward) > 0.000000))
			{
				deathmsg = 22;
				if (trace_ent.is_monster == 1)
				{
					if (other.tfstate & #MONSTER_TRANQUILIZED)
						TF_T_Damage (trace_ent, self, self, 230, 2, 0.000000);
					else
						TF_T_Damage (trace_ent, self, self, 195, 2, 0.000000);
				}
				else
				{
					TF_T_Damage (trace_ent, self, self, 120, 2, 0.000000);
				}
			}
			else
			{
				deathmsg = 17;
				TF_T_Damage (trace_ent, self, self, 40, 2, 0.000000);
			}
		}
	}
	else
	{
		sound (self, 1, "player/axhit2.wav", 1, 1);
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
};
void () W_FireSpanner =
{
	local vector source;
	local vector org;
	local float healam;
	local entity te;
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	if ((trace_ent.goal_activation & 8))
	{
		if (Activated (trace_ent, self))
		{
			DoResults (trace_ent, self, 1);
			if ((trace_ent.classname == "func_button"))
			{
				trace_ent.enemy = self;
				other = self;
				self = trace_ent;
				self.dont_do_triggerwork = 1;
				button_fire ();
				self = other;
			}
		}
		else
		{
			if ((trace_ent.else_goal != 0.000000))
			{
				te = Findgoal (trace_ent.else_goal);
				if (te)
				{
					DoResults (te, self, (trace_ent.goal_result & 2));
				}
			}
			else
			{
				sound (self, 1, "player/axhit2.wav", 1, 1);
				WriteByte (4, 23);
				WriteByte (4, 2);
				WriteByte (4, 3);
				WriteCoord (4, org_x);
				WriteCoord (4, org_y);
				WriteCoord (4, org_z);
				multicast (org, 2);
			}
		}
		return;
	}
	if (trace_ent.takedamage)
	{
		if ((trace_ent.classname == "building_dispenser"))
		{
			Engineer_UseDispenser (trace_ent);
			return;
		}
		else
		{
			if ((trace_ent.classname == "building_sentrygun"))
			{
				Engineer_UseSentryGun (trace_ent);
				return;
			}
			else
			{
				if ((trace_ent.classname == "building_sentrygun_base"))
				{
					if (trace_ent.oldenemy)
					{
						Engineer_UseSentryGun (trace_ent.oldenemy);
					}
					return;
				}
				else
				{
					if ((trace_ent.classname == "building_tesla"))
					{
						Engineer_UseTesla (trace_ent);
						return;
					}
					else
					{
					if ((trace_ent.classname == "building_camera"))
					{
						Engineer_UseCamera (trace_ent);
						return;
					}
					else
					{
					if ((trace_ent.classname == "building_teleporter"))
					{
						Engineer_UseTeleporter(trace_ent);
						return;
					}
					else
					{
					if ((trace_ent.classname == "building_fieldgen"))
					{
						Engineer_UseFieldGen (trace_ent);
						return;
					}
					else
					{
						if ((trace_ent.classname == "player"))
						{
							if (trace_ent.team_no == self.team_no) 
							{
								healam = 10;
								if ((self.ammo_cells < healam))
								{
									healam = self.ammo_cells;
								}
								if ((trace_ent.armortype == 0.000000))
								{
									return;
								}
								if (((trace_ent.maxarmor - trace_ent.armorvalue) < (healam * 4)))
								{
									healam = ceil (((trace_ent.maxarmor - trace_ent.armorvalue) / 4));
								}
								if ((healam > 0.000000))
								{
									trace_ent.armorvalue = (trace_ent.armorvalue + (healam * 4));
									if ((trace_ent.armorvalue > trace_ent.maxarmor))
									{
										trace_ent.armorvalue = trace_ent.maxarmor;
									}
									self.ammo_cells = (self.ammo_cells - healam);
									sound (trace_ent, 1, "items/repair.wav", 1, 1);
									WriteByte (4, 23);
									WriteByte (4, 2);
									WriteByte (4, 3);
									WriteCoord (4, org_x);
									WriteCoord (4, org_y);
									WriteCoord (4, org_z);
									multicast (org, 2);
									W_SetCurrentAmmo ();
								}
								return;
							}
						//rip the armor down a bit with the tool on the enemy and steal some ammo and convert to cells/shells from their vest. -arg
						self.ammo_cells = self.ammo_cells +50;
						self.ammo_shells = self.ammo_shells + 30;
						trace_ent.armorvalue = (trace_ent.armorvalue - 50);
						trace_ent.axhitme = 1;
						SpawnBlood (org, 20);
						deathmsg = 32;
						TF_T_Damage (trace_ent, self, self, 40, 2, 0.000000);
						//concuss the poor bastard to get spanner whacked. -arg
						T_RadiusBounce(trace_ent, self, 240, world);
						trace_ent.axhitme = 1;
						SpawnBlood (org, 20);
						deathmsg = 32;
						TF_T_Damage (trace_ent, self, self, 40, 2, 0.000000);
					}
					}
				}
			}
		} } } }
	}
	else
	{
		sound (self, 1, "player/axhit2.wav", 1, 1);
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
};
void () W_FireMedikit =
{
	local vector source;
	local vector org;
	local float healam;
	local entity te;
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	
	if (trace_ent.takedamage)
	{
		if ((trace_ent.classname == "building_dispenser"))
		{
			trace_ent.skin = TF_FLARE_OFF;
			return;
		}
		if ( Is_Monster(trace_ent) && trace_ent.team_no == self.team_no )
		{
			return;
		}	
		if ((trace_ent.classname == "player"))
		{
			if ((((trace_ent.team_no == self.team_no) && (self.team_no != 0.000000)) || coop))
			{
				healam = 200;
				if ((trace_ent.leg_damage > 1))
				{
					sprint (trace_ent, 2, "Your leg wound has been healed!\n");
				}
				TeamFortress_SetSpeed (trace_ent);
				te = find (world, classname, "timer");
				while ((((te.owner != trace_ent) || (te.think != ConcussionGrenadeTimer)) && (te != world)))
				{
					te = find (te, classname, "timer");
				}
				if ((te != world))
				{
					stuffcmd (trace_ent, "v_idlescale 0\n");
					SpawnBlood (org, 20);
					sprint (trace_ent, 2, "you have been healed of your concussion.\n");
					if ((te.team_no != self.team_no))
					{
						self.real_frags = (self.real_frags + 1);
						if (!(toggleflags & 128))
						{
							self.frags = self.real_frags;
						}
					}
					dremove (te);
				}
				if ((trace_ent.tfstate & 16384))
				{
					te = find (world, classname, "timer");
					while ((((te.owner != trace_ent) || (te.think != HallucinationTimer)) && (te != world)))
					{
						te = find (te, classname, "timer");
					}
					if ((te != world))
					{
						stuffcmd (trace_ent, "v_idlescale 0\n");
						trace_ent.tfstate = (trace_ent.tfstate - (trace_ent.tfstate & 16384));
						SpawnBlood (org, 20);
						sprint (trace_ent, 2, "you have been healed of your hallucinations.\n");
						if ((te.team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1);
							if (!(toggleflags & 128))
							{
								self.frags = self.real_frags;
							}
						}
						dremove (te);
					}
					else
					{
						dprint ("Warning: Error in Hallucination Timer logic.\n");
					}
				}
				if ((trace_ent.tfstate & 32768))
				{
					te = find (world, classname, "timer");
					while ((((te.owner != trace_ent) || (te.think != TranquiliserTimer)) && (te != world)))
					{
						te = find (te, classname, "timer");
					}
					if ((te != world))
					{
						trace_ent.tfstate = (trace_ent.tfstate - (trace_ent.tfstate & 32768));
						TeamFortress_SetSpeed (trace_ent);
						SpawnBlood (org, 20);
						stuffcmd (trace_ent, "v_cshift 0 0 0 0\n");
						sprint (trace_ent, 2, "you have been healed of your tranquilisation.\n");
						if ((te.team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1);
							if (!(toggleflags & 128))
							{
								self.frags = self.real_frags;
							}
						}
						dremove (te);
					}
					else
					{
						dprint ("Warning: Error in Tranquilisation Timer logic.\n");
					}
				}
				if ((trace_ent.FlashTime > 0.000000))
				{
					te = find (world, netname, "flashtimer");
					while ((((te.owner != trace_ent) || (te.classname != "timer")) && (te != world)))
					{
						te = find (te, netname, "flashtimer");
					}
					if ((te != world))
					{
						trace_ent.FlashTime = 0.000000;
						SpawnBlood (org, 20);
						stuffcmd (trace_ent, "v_cshift 0 0 0 0\n");
						if ((te.team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1);
							if (!(toggleflags & 128))
							{
								self.frags = self.real_frags;
							}
						}
						dremove (te);
					}
					else
					{
						dprint ("Warning: Error in Flash Timer logic.\n");
						trace_ent.FlashTime = 0.000000;
					}
				}
				if ((trace_ent.tfstate & 16))
				{
					healam = rint ((trace_ent.health / 2));
					trace_ent.tfstate = (trace_ent.tfstate - (trace_ent.tfstate & 16));
					deathmsg = 23;
					T_Damage (trace_ent, self, self, healam);
					SpawnBlood (org, 30);
					sprint (trace_ent, 2, "Your infection is cured!\n");
					bprint (1, trace_ent.netname);
					bprint (1, "'s infection was cured by ");
					bprint (1, self.netname);
					bprint (1, "\n");
					if ((self.classname == "player"))
					{
						sprint (self, 2, "You have healed ");
						sprint (self, 2, trace_ent.netname);
						sprint (self, 2, " of the infection.\n");
						if ((trace_ent.infection_team_no != self.team_no))
						{
							self.real_frags = (self.real_frags + 1);
							if (!(toggleflags & 128))
							{
								self.frags = self.real_frags;
							}
						}
					}
					return;
				}
				if ((trace_ent.numflames > 0.000000))
				{
					sound (trace_ent, 1, "items/r_item1.wav", 1, 1);
					trace_ent.numflames = 0.000000;
					sprint (trace_ent, 2, "The flames have been doused!\n");
					if ((self.classname == "player"))
					{
						sprint (self, 1, "You have put out ");
						sprint (self, 1, trace_ent.netname);
						sprint (self, 1, "'s fire.\n");
					}
					return;
				}
				if (((healam > 0.000000) && (trace_ent.health < trace_ent.max_health)))
				{
					if (pointcontents(trace_ent.origin) != CONTENT_LAVA && pointcontents(trace_ent.origin) != CONTENT_SLIME)
					{
						if ( trace_ent.health < (trace_ent.max_health*.9) )
						{
							if ( trace_ent.health < (trace_ent.max_health*.3) ) 
								MTF_Coop_AddServiceExp( self, trace_ent, 20, #SRV_HEAL );
							else
							if ( trace_ent.health < (trace_ent.max_health*.5) ) 
								MTF_Coop_AddServiceExp( self, trace_ent, 15, #SRV_HEAL );
							else
							if ( trace_ent.health < (trace_ent.max_health*.7) ) 
								MTF_Coop_AddServiceExp( self, trace_ent, 10, #SRV_HEAL );
							else 
							MTF_Coop_AddServiceExp( self, trace_ent, 5, #SRV_HEAL );
							Achievements_Change( self, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_HEAL, 1 );
						}
					}
					sound (trace_ent, 1, "items/r_item1.wav", 1, 1);
					trace_ent.axhitme = 1;
					SpawnBlood (org, 20);
					T_Heal (trace_ent, healam, 0.000000);
				}
				else
				{
					if (((trace_ent.health >= trace_ent.max_health) && (trace_ent.health < (trace_ent.max_health + 51))))
					{
						healam = 5;
						if ((healam > (self.ammo_medikit * 5)))
						{
							healam = (self.ammo_medikit * 5);
						}
						if ((healam > 0.000000))
						{
							sound (trace_ent, 3, "items/r_item2.wav", 1, 1);
							T_Heal (trace_ent, healam, 1);
							self.ammo_medikit = (self.ammo_medikit - rint ((healam / 5)));
							if (!(trace_ent.items & 65536))
							{
								trace_ent.items = (trace_ent.items | 65536);
								newmis = spawn ();
								newmis.nextthink = (time + 5);
								newmis.think = item_megahealth_rot;
								newmis.owner = trace_ent;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		sound (self, 1, "player/axhit2.wav", 1, 1);
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
};
void () W_FireBioweapon =
{
	local vector source;
	local vector org;
	local entity BioInfection;
	source = (self.origin + '0 0 16');
	traceline (source, source + v_forward*64, 0.000000, self);
	if ((trace_fraction == 1))
	{
		return;
	}
	org = (trace_endpos - (v_forward * 4));
	if (trace_ent.takedamage)
	{
		if ((trace_ent.classname == "building_dispenser"))
		{
			trace_ent.skin = 1;
			return;
		}
		if ((trace_ent.classname == "building_tesla"))
		{
			return;
		}
		if ((trace_ent.classname == "building_teleporter"))
		{
			return;
		}
		if ( Is_Monster(trace_ent) && trace_ent.team_no == self.team_no )
		{
			return;
		}	
		if ((trace_ent.classname == "player"))
		{
			if (((((trace_ent.team_no != self.team_no) && (self.team_no != 0.000000)) && teamplay) || (teamplay == 0.000000)))
			{
				trace_ent.axhitme = 1;
				SpawnBlood (org, 20);
				deathmsg = 14;
				T_Damage (trace_ent, self, self, 10);
				if ((trace_ent.playerclass == 5))
				{
					return;
				}
				trace_ent.tfstate = (trace_ent.tfstate | 16);
				BioInfection = spawn ();
				BioInfection.classname = "timer";
				BioInfection.owner = trace_ent;
				BioInfection.nextthink = (time + 2);
				BioInfection.think = BioInfection_Decay;
				BioInfection.enemy = self;
				trace_ent.infection_team_no = self.team_no;
				sprint (self, 2, "Your BioAxe has Infected an enemy!\n");
			}
		}
		else
		{
			if ((trace_ent.flags & 32))
			{
				if ((trace_ent.classname == "monster_zombie"))
				{
					T_Damage (trace_ent, self, self, 200);
				}
				if (trace_ent == world)
					return;
				trace_ent.axhitme = 1;
				SpawnBlood (org, 20);
				T_Damage (trace_ent, self, self, 10);
				BioInfection = spawn ();
				BioInfection.classname = "timer";
				BioInfection.nextthink = (time + 2);
				BioInfection.think = BioInfection_MonsterDecay;
				BioInfection.owner = self;
				BioInfection.enemy = trace_ent;
			}
			else
			{
				if (trace_ent == world)
					return;
				trace_ent.axhitme = 1;
				SpawnBlood (org, 30);
				T_Damage (trace_ent, self, self, 40);
			}
		}
	}
	else
	{
		sound (self, 1, "player/axhit2.wav", 1, 1);
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, 3);
		WriteCoord (4, org_x);
		WriteCoord (4, org_y);
		WriteCoord (4, org_z);
		multicast (org, 2);
	}
};
void (vector org,vector vel) SpawnMeatSpray =
{
	local entity missile;
	missile = spawn ();
	missile.owner = self;
	missile.movetype = 10;
	missile.solid = 0.000000;
	makevectors (self.angles);
	missile.velocity = vel;
	missile.velocity_z = ((missile.velocity_z + 250) + (50 * random ()));
	missile.avelocity = '3000 1000 2000';
	missile.nextthink = (time + 1);
	missile.think = SUB_Remove;
	setmodel (missile, "progs/zom_gib.mdl");
	setsize (missile, '0 0 0', '0 0 0');
	setorigin (missile, org);
};
#ifdef mtf_coop_bloodmod
float MAX_t_dropS;
void () SpawnMeatSprayBloody_Touch;
void (vector org, vector vel, float damage) SpawnMeatSprayBloody =
{
	local entity missile;
	if (self.next_bloodtime > time)
		return;
	if ((num_blooddrops >= MAX_t_dropS))
	{
		return;
	}
	if (#DOOM_MAP || #DOOM2_MAP)
		if ((num_blooddrops >= 16))
		{
			return;
		}
	missile = spawn ();
	missile.owner = self;
	missile.movetype = 10;
	missile.solid = SOLID_TRIGGER;
	makevectors (self.angles);
	missile.velocity = vel;
	missile.velocity_z = ((missile.velocity_z + 250) + (50 * random ()));
	missile.avelocity = '3000 1000 2000';
	missile.nextthink = (time + 1);
	missile.think = SUB_Remove;
	setmodel (missile, "progs/zom_gib.mdl");
	setsize (missile, '0 0 0', '0 0 0');
	setorigin (missile, org);
	missile.health = damage;
	missile.orig_origin = self.origin;
	missile.touch = SpawnMeatSprayBloody_Touch;
};
void (entity to_bloody, float damage) bloodyme =
{
	local vector org, x, y, v;
	local entity oself;
	oself = self;
	self = to_bloody;
	org = to_bloody.origin;
	x = '1 0 0';
	y = '0 1 0';
	v = ((x * (50 - (random () * 100))) + (y * (50 - (random () * 100))));
	v *= 5;
	SpawnMeatSprayBloody (org, v, damage);
	x = '1 0 0';
	y = '0 1 0';
	v = ((x * (50 - (random () * 100))) + (y * (50 - (random () * 100))));
	v *= 5;
	SpawnMeatSprayBloody (org, v, damage);
	x = '1 0 0';
	y = '0 1 0';
	v = ((x * (50 - (random () * 100))) + (y * (50 - (random () * 100))));
	v *= 5;
	SpawnMeatSprayBloody (org, v, damage);
	self.next_bloodtime = time + 0.24;
	self=oself;
};
#endif
void (vector org,vector vel) SpawnChunk =
{
	particle (org, (vel * 0.02), 0.000000, 10);
};
void () W_FireShotgun =
{
	local vector dir;
	sound (self, 1, "weapons/guncock.wav", 1, 1);
	KickPlayer (-2.000000, self);
	self.ammo_shells = (self.ammo_shells - 1);
	self.currentammo = (self.ammo_shells);
	EjectShell ();
	dir = aim (self, 100000);
	deathmsg = 1;
	FireBullets (6, dir, '0.04 0.04 0');
};
void () W_FireNeedler;
void () W_FireSuperShotgun =
{
	local vector dir;
	if ((self.currentammo == 1))
	{
		W_FireShotgun ();
		return;
	}
	if (self.mtf_items & MTFITEM_NEEDLER)
	{
		W_FireNeedler ();
		return;
	}
	EjectShell ();
	EjectShell ();
	sound (self, 1, "weapons/shotgn2.wav", 1, 1);
	KickPlayer (-4.000000, self);
	self.ammo_shells = (self.ammo_shells - 2);
	self.currentammo = (self.ammo_shells);
	dir = aim (self, 100000);
	deathmsg = 2;
	FireBullets (14, dir, '0.14 0.08 0');
};
void (vector direction, float damage) FireSniperBullet =
{
	local vector org;
	local vector src;
	makevectors (self.v_angle);
	src = self.origin + (v_forward * 10.000000);
	src_z = self.absmin_z + (self.size_z * 0.700000);
	ClearMultiDamage ();
	traceline (src, (src + (direction * 4096.000000)), 0.000000, self);
	if ((trace_fraction != 1.000000))
	{
		TraceAttack (damage, direction);
	}
	if (trace_ent.takedamage)
	{
		org = trace_endpos - (v_forward * 4.000000);
		SpawnBlood (org, 9.000000);
	}
	else
	{
		org = trace_endpos - (v_forward * 4.000000);
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 0.000000);
		WriteCoord (4.000000, org_x);
		WriteCoord (4.000000, org_y);
		WriteCoord (4.000000, org_z);
		multicast (self.origin, 1.000000);
	}
	ApplyMultiDamage ();
};
void () W_FireSniperRifle =
{
	local vector dir;
	local vector _l_2708;
	local vector src;
	local float dam_mult;
	local float zdif;
	local float use_this;
	local float x;
	local vector f;
	local vector g;
	local vector h;
	sound (self, 1, "weapons/rifle.wav", 1, 1);
	self.ammo_shells = (self.ammo_shells - 1);
	KickPlayer (-2.000000, self);
	self.currentammo = (self.ammo_shells);
	EjectShell ();
	makevectors (self.v_angle);
	src = (self.origin + (v_forward * 10));
	src_z = (self.absmin_z + (self.size_z * 0.7));
	use_this = 0.000000;
	traceline (src, (src + (dir * 8092)), 0.000000, self);
	if ((trace_fraction != 1))
	{
		if ((trace_ent.classname == "player"))
		{
			use_this = 1;
		}
	}
	KickPlayer (-4.000000, self);
	if (!use_this)
	{
		dir = aim (self, 10000);
		traceline (src, (src + (dir * 6072)), 0.000000, self);
	}
	deathmsg = 18;
	dam_mult = 1;
	if (trace_ent)
	{
		if ((trace_ent.classname == "player"))
		{
			f = (trace_endpos - src);
			g_x = trace_endpos_x;
			g_y = trace_endpos_y;
			g_z = 0.000000;
			h_x = trace_ent.origin_x;
			h_y = trace_ent.origin_y;
			h_z = 0.000000;
			x = vlen ((g - h));
			f = ((normalize (f) * x) + trace_endpos);
			zdif = (f_z - trace_ent.origin_z);
			deathmsg = 18;
			trace_ent.head_shot_vector = '0 0 0';
			if (((zdif < 0.000000) && (trace_ent.is_squating == 0.000000)))
			{
				dam_mult = 0.5;
				if ((trace_ent.team_no != self.team_no))
				{
					trace_ent.leg_damage = (trace_ent.leg_damage + 1);
					TeamFortress_SetSpeed (trace_ent);
					deathmsg = 28;
					T_Damage (trace_ent, self, self, (self.heat * dam_mult));
				}
				if ((trace_ent.health > 0.000000))
				{
					if ((trace_ent.team_no == self.team_no))
					{
						sprint (self, 1, "Stop shooting team mates!!!\n");
					}
					else
					{
						sprint (trace_ent, 1.000000, "Leg injury!\n");
						sprint (self, 1, "Leg shot - that'll slow him down!\n");
					}
				}
				return;
			}
			else
			{
				if (((zdif > 20) || (trace_ent.is_squating == 1)))
				{
					dam_mult = 3;
					stuffcmd (trace_ent, "bf\n");
					deathmsg = 29;
					if ((trace_ent.health > 0.000000))
					{
						if ((trace_ent.team_no == self.team_no))
						{
							sprint (self, 1, "Stop shooting team mates!!!\n");
						}
						else
						{
							trace_ent.head_shot_vector = (trace_ent.origin - self.origin);
							deathmsg = 29;
							T_Damage (trace_ent, self, self, (self.heat * dam_mult));
						}
						return;
					}
					else
					{
						deathmsg = 18;
					}
				}
			}
		}
		else
		if ( Coop_IsMonster( trace_ent, #MONSTERTYPE_NORMAL ) )
		{
			f = trace_endpos - src;
			g_x = trace_endpos_x;
			g_y = trace_endpos_y;
			g_z = 0;
			h_x = trace_ent.origin_x;
			h_y = trace_ent.origin_y;
			h_z = 0;
			x = vlen(g - h);
			f = (normalize(f) * x) + trace_endpos;
			zdif = f_z - trace_ent.origin_z;
			if ( zdif < trace_ent.mins_z * 0.5 )
			{
				dam_mult = 0.5;
				trace_ent.leg_damage = (trace_ent.leg_damage + 1);	// coop_todo: make leg damage cause monsters to move slower
				sprint( self, PRINT_MEDIUM, "Leg shot - that'll slow it down!\n" );
				deathmsg = 28;
				T_Damage (trace_ent, self, self, (self.heat * dam_mult));
				return;
			}
			if ( zdif > trace_ent.maxs_z * 0.60 )
			{	// 75 old - monsters have much larger hitboxes
				if ( zdif < trace_ent.maxs_z * 0.89 || zdif > trace_ent.maxs_z * 0.99 )
				{	// so we dont get much for aiming above their heads lol
					dam_mult = 1.65;
					sprint( self, PRINT_MEDIUM, "Head shot - that's gotta hurt!\n" );
					deathmsg = 29;
					T_Damage (trace_ent, self, self, (self.heat * dam_mult));
					if (trace_ent.health <= 0)
						Achievements_Change( self, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_HEADSHOT, 1 );
					return;
				}
			}
		}
		ClearMultiDamage ();
		if ((trace_fraction != 1))
		{
			TraceAttack ((self.heat * dam_mult), dir);
		}
		ApplyMultiDamage ();
	}
	else
	{
		_l_2708 = trace_endpos - (v_forward * 4.000000);
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 0.000000);
		WriteCoord (4.000000, _l_2708_x);
		WriteCoord (4.000000, _l_2708_y);
		WriteCoord (4.000000, _l_2708_z);
		multicast (self.origin, 1.000000);
	}
};
void () W_FireAutoRifle =
{
	local vector dir;
	sound (self, 1, "weapons/rifle.wav", 1, 1);
	KickPlayer (-1.000000, self);
	self.ammo_shells = (self.ammo_shells - 1);
	self.currentammo = (self.ammo_shells);
	makevectors (self.v_angle);
	dir = v_forward;
	deathmsg = 19;
	FireSniperBullet (dir, 10);
};

void () W_FireAssaultCannon =
{
	local vector dir;
	KickPlayer (-4.000000, self);
	self.ammo_shells = (self.ammo_shells - 1);  //Reduced to 1 for each shot -arg
	self.currentammo = (self.ammo_shells);
	dir = aim (self, 100000);
	deathmsg = 20;
	FireBullets (6, dir, '0.04 0.04 0');
	Stats_Fired (self.current_weapon);
};
void () RemoveAlarmMine =
{
	sprint (self.owner, 2, "Your batteries died in an alarm.. :(\n");
	dremove (self);
	return;
};
void () RemoveAIDSMine =
{
	sprint (self.owner, 2, "Your syringe is sterile...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};
void () RemoveFlashMine =
{
	sprint (self.owner, 2, "Your Flash mine fizzled...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};
void () RemoveSpikeTrap =
{
	sprint (self.owner, 2, "Your Spike Trap is gone...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};
void () RemoveMagnetMine =
{
	sprint (self.owner, 2, "Your Mag Mine is gone...\n");
	self.owner.has_syringe = TF_FLARE_OFF;
	dremove (self);
	return;
};
void () AlarmMineTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if ((other.bugger > 0.000000))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		if ((((other.velocity_x < 5.000000) && (other.velocity_y < 5.000000)) && (other.is_squating == 1.000000)))
		{
			self.think = RemoveAlarmMine;
			self.nextthink = (time + 0.200000);
		}
		else
		{
			return;
		}
	}
	else
	{
		other.effects = (other.effects | 4.000000);
		sound (self, 3.000000, "misc/enemy.wav", 1.000000, 1.000000);
		sprint (other, 2.000000, "You have tripped an ALARM!\n");
		sprint (self.owner, 2.000000, "Your ALARM was tripped!\n");
		sprint (self.owner, 2.000000, "        Your ALARM was tripped!\n");
		self.pausetime = (time + 5.000000);
	}
	self.nextthink = (time + 10.000000);
	if ((other.effects & 4.000000))
	{
		other.effects = (other.effects - (other.effects & 8.000000));
	}
};
void () AIDSMineTouch =
{
	local entity BioInfection;
	if ((self.pausetime > time))
	{
		return;
	}
	if (Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
	{
		deathmsg = 14;
		other.tfstate = (other.tfstate | 16);
		BioInfection = spawn ();
		BioInfection.classname = "timer";
		BioInfection.owner = other;
		BioInfection.nextthink = (time + 2);
		BioInfection.think = BioInfection_MonsterDecay;
		BioInfection.enemy = self.owner;
		other.infection_team_no = self.team_no;
	}
	else
	{
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= TF_FLARE_LIT))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if ((other.playerclass == 5))
	{
		RemoveAIDSMine ();
		sprint (other, 2, "You removed an enemy syringe! :)\n");
		sprint (self.owner, 2, " Syringe removed by enemy medic!\n");
		return;
	}
	if ((other.classname == "player"))
	{
		deathmsg = 14;
		if ((other.playerclass == 5))
		{
			return;
		}
		other.tfstate = (other.tfstate | 16);
		BioInfection = spawn ();
		BioInfection.classname = "timer";
		BioInfection.owner = other;
		BioInfection.nextthink = (time + 2);
		BioInfection.think = BioInfection_Decay;
		BioInfection.enemy = self.owner;
		other.infection_team_no = self.team_no;
	}
	sound (self, 3, "player/mpain6.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	sprint (other, 2, "You're infected by a syringe! :(\n");
	}
	sprint (self.owner, 2, "Your syringe has Infected an enemy!\n");
	bprint (1, other.netname);
	bprint (1, " was infected by ");
	bprint (1, self.owner.netname);
	bprint (1, "'s syringe.\n");
	self.pausetime = (time + 5);
	self.nextthink = (time + 10);
	RemoveAIDSMine ();
};
void () FlashMineTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= TF_FLARE_LIT))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if ((other.classname == "player"))
	{
	
		FlashGrenadeExplode2 ();
		sprint (self.owner, 2, "Your Flash mine was tripped!\n");
	}
	self.nextthink = time;
	dremove (self);
};
void () SpikeTrapTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if (other.classname != "player" && Coop_IsMonster(other, #MONSTERTYPE_NORMAL) != 1)
	{
		return;
	}
	if ((other.health <= 0))
	{
		return;
	}
	if ((other.invincible_finished >= time))
	{
		if ((other.invincible_sound < time))
		{
			sound (other, 3, "items/protect3.wav", 1, 1);
			other.invincible_sound = (time + 2);
		}
		return;
	}
	if ((other.bugger > 0))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if (Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
	{
		sound (self, 3, "shambler/smack.wav", 1, 1);
		sprint (self.owner, 2, "Your Trap worked!\n");
		self.pausetime = (time + 5);
		self.nextthink = (time + 5);
		deathmsg = 200;
		TF_T_Damage (other, self.owner, self.owner, 25, 2, 0);
		if ((other.health <= 0))
		{
			return;
		}
		other.tfstate = other.tfstate | #MONSTER_TRANQUILIZED;
		return;
	}
	if ((other.playerclass == 6))
	{
		RemoveSpikeTrap ();
		sprint (other, 2, "You removed an enemy trap!\n");
		sprint (self.owner, 2, "Spike Trap removed by enemy!\n");
		sound (self, 3, "weapons/tink2.wav", 1, 1);
		return;
	}
	sound (self, 3, "shambler/smack.wav", 1, 1);
	sprint (other, 2, "You stepped on a Spike Trap!\n");
	sprint (self.owner, 2, "Your Trap worked!\n");
	self.pausetime = (time + 5);
	self.nextthink = (time + 5);
	deathmsg = 200;
	TF_T_Damage (other, self.owner, self.owner, 1, 2, 0);
	if ((other.health <= 0))
	{
		return;
	}
	other.leg_damage = (other.leg_damage + 1);
	TeamFortress_SetSpeed (other);
};
void () MagnetMineTouch =
{
	if ((self.pausetime > time))
	{
		return;
	}
	if (other.classname != "player" && Coop_IsMonster(other, #MONSTERTYPE_NORMAL) != 1)
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if ((other.bugger > 0.000000))
	{
		return;
	}
	if ((other.is_undercover == 1.000000))
	{
		return;
	}
	if ((other.team_no == self.owner.team_no))
	{
		return;
	}
	if (Coop_IsMonster(other, #MONSTERTYPE_NORMAL))
	{
		MagMineActivate ();
		sprint (self.owner, 2.000000, "Your Magnet Mine worked!\n");
		self.pausetime = (time + 5.000000);
	}
	else 
	if ((other.classname == "player"))
	{
		MagMineActivate ();
		sprint (other, 2.000000, "You stepped on a Magnetic Mine! :(\n");
		sprint (self.owner, 2.000000, "Your Magnet Mine worked!\n");
		self.pausetime = (time + 5.000000);
	}
	self.nextthink = (time + 5.000000);
	dremove (self);
};
void () Tranq_spike_touch;
void () spike_touch;
void (vector org,vector dir) Tranq_launch_spike =
{
	newmis = spawn ();
	newmis.owner = self;
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.angles = vectoangles (dir);
	newmis.touch = Tranq_spike_touch;
	newmis.weapon = 3;
	newmis.classname = "spike";
	newmis.think = SUB_Remove;
	newmis.nextthink = (time + 3);
	if ((deathmsg != 25))
	{
		setmodel (newmis, "progs/spike.mdl");
	}
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = (dir * 2000);
};
void (float type) ThrowMine =
{
	local entity item99;
	item99 = spawn ();
	item99.team_no = self.team_no;
	item99.owner = self;
	item99.classname = "drop1";
	item99.origin = (self.origin - '0.000000 0.000000 10.000000');
	if ((type == 1.000000))
	{
		item99.angles_x = 270.000000;
	}
	if ((type == 2.000000))
	{
		item99.angles_x = 0.000000;
		item99.health = 5.000000;
		item99.th_die = RemoveAIDSMine;
	}
	if ((type == 4.000000))
	{
		item99.angles_x = 90.000000;
		item99.health = 5.000000;
		item99.th_die = RemoveSpikeTrap;
	}
	item99.angles_y = 45.000000;
	item99.flags = 256.000000;
	item99.solid = 2.000000;
	item99.movetype = 6.000000;
	item99.velocity = '0.000000 0.000000 1.000000';
	setsize (item99, '-1.000000 -1.000000 0.000000', '1.000000 1.000000 6.000000');
	if ((type == 4.000000))
	{
		setmodel (item99, "progs/spikebal.mdl");
	}
	else
	{
		if ((type == 5.000000))
		{
			setmodel (item99, "progs/tgib1.mdl");
			item99.skin = 1.000000;
		}
		else
		{
			setmodel (item99, "progs/syringe.mdl");
		}
	}
	if ((type == 1.000000))
	{
		item99.touch = AlarmMineTouch;
	}
	if ((type == 2.000000))
	{
		item99.touch = AIDSMineTouch;
		item99.solid = 1;
	}
	if ((type == 3.000000))
	{
		item99.health = 1.000000;
		item99.th_die = RemoveFlashMine;
		item99.touch = FlashMineTouch;
		setmodel (item99, "progs/s_bubble.spr");
	}
	if ((type == 4.000000))
	{
		item99.touch = SpikeTrapTouch;
		item99.solid = 1;
	}
	if ((type == 5.000000))
	{
		item99.touch = MagnetMineTouch;
		setmodel (item99, "progs/tgib1.mdl");
		item99.solid = 1;
	}
	item99.nextthink = (time + 180.000000);
	if ((type == 1.000000))
	{
		item99.think = RemoveAlarmMine;
	}
	if ((type == 2.000000))
	{
		item99.think = RemoveAIDSMine;
	}
	if ((type == 3.000000))
	{
		item99.think = RemoveFlashMine;
	}
	if ((type == 4.000000))
	{
		item99.think = RemoveSpikeTrap;
	}
	if ((type == 5.000000))
	{
		item99.think = RemoveMagnetMine;
	}
};
void () A_Mine =
{
	if (((self.ammo_cells < 50) && (self.playerclass == 2)))
	{
		sprint (self, 2, "Not enough cells...\n");
		return;
	}
	self.ammo_cells = TF_FLARE_LIT;
	ThrowMine (1);
	sprint (self, 2, "You set an alarm!\n");
	sound (self, 2, "effects/beep.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};
void () B_Mine =
{
	local entity te;
	if ((self.has_syringe != 1))
	{
		sprint (self, 2, "1 syringe at a time!\n");
		return;
	}
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			sprint (self, 2, "1 syringe at a time!\n");
			return;
		}
		te = find (te, classname, "drop1");
	}

	ThrowMine (2);
	sprint (self, 2, "You dropped a syringe!\n");
	sound (self, 2, "weapons/tink1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};
void () C_Mine =
{
	local entity te;
	if ((self.has_syringe != 1))
	{
		sprint (self, 2, "1 flash mine at a time!\n");
		return;
	}
	if ((self.last_used >= time))
	{
		sprint (self, 2, "not ready yet...\n");
		return;
	}
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			sprint (self, 2, "1 flash mine at a time!\n");
			return;
		}
		te = find (te, classname, "drop1");
	}
	ThrowMine (3);
	sprint (self, 2, "You set a Flash mine! With caltrop sprinkles. \n");
	ScatterCaltrops();	//requires 1 type 1 grenade, self terminating. -arg death msg 48 for it.
	sound (self, 2, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};
void () S_Mine =
{
	local entity te;
	local float spikecount;
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			spikecount = (spikecount + TF_FLARE_OFF);
		}
		te = find (te, classname, "drop1");
	}
	if ((spikecount >= 2))
	{
		sprint (self, 2, "2 spike traps at a time!\n");
		return;
	}
	ThrowMine (4);
	sprint (self, 2, "You set a Spike Trap!\n");
	sound (self, 2, "doors/meduse.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};
void () M_Mine =
{
	local entity te;
	if ((self.has_syringe != 1.000000))
	{
		sprint (self, 2.000000, "You get 1 Mag Mine at a time!\n");
		return;
	}
	te = find (world, classname, "drop1");
	while (te)
	{
		if ((te.owner == self))
		{
			sprint (self, 2.000000, "You get 1 Mag Mine at a time!\n");
			return;
		}
		te = find (te, classname, "drop1");
	}
	ThrowMine (5.000000);
	sprint (self, 2.000000, "You set a Mag Mine!\n");
	sound (self, 2.000000, "weapons/bounce.wav", 1.000000, 1.000000);
};
void () MakeHolo =
{
	local string he;
	he = infokey(self, "tf_help");
	if ((self.playerclass == TF_FLARE_LIT))
	{
		return;
	}
	if ((self.has_holo != 1))
	{
		if (he != "off")
		{
			sprint (self, 2, "holograph already running!\n");
			return;
		}
		else
		{
			return;
		}
	}
	self.has_holo = 0.000000;
	HoloDood ();
	if (he != "off")
	{
		sprint (self, 2, "Holographic replica active!\n");
	}
};
void () BalloonMIRVtouch =
{
	if ((pointcontents (self.origin) == -6.000000))
	{
		self.velocity_z = TF_FLARE_LIT;
	}
	if ((pointcontents (self.origin) == -2.000000))
	{
		self.velocity = '0 0 0';
	}
};
void (vector org,entity shooter) BalloonMirvGrenadeLaunch =
{
	local float xdir;
	local float ydir;
	local float zdir;
	xdir = ((150 * random ()) - 75);
	ydir = ((150 * random ()) - 75);
	zdir = (40 * random ());
	newmis = spawn ();
	newmis.owner = shooter;
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "grenade";
	newmis.weapon = 40;
	newmis.touch = GrenadeTouch;
	newmis.think = GrenadeExplode;
	newmis.nextthink = ((time + 2) + (random () * 2));
	newmis.velocity_x = (xdir * 2);
	newmis.velocity_y = (ydir * 2);
	newmis.velocity_z = (zdir * 10);
	newmis.avelocity = '0 0 0';
	setmodel (newmis, #MODEL_HGREN2);
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
};
void () BalloonMIRVpop =
{
	local float i;
	sound (self, 3, "shambler/sboom.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	deathmsg = 40;
	i = TF_FLARE_LIT;
	while ((i < 6))
	{
		BalloonMirvGrenadeLaunch ((self.origin + '0 0 -1'), self.owner);
		i = (i + TF_FLARE_OFF);
	}
	BecomeExplosion ();
};
void () BalloonMIRVnoise =
{
	self.playerclass = (self.playerclass + TF_FLARE_OFF);
	self.nextthink = (time + 0.3);
	if (((self.velocity_x < 3) && (self.velocity_y < 3)))
	{
		sound (self, 0.000000, "player/axhit2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	else
	{
		sound (self, 0.000000, "weapons/throw.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	if ((self.playerclass >= 20))
	{
		self.think = BalloonMIRVpop;
	}
};
void () BalloonMIRV =
{
	if ((self.no_grenades_2 < TF_FLARE_OFF))
	{
		sprint (self, 2, "You need type 2 grens for an AirMIRV.\n");
		return;
	}
	if ((self.last_saveme_sound > time))
	{
		return;
	}
	self.last_saveme_sound = (time + 2);
	self.no_grenades_2 = (self.no_grenades_2 - TF_FLARE_OFF);
	sprint (self, 2, "AirMIRV released!\n");
	sound (self, 3, "weapons/chngnu1a.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis = spawn ();
	newmis.health = 180;
	newmis.takedamage = 2;
	newmis.th_die = BalloonMIRVpop;
	newmis.owner = self;
	newmis.weapon = 40;
	newmis.movetype = 5;
	newmis.solid = 2;
	newmis.classname = "bot";//"grenade";
	newmis.netname = "airmirv";
	newmis.playerclass = TF_FLARE_LIT;
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = ((v_forward * 100) + (v_up * 200));
	}
	else
	{
		newmis.velocity = aim (self, 10000);
		newmis.velocity = (newmis.velocity * 100);
		newmis.velocity_z = 200;
	}
	newmis.avelocity = '0 0 0';
	setsize (newmis, '-8 -8 -8', '8 8 8');
	setorigin (newmis, self.origin);
	newmis.nextthink = (time + TF_FLARE_OFF);
	newmis.think = BalloonMIRVnoise;
	newmis.touch = BalloonMIRVtouch;
	setmodel (newmis, "progs/air-mirv.mdl");
	deathmsg = 40;
};
void (entity from,float damage) LightningHit =
{
	WriteByte (4, 23);
	WriteByte (4, 13);
	WriteCoord (4, trace_endpos_x);
	WriteCoord (4, trace_endpos_y);
	WriteCoord (4, trace_endpos_z);
	multicast (trace_endpos, 2);
	TF_T_Damage (trace_ent, from, from, damage, 2, 8);
};
void (vector p1,vector p2,entity from,float damage) LightningDamage =
{
	local entity e1;
	local entity e2;
	local vector f;
	f = (p2 - p1);
	normalize (f);
	f_x = (0.000000 - f_y);
	f_y = f_x;
	f_z = 0.000000;
	f = (f * 16);
	e2 = world;
	e1 = world;
	traceline (p1, p2, 0.000000, self);
	if (trace_ent == world)
		return;
	if (trace_ent.takedamage)
	{
		LightningHit (from, damage);
		if ((self.classname == "player"))
		{
			if ((other.classname == "player"))
			{
				if (trace_ent != world)
					trace_ent.velocity_z = (trace_ent.velocity_z + 400);
			}
		}
	}
	e1 = trace_ent;
	traceline ((p1 + f), (p2 + f), 0.000000, self);
	if (((trace_ent != e1) && trace_ent.takedamage))
	{
		LightningHit (from, damage);
	}
	e2 = trace_ent;
	traceline ((p1 - f), (p2 - f), 0.000000, self);
	if ((((trace_ent != e1) && (trace_ent != e2)) && trace_ent.takedamage))
	{
		LightningHit (from, damage);
	}
};
void () W_FireLightning =
{
	local vector org;
	local float cells;
	deathmsg = 100;
	if ((self.ammo_cells < 1))
	{
  self.last_weapon = self.current_weapon;
  self.last_weaponmode = self.weaponmode;
		self.current_weapon = W_BestWeapon ();
		W_SetCurrentAmmo ();
		W_PrintWeaponMessage ();
		return;
	}
	if ((self.waterlevel > 1))
	{
		cells = self.ammo_cells;
		self.ammo_cells = 0.000000;
		W_SetCurrentAmmo ();
		deathmsg = 7;
		T_RadiusDamage (self, self, (35 * cells), world);
		return;
	}
	if ((self.t_width < time))
	{
		sound (self, 1, "weapons/lhit.wav", 1, 1);
		self.t_width = (time + 0.6);
	}
	KickPlayer (-2.000000, self);
	self.ammo_cells = (self.ammo_cells - 1);
	self.currentammo = (self.ammo_cells);
	org = (self.origin + '0 0 16');
	traceline (org, (org + (v_forward * 600)), 1, self);
	WriteByte (4, 23);
	WriteByte (4, 6);
	WriteEntity (4, self);
	WriteCoord (4, org_x);
	WriteCoord (4, org_y);
	WriteCoord (4, org_z);
	WriteCoord (4, trace_endpos_x);
	WriteCoord (4, trace_endpos_y);
	WriteCoord (4, trace_endpos_z);
	multicast (org, 1);
	LightningDamage (self.origin, (trace_endpos + (v_forward * 4)), self, 30);
};
void () W_FireSpikes =
{
	local vector dir;
	makevectors (self.v_angle);
	Stats_Fired (self.current_weapon);
	if (((self.ammo_nails >= 1) && (self.current_weapon == 1024)))
	{
		sound (self, 1, "effects/mortar.wav", 1, 1);
		deathmsg = 4;
		Attack_Finished (0.3);
		self.ammo_nails = (self.ammo_nails - 1);
		self.currentammo = (self.ammo_nails - 1);
		dir = aim (self, 1000);
		FireSniperBullet (dir, 40); // was 15
		KickPlayer (-3.000000, self);
		return;
	}
	if ((self.ammo_nails < 1))
	{
  self.last_weapon = self.current_weapon;
  self.last_weaponmode = self.weaponmode;
		self.current_weapon = W_BestWeapon ();
		W_SetCurrentAmmo ();
		W_PrintWeaponMessage ();
		return;
	}
	sound (self, 3, "weapons/sniper.wav", 1, 1);
	Attack_Finished (0.1);
	self.ammo_nails = (self.ammo_nails - 1);
	self.currentammo = (self.ammo_nails - 1);
	dir = aim (self, 1000);
	deathmsg = 3;
	FireSniperBullet (dir, 4);
};
void () spike_touch =
{
	if ((other.solid == 1))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (other.takedamage)
	{
		spawn_touchblood (9);
		deathmsg = self.weapon;
		if ((self.owner.classname == "grenade"))
		{
			TF_T_Damage (other, self, self.owner.owner, 9, 2, 2);
		}
		else
		if (self.owner.classname == "monster_wizard")
		{
			TF_T_Damage (other, self, self.owner, 5, 2, 2);
		}
		else
		{
			TF_T_Damage (other, self, self.owner, 9, 2, 2);
		}
	}
	else
	{
		WriteByte (4, 23);
		if ((self.classname == "wizspike"))
		{
			WriteByte (4, 7);
		}
		else
		{
			if ((self.classname == "knightspike"))
			{
				WriteByte (4, 8);
			}
			else
			{
				WriteByte (4, 0.000000);
			}
		}
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
		multicast (self.origin, 1);
	}
	if (self.owner.classname == "monster_wizard")
		Wizard_Bounce_Off_Walls();
	else
	dremove (self);
};
void () Tranq_spike_touch =
{
	if ((other.solid == 1))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (other.takedamage)
	{
		spawn_touchblood (9);
		deathmsg = 25;
		if ((self.owner.classname == "Tgrenade"))
		{
			TF_T_Damage (other, self, self.owner.owner, 9, 2, 2);
		}
		else
		{
			TF_T_Damage (other, self, self.owner, 9, 2, 2);
		}
	}
	else
	{
		WriteByte (4, 23);
		if ((self.classname == "wizspike"))
		{
			WriteByte (4, 7);
		}
		else
		{
			if ((self.classname == "knightspike"))
			{
				WriteByte (4, 8);
			}
			else
			{
				WriteByte (4, 0.000000);
			}
		}
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
		multicast (self.origin, 1);
	}
	dremove (self);
};
// xavior's fix for reload after proxy is selected (Added from MegaTF 11.11.05)
void (entity reloaded_player, float type_rl) W_ReloadSetCurrentAmmo =
{
	if (type_rl == 0)
	{
		reloaded_player.items = (reloaded_player.items - (reloaded_player.items & (((256 | 512) | 1024) | 2048)));
		reloaded_player.currentammo = 0;
	}
 	else
	if (type_rl == 1)
	{
		reloaded_player.currentammo = reloaded_player.ammo_shells;
		reloaded_player.items = (reloaded_player.items | 2048);
	}
	else
	if (type_rl == 3)
	{
		reloaded_player.currentammo = reloaded_player.ammo_nails;
		reloaded_player.items = (reloaded_player.items | 512);
	}
	else
	{
		reloaded_player.currentammo = reloaded_player.ammo_rockets;
		reloaded_player.items = (reloaded_player.items | 1024);
	}
	local entity oself;
	oself = self;
	self = reloaded_player;
	VWEPS_SetModel ();
	self = oself;
};
void () VWEPS_SetModel =
{
	local float vw_model;
	if (self.current_weapon != 16 && self.current_weapon != 8 && self.current_weapon != 4 && self.current_weapon != 2)
		vw_model = 7;
	else
		vw_model = 1;
	if (self.monster_type > 0)
	{
		self.vw_index = 0;
		return;
	}
	if (self.items & 524288 || self.model == "progs/mini-sub.mdl" || self.model == "progs/helo2.mdl")
	{
		self.vw_index = 31;
		return;
	}
	if (self.weaponmodel == #MODEL_V_SHOTGUN)
		vw_model = 2;
	else
	if (self.weaponmodel == "progs/v_shot2.mdl")
		vw_model = 3;
	else
	if (self.weaponmodel == "progs/v_mac10.mdl")
		vw_model = 4;
	else
	if (self.weaponmodel == "progs/v_nail2.mdl")
		vw_model = 5;
	else
	if (self.weaponmodel == "progs/v_rock.mdl")
		vw_model = 6;
	else
	if (self.weaponmodel == "progs/v_srifle.mdl")
		vw_model = 18;
	else
	if (self.weaponmodel == "progs/v_grap.mdl")
		vw_model = 19;
	else
	if (self.weaponmodel == "progs/v_rail.mdl")
		vw_model = 14;		// invalid #, but that makes the player model hold the normal sausage gun
	else
	if (self.weaponmodel == "progs/v_asscan.mdl")
		vw_model = 15;
	else
	if (self.weaponmodel == "progs/proxgren.mdl")
		vw_model = 17;
	else
	if (self.weaponmodel == #MODEL_CHAINSAW)
		vw_model = 11;
	else
	if (self.current_weapon == 32768)		// 20mm cannon
		vw_model = 5;
	else
	if (self.current_weapon == 524288)		// railgun
		vw_model = 2;
	if (self.weaponmodel == "progs/v_bio.mdl" || self.weaponmodel == "progs/v_medi.mdl")
		vw_model = 10;
	else
	if (self.weaponmodel == "progs/v_bat.mdl")
		vw_model = 9;
	else
	if (self.weaponmodel == "progs/v_knife.mdl")
		vw_model = 12;
	else
	if (self.weaponmodel == "progs/v_knife2.mdl")
		vw_model = 13;
	if (self.playerclass == 9 && self.weaponmodel == "progs/v_mac10.mdl")	// gravity gun
		vw_model = 8;
	else
	if (self.weaponmodel == "progs/v_span.mdl")
		vw_model = 16;
	else
	if (self.weaponmodel == "progs/proxgren.mdl" && self.current_weapon == 16)
		vw_model = 12;
	if ( self.mtf_items & #MTFITEM_LIGHTGUN && self.current_weapon == 128 || self.current_weapon == #WEAP_ZEROGRAVITY )
		vw_model = 8;		// LG
	if (self.tfstate & 65536 && self.is_detpacking == #TRUE)		// laying det..
		vw_model = 1;
	else
	if (self.tfstate & 65536 && self.playerclass != 8)	// building
		vw_model = 16;
	if (self.maxs_z == 8 || self.is_feigning == #TRUE)		// player is laying
		vw_model = 31;
	if (self.hook_out && (self.frame == 137 || self.frame == 138 || self.frame == 139))
		vw_model = 31; // todo: 19 looks nicer. Problem with dying in mid-air though O.o
	if (self.tfstate & 2 && self.weaponmodel != "progs/proxgren.mdl")
	{		// if reloading, dont do anything
		if (vw_model == 1 || vw_model == 31)
			self.vw_index = vw_model;
		return;
	}
#ifdef PL_FEM
	if (self.gender == GENDER_FEMALE)
		vw_model = 0;
#endif
	self.vw_index = vw_model;
};
float () W_CheckNoAmmo =
{
	if (self.current_weapon == #WEAP_ZEROGRAVITY)
		return TRUE;
	if ((self.current_weapon == 4))
	{
		return (1);
	}
	else
	{
		if ((self.current_weapon == 2))
		{
			return (1);
		}
		else
		{
			if ((((self.current_weapon == 16) || (self.current_weapon == 1)) || (self.current_weapon == 8)))
			{
				return (1);
			}
			else
			{
				if (((self.current_weapon == 1) && (self.ammo_cells < 10)))
				{
					return (1);
				}
				else
				{
					if ((self.current_weapon == 16384))
					{
						if ((self.currentammo >= 3))
						{
							return (1);
						}
					}
					else
					{
						if ((self.currentammo > 0.000000))
						{
							return (1);
						}
					}
				}
			}
		}
	}
	self.current_weapon = W_BestWeapon ();
	W_SetCurrentAmmo ();
	W_PrintWeaponMessage ();
	return (0.000000);
};
void ( entity slave, entity master ) Hax_Fixowner =
{
	if (master == world)
		return;
	if (slave.owner == world)
{
		slave.owner = master;
		bprint(2,"Hax_Fixowner: NO OWNER - TELL DEV this.\n");
	}
};
void () W_Reload_shotgun =
{
	Hax_Fixowner ( self, self.real_owner );
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = #MODEL_V_SHOTGUN;
	sound (self.owner, 1, "weapons/pkup.wav", 1, 1);
	sprint (self.owner, 0.000000, "Finished reloading. Go get some.\n");
	W_ReloadSetCurrentAmmo (self.owner, 1);
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};
void () W_Reload_super_shotgun =
{
	Hax_Fixowner ( self, self.real_owner );
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_shot2.mdl";
	sound (self.owner, 1, "weapons/pkup.wav", 1, 1);
	sprint (self.owner, 0.000000, "Finished reloading. Groovy.\n");
	W_ReloadSetCurrentAmmo (self.owner, 1);
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
	self.owner.needler_heat = 0;
};
void () W_Reload_grenade_launcher =
{
	Hax_Fixowner ( self, self.real_owner );
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_rock.mdl";
	sound (self.owner, 1, "weapons/rocklr1a.wav", 1, 1);
	sprint (self.owner, 0.000000, "Finished reloading. This is the way.\n");
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};
void () W_Reload_rocket_launcher =
{
	Hax_Fixowner ( self, self.real_owner );
	if (self.owner == world)
	{
		bprint(2,"W_Reload_rocket_launcher: WORLD OWNER - TELL DEV this.\n");
	}
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_rock2.mdl";
	sound (self.owner, 1, "weapons/rocklr1a.wav", 1, 1);
	sprint (self.owner, 0.000000, "Finished reloading. Need a light?\n");
	W_ReloadSetCurrentAmmo (self.owner, 2);
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};
void () W_Reload_rail_gun =
{
	Hax_Fixowner ( self, self.real_owner );
	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 2));
	self.owner.weaponmodel = "progs/v_rail.mdl";
	sound (self.owner, 1, "weapons/railgr1a.wav", 1, 1);
	sprint (self.owner, 0.000000, "Finished recharging. Swiss cheese em.\n");
	W_ReloadSetCurrentAmmo (self.owner, 3);
	dremove (self);
	self.owner.StatusRefreshTime = (time + 0.1);
};
float () CheckForReload =
{
	if ((self.current_weapon == 128))
	{
		if (((self.reload_shotgun >= GetClipSize(128)) && (self.ammo_shells > 0.000000)))
		{
			TeamFortress_ReloadCurrentWeapon();
			return (1);
		}
	}
	else
if ((self.current_weapon == 256))
	{
		if ((self.reload_super_shotgun > GetClipSize(256)))
		{
			self.reload_super_shotgun = GetClipSize(256);
		}
		if (((self.reload_super_shotgun >= GetClipSize(256)) && (self.ammo_shells > 0.000000)))
		{
			TeamFortress_ReloadCurrentWeapon();
			return (1);
		}
	}
	else
	if ((self.current_weapon == 2048))
	{
		if (((self.reload_grenade_launcher >= GetClipSize(2048)) && (self.ammo_rockets > 0.000000)))
		{
			TeamFortress_ReloadCurrentWeapon();
			return (1);
		}
	}
	else
	if ((self.current_weapon == 8192))
	{
		if (((self.reload_rocket_launcher >= GetClipSize(8192)) && (self.ammo_rockets > 0.000000)))
		{
			TeamFortress_ReloadCurrentWeapon();
			return (1);
		}
	}
	if (lms_entity != world)
{}							// no rg reload in LMS mode
	else
	if (self.current_weapon == 524288)
	{
		if (((self.reload_rail_gun >= GetClipSize(524288)) && (self.ammo_cells > 0.000000)))
		{
			TeamFortress_ReloadCurrentWeapon();
			return (1);
		}
	}
	return (0.000000);
};
void() player_axe1;
void() player_axeb1;
void() player_axec1;
void() player_axed1;
void() player_shot1;
void() player_nail1;
void() player_light1;
void() player_rocket1;
void() player_autorifle1;
void() player_assaultcannon1;
void() player_assaultcannonup1;
void() player_assaultcannondown1;
void() player_medikit1;
void() player_medikitb1;
void() player_medikitc1;
void() player_medikitd1;
void() player_bioweapon1;
void() player_bioweaponb1;
void() player_bioweaponc1;
void() player_bioweapond1;
void() player_chain1;
void() player_chain2;
void() player_chain3;
void() player_chain4;
void() player_chain5;
void() W_Attack =
{
	local float _l_3147;
	local entity te;
	local float tm;
			te = nextent(world);
		while (te != world)
		{
			tm+= 1;
			te = nextent(te); 
		}
		if (tm >= 512) 
		{
					te = find(world,classname,"monster");
			while (te)
			{
				dremove(te);
				te = find(te,classname,"monster");
			}
		}
	if (self.Aircraft_Owner)
	{
		Aircraft_Attack ();
		return;
	}
	if ((self.tools == (self.tools | 32)))		// SUBMARINE Owner
	{
		Sub_Attack ();
		return;
	}
	if (((self.playerclass == 0.000000) || (self.team_no <= 0.000000)))
	{
		return;
	}
	if ((self.bugger > 0.000000))
	{
		return;
	}
	if ((self.weaponmodel == "progs/spycamb.mdl"))
	{
		Cam ();
		Attack_Finished (0.200000);
		self.impulse = 0.000000;
		return;
	}
	if ((self.weaponmodel == "progs/proxgren.mdl"))
	{
		Prox ();
		Attack_Finished (0.200000);
		self.impulse = 0.000000;
		return;
	}
	if (!W_CheckNoAmmo ())
	{
		sound (self, 1.000000, "buttons/switch02.wav", 0.800000, 1.000000);
		Attack_Finished (0.050000);
		return;
	}
	if ((self.tfstate & 2.000000))
	{
		if (self.reload_ent != world)
			if (self.reload_ent.nextthink <= time)
			{
				newmis = spawn();
				newmis.classname = "timer";
				newmis.owner = self;
				newmis.think = self.reload_finished_func;
				newmis.nextthink = time;
			}
		sound (self, 1.000000, "weapons/no_ammo.wav", 0.800000, 1.000000);
		Attack_Finished (0.200000);
		return;
	}
	if ((time < self.attack_finished))
	{
		return;
	}
	if (self.monster_type > 0)
	{
		monster_attack();
		return;
	}
	if (self.is_undercover)
	{
		Spy_RemoveDisguise (self);
	}
	if ((self.is_squating == 1.000000))
	{
		unlay ();
		VWEPS_SetModel ();
	}
	Stats_Fired (self.current_weapon);
	makevectors (self.v_angle);
	self.show_hostile = (time + 1.000000);
	if ((self.current_weapon == 16.000000))
	{
		Attack_Finished (0.500000);
		sound (self, 1.000000, "weapons/ax1.wav", 1.000000, 1.000000);
		_l_3147 = random ();
		if ((_l_3147 < 0.250000))
		{
			player_axe1 ();
		}
		else
		{
			if ((_l_3147 < 0.500000))
			{
				player_axeb1 ();
			}
			else
			{
				if ((_l_3147 < 0.750000))
				{
					player_axec1 ();
				}
				else
				{
					player_axed1 ();
				}
			}
		}
	}
	else
	{
		if ((self.current_weapon == 8.000000))
		{
			Attack_Finished (0.500000);
			sound (self, 1.000000, "weapons/ax1.wav", 1.000000, 1.000000);
			player_axe1 ();
		}
		else
		{
			if ((self.current_weapon == 1.000000))
			{
				if (((!self.hook_out && (self.ammo_cells > 19.000000)) && (self.is_feigning == 0.000000)))
				{
					self.immune_to_check = (time + 4.000000);
					player_chain1 ();
					sound (self, 1.000000, "weapons/sniper.wav", 1.000000, 1.000000);
					sound (self, 3.000000, "weapons/unreel.wav", 1.000000, 1.000000);
					Attack_Finished (0.100000);
				}
				else
				{
					sprint (self, 2.000000, "Not enough power cells...\n");
					Attack_Finished (1.000000);
				}
			}
			else
			{
				if ((self.current_weapon == 128.000000))
				{
					if ( self.mtf_items & #MTFITEM_LIGHTGUN )
					{
						player_light1 ();
						Attack_Finished (0.1);
						sound (self, 0, "weapons/lstart.wav", 1, 1);
					}
					else
					{
					if ((CheckForReload () == 1.000000))  // I think this is what is causing the elec gun not selected since the reg shotgun(128) is out of ammo. -arg
					{
						return;
					}
					player_shot1 ();
					W_FireShotgun ();
					self.reload_shotgun = (self.reload_shotgun + 1.000000);
					self.StatusRefreshTime = (time + 0.100000);
					CheckForReload ();
					Attack_Finished (0.500000);
					}
				}
				else
				{
					if ((self.current_weapon == 256.000000))
					{
						if ((CheckForReload () == 1.000000))
						{
							return;
						}
						player_shot1 ();
						W_FireSuperShotgun ();
						if (self.mtf_items & MTFITEM_NEEDLER)
						{
							self.reload_super_shotgun = (self.reload_super_shotgun + 0.5);
							self.StatusRefreshTime = (time + 0.100000);
							CheckForReload ();
							if (self.needler_heat > 10)
								Attack_Finished (0.07);
							else
							if (self.needler_heat > 5)
								Attack_Finished (0.12);
							else
								Attack_Finished (0.7);
						}
						else
						{
						self.reload_super_shotgun = (self.reload_super_shotgun + 2.000000);
						self.StatusRefreshTime = (time + 0.100000);
						CheckForReload ();
						Attack_Finished (0.700000);
						}
					}
					else
					{
						if ((self.current_weapon == 512.000000))
						{
							player_nail1 ();
						}
						else
						{
							if ((self.current_weapon == 1024.000000))
							{
								player_nail1 ();
							}
							else
							{
								if ((self.current_weapon == 2048.000000))
								{
									if ((CheckForReload () == 1.000000))
									{
										return;
									}
									player_rocket1 ();
									W_FireGrenade ();
									self.reload_grenade_launcher = (self.reload_grenade_launcher + 1.000000);
									if ((self.option == 1.000000 || self.option4 == 1))
									{
										self.reload_grenade_launcher = (self.reload_grenade_launcher + 1.000000);
										if (self.useclip == 1)
										{
												self.reload_grenade_launcher = (self.reload_grenade_launcher - 1.000000);
											if (self.option == 1)
											{
												self.reload_grenade_launcher = (self.reload_grenade_launcher + 1.000000);
												if (infokey(world, "newclip") != "1")
												{
													self.reload_grenade_launcher = (self.reload_grenade_launcher + 1.000000);
												}
											}
										}
										if (self.useclip == 3)
										{
												self.reload_grenade_launcher = (self.reload_grenade_launcher + 1.000000);
										}
									}
									self.StatusRefreshTime = (time + 0.100000);
									CheckForReload ();
									Attack_Finished (0.600000);
								}
								else
								{
									if ((self.current_weapon == 8192.000000))
									{
										if ((CheckForReload () == 1.000000))
										{
											return;
										}
										player_rocket1 ();
										W_FireRocket ();
										self.reload_rocket_launcher = (self.reload_rocket_launcher + 1.000000);
										self.StatusRefreshTime = (time + 0.100000);
										CheckForReload ();
										Attack_Finished (0.800000);
									}
									else
									{
										if ((self.current_weapon == 65536.000000))
										{
											player_light1 ();
											Attack_Finished (0.100000);
											sound (self, 0.000000, "weapons/lstart.wav", 1.000000, 1.000000);
										}
										else
										{
											if ((self.current_weapon == 32.000000))
											{
												if (((self.flags & 512.000000) || self.hook_out))
												{
													player_shot1 ();
													W_FireSniperRifle ();
													Attack_Finished (1.500000);
												}
											}
											else
											{
												if ((self.current_weapon == 64.000000))
												{
													player_autorifle1 ();
													W_FireAutoRifle ();
													Attack_Finished (0.100000);
												}
												else
												{
													if ((self.current_weapon == 32768.000000))
													{
														if (((self.playerclass == 6.000000) && (self.option4 == 1.000000)))
														{
															W_FireBigAss ();
															Attack_Finished (0.200000);
															self.impulse = 0.000000;
															return;
														}
														if ((self.ammo_cells < 4.000000))
														{
															sprint (self, 1.000000, "Insufficient cells to power up the Assault Cannon.\n");
														}
														else
														{
															self.ammo_cells = (self.ammo_cells - 4.000000);
															self.heat = 1.000000;
															self.immune_to_check = (time + 2.000000);
															self.maxspeed = 80.000000;
															self.tfstate = (self.tfstate | 131072.000000);
															TeamFortress_SetSpeed (self);
															player_assaultcannonup1 ();
														}
													}
													else
													{
														if ((self.current_weapon == 4096.000000))
														{
															if ((self.last_saveme_sound <= time))
															{
																traceline (self.origin, (self.origin + (v_forward * 250.000000)), 0.000000, self);
																self.last_saveme_sound = (time + 5.000000);
																if (((trace_ent.team_no != self.team_no) && trace_ent.takedamage))
																{
																	sound (self, 3.000000, "speech/needlite.wav", 1.000000, 1.000000);
																}
															}
															player_shot1 ();
															W_FireFlame ();
															if ((self.waterlevel > 2.000000))
															{
																Attack_Finished (1.000000);
															}
															else
															{
																Attack_Finished (0.150000);
															}
														}
														else
														{
															if ((self.current_weapon == 16384.000000))
															{
																player_rocket1 ();
																W_FireIncendiaryCannon ();
																Attack_Finished (1.100000);
															}
															else
															{
																if ((self.current_weapon == 4.000000))
																{
																	sound (self, 1.000000, "weapons/ax1.wav", 1.000000, 1.000000);
																	_l_3147 = random ();
																	if ((_l_3147 < 0.250000))
																	{
																		player_medikit1 ();
																	}
																	else
																	{
																		if ((_l_3147 < 0.500000))
																		{
																			player_medikitb1 ();
																		}
																		else
																		{
																			if ((_l_3147 < 0.750000))
																			{
																				player_medikitc1 ();
																			}
																			else
																			{
																				player_medikitd1 ();
																			}
																		}
																	}
																	Attack_Finished (0.500000);
																}
																else
																{
																	if ((self.current_weapon == 2.000000))
																	{
																		sound (self, 1.000000, "weapons/ax1.wav", 1.000000, 1.000000);
																		_l_3147 = random ();
																		if ((_l_3147 < 0.250000))
																		{
																			player_bioweapon1 ();
																		}
																		else
																		{
																			if ((_l_3147 < 0.500000))
																			{
																				player_bioweaponb1 ();
																			}
																			else
																			{
																				if ((_l_3147 < 0.750000))
																				{
																					player_bioweaponc1 ();
																				}
																				else
																				{
																					player_bioweapond1 ();
																				}
																			}
																		}
																		Attack_Finished (0.500000);
																	}
																	else
																	{
																		if ((self.current_weapon == 262144.000000))
																		{
																			sound (self, 1.000000, "weapons/dartgun.wav", 1.000000, 1.000000);
																			player_shot1 ();
																			W_FireTranq ();
																			Attack_Finished (1.500000);
																		}
																		else
																		{
																			if ((self.current_weapon == 524288.000000))  //if railgun selected (weapon 2) -arg
																			{
																				if (self.mtf_items & #MTFITEM_RAILGUN)  // If you bought the upgrade, fire the uber railgun slug. -arg
																				{
																					self.option6 = 1;
																					sound (self, 1, "weapons/railgun.wav", 1, 1);
																					player_shot1 ();
																					W_FireLaser (175);
																					Attack_Finished (1.7); // speed it up just a bit from 2.5 -arg
																				}
																				else
																				{
																				if ((self.option6 != 1)) //else, fire the regular lasers.
																				{
																					if ((CheckForReload () == 1.000000))
																					{
																						return;
																					}
																					sound (self, 1, "enforcer/enfire.wav", 1, 1);
																					player_shot1 ();
																					W_FireLaser (65);
																					self.reload_rail_gun = (self.reload_rail_gun + 1);
																					Attack_Finished (0.4);
																				}
																			else  //Fire the slug -arg
																				{
																					sound (self, TF_FLARE_OFF, "weapons/railgun.wav", TF_FLARE_OFF, TF_FLARE_OFF);
																					player_shot1 ();
																					W_FireLaser (65);
																					Attack_Finished (1.5);
																				}
																			}
																		}
																			else
																			{
																				if (self.current_weapon == #WEAP_ZEROGRAVITY)
																				{
																					zg_togglepickup (self, FALSE);
																					Attack_Finished (0.4);
																				}
#ifdef NEW_CLASS1
																			else
																			{
																				if (self.current_weapon == #WEAPON_THUMPER)
																				{
																					player_shot1 ();
																					W_FireThumper ();
																					self.attack_finished = (time + 0.7);
																				}
																			
																				else
																				{
																					if (self.current_weapon == #WEAPON_CROSSBOW)
																					{
																						player_shot1 ();
																						W_FireCrossbowArrow ();
																						self.attack_finished = (time + 0.8);
																					}
																				}
																			}
#endif
																		}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
void () W_PrintWeaponMessage =
{
	if (((self.current_weapon == 16) && allow_hook))
	{
		if ((self.playerclass != 8))
		{
			if (allow_bat == 1)
			{
				if (self.playerclass == 1) // scout
					sprint (self, 1, "Bat selected.\n");
			}
			else
			{
				sprint (self, 1, "Knife selected.\n");
				self.weaponmode = 3;
			}
		}
	}
	else
	{
		if ((self.current_weapon == 1))
		{
			sprint (self, 1, "Grappling hook/harpoon selected.\n");
		}
		else
		{
			if ((self.current_weapon == 2048))
			{
				if (((self.weaponmode == 0.000000) && (self.option != 1)))
				{
					sprint (self, 1, "Normal grenade mode.\n");
					self.useclip = 1;
				}
				else
				{
					if (((self.weaponmode == 0.000000) && (self.option == 1)))
					{
						sprint (self, 1, "Long-range grenade mode.\n");
						self.useclip = 3;
						if (infokey(world, "newclip") == "1")
						{
							self.useclip = 2;
						}
					}
					else
					{
						if (((self.weaponmode == 1.000000) && (self.option4 == 1.000000)))
						{
							sprint (self, 1.000000, "Sticky Pipebomb mode.\n");
							self.useclip = 2;
							if (self.option == 1)
							{
								self.useclip = 3;
							}
						}
						else
						{
							sprint (self, 1.000000, "Pipebomb mode.\n");
							self.useclip = 1;
						}
					}
				}
			}
			else
			{
				if ((self.current_weapon == 32))
				{
					sprint (self, 1, "Sniper rifle ready.\n");
				}
				else
				{
					if ((self.current_weapon == 64))
					{
						sprint (self, 1, "Rifle on fully auto.\n");
					}
					else
					{
						if ((self.current_weapon == 262144))
						{
							sprint (self, 1, "Tranquiliser gun selected.\n");
						}
						else
						{
							if ((self.current_weapon == 2))
							{
								sprint (self, 1, "BioWeapon readied.\n");
							}
							else
							{
								if ((self.current_weapon == 4))
								{
									sprint (self, 1, "Medikit readied.\n");
								}
							}
						}
					}
				}
			}
		}
	}
};
void () W_ChangeWeapon =
{
	local float it;
	local float am;
	local float fl;
	local float have_weapon;
	local float usable;
	if (self.Aircraft_Owner)
	{
		AC_ChangeWeapon ();
		return;
	}
	if (self.tools == (self.tools | 32))
	{
		Sub_ChangeWeapon ();
		return;
	}
	if ((self.tfstate & 2.000000))
	{
		return;
	}
	if ((self.tools == (self.tools | 32.000000)))
	{
		return;
	}
	it = self.weapons_carried;
	fl = self.current_weapon;
	am = 0.000000;
	usable = 0.000000;
	have_weapon = 1.000000;
	if ((self.playerclass != 8.000000))
	{
		it = it - (it & 1.000000);
	}
	if (self.impulse == 70)
	{
		if (self.last_weapon != 0)
		{
			fl = self.last_weapon;
			if (it & self.last_weapon) 
				usable = 1;
			if (fl & (32 | 64 | 128 | 256 | 32768 | 262144) && self.ammo_shells < 1)
			{
				am = 1;
			}
			else
			{
			if (fl & (32 ) && self.ammo_shells < 1/*snip_ammo*/) 
				am = 1;
			else
			{
			if (fl & (512 | 1024 | 524288) && self.ammo_nails < 1) 
				am = 1;
			else
			{
			if (fl & (2048 | 8192) && self.ammo_rockets < 1) 
			am = 1;
			else
			{
			if (fl & (4096 | 65536) && self.ammo_cells < 1) 
				am = 1;
			else
			{
			if (fl == 16384 && self.ammo_rockets < 3) 
				am = 1;
			else
			{
			if (fl == 32768/*#WEAP_ASSAULT_CANNON*/ && self.ammo_cells < 4) 
				am = 2;
				}
				}
			}
		}
	}
}
}
}
	else
if ((self.impulse == 1.000000))
	{
		if ((fl == 8.000000))
		{
			return;
		}
		if ((((self.playerclass == 5.000000) && (fl == 2.000000)) || (fl == 4.000000)))
		{
			fl = 2.000000;
			return;
		}
		if ((fl != 16.000000))
		{
			if ((self.playerclass != 8.000000))
			{
				sound (self, 1.000000, "weapons/knifedrw.wav", 1.000000, 1.000000);
			}
		}
		while ((!usable && have_weapon))
		{
			if ((fl == 8.000000))
			{
				fl = 2.000000;
				if ((it & 2.000000))
				{
					usable = 1.000000;
				}
			}
			else
			{
				if ((fl == 2.000000))
				{
					fl = 4.000000;
					if ((it & 4.000000))
					{
						usable = 1.000000;
					}
				}
				else
				{
					if ((fl == 4.000000))
					{
						fl = 16.000000;
						usable = 1.000000;
					}
					else
					{
						if ((fl == 1.000000))
						{
							fl = 16.000000;
							usable = 1.000000;
						}
						else
						{
							fl = 8.000000;
							if ((it & 8.000000))
							{
								usable = 1.000000;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		if (((allow_hook && (self.impulse == 22.000000)) || (self.impulse == 39.000000)))
		{
			if ((self.playerclass == 8.000000))
			{
				fl = 1.000000;
			}
			else
			{
				usable = 0.000000;
			}
		}
		else
		{
			if ((self.impulse == 40.000000))
			{
				if (!(it & 30.000000))
				{
					have_weapon = 0.000000;
				}
				while ((!usable && have_weapon))
				{
					if ((fl == 8.000000))
					{
						fl = 2.000000;
						if ((it & 2.000000))
						{
							usable = 1.000000;
						}
					}
					else
					{
						if ((fl == 2.000000))
						{
							fl = 16.000000;
							if ((it & 16.000000))
							{
								usable = 1.000000;
							}
						}
						else
						{
							fl = 8.000000;
							if ((it & 8.000000))
							{
								usable = 1.000000;
							}
						}
					}
				}
			}
			else
			{
				if ((self.impulse == 2.000000))
				{
#ifdef NEW_CLASS1
											if ((it & #WEAPON_THUMPER))
											{
												fl = #WEAPON_THUMPER;
												if ((self.ammo_shells < 1.000000))
												{
													am = 1;
												}
												else
												{
													sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
												}
											}
											else
if ((it & 32.000000))
#else
					if ((it & 32.000000))
#endif
					{
						fl = 32.000000;
						if ((self.ammo_shells < 1.000000))
						{
							am = 1.000000;
						}
						else
						{
							sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
						}
					}
					else
					{
						if ((it & 128.000000))
						{
							fl = 128.000000;
							if ((self.ammo_shells < 1.000000))
							{
								am = 1.000000;
							}
							else
							{
								if ((self.playerclass != 8.000000))
								{
									sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
								}
							}
						}
						else
						{
							if ((it & 262144.000000))
							{
								fl = 262144.000000;
								if ((self.ammo_shells < 1.000000))
								{
									am = 1.000000;
								}
								else
								{
									if ((self.playerclass != 8.000000))
									{
										sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
									}
								}
							}
							else
							{
								if ((it & 524288.000000))
								{
									fl = 524288.000000;
									if ((self.ammo_nails < 1.000000))
									{
										am = 1.000000;
									}
									else
									{
										local string srailcheck;
//										srailcheck = infokey (world, "superrail");  // Allow super railgun and that allows check for Uber Rail gun. -arg
										if (self.mtf_items & #MTFITEM_RAILGUN)  //If you activate the uber railgun upgrade from inv this flag goes on, and you have to turn on srailcheck -arg
										{
											srailcheck = "1"; // You have to have this on and then uber rail gun works along side rail gun and laser gun. -arg
										}
										if ((srailcheck == "1") && self.weaponmodel != "progs/v_span.mdl" && self.weaponmodel != "progs/v_shot2.mdl")
										{

											sound (self, 1, "weapons/railgr1a.wav", 0.8, 1);
											if (((self.weaponmode == 1) && (self.option6 == 0)))
											{
												self.option6 = 1;
												sprint (self, 1.000000, "Super Railgun mode.\n");
											}
											else
											{
												if (((self.weaponmode == 1) && (self.option6 == 1)))
												{
													self.option6 = 0;
													sprint (self, 1.000000, "Regular Railgun mode.\n");
												}
											}
										}
										self.weaponmode = 1;
										if ((srailcheck != "1"))
										{
											sound (self, 1, "weapons/railgr1a.wav", 0.8, 1);
										}
									}
								}
								else
								{
									have_weapon = 0.000000;
								}
							}
						}
					}
				}
				else
				{
					if ((self.impulse == 3.000000))
					{
						if ((it & 64.000000))
						{
							fl = 64.000000;
							if ((self.ammo_shells < 1.000000))
							{
								am = 1.000000;
							}
							else
							{
								if ((self.playerclass != 8.000000))
								{
									sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
								}
							}
						}
						else
						{
							fl = 256.000000;
							if ((self.ammo_shells < 2.000000))
							{
								am = 1.000000;
							}
							else
							{
								sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
							}
						}
					}
					else
					{
						if ((self.impulse == 4.000000))
						{
#ifdef NEW_CLASS1
											if ((it & #WEAPON_CROSSBOW))
											{
												fl = #WEAPON_CROSSBOW;
												if ((self.ammo_nails < 1.000000))
												{
													am = 1;
												}
												else
												{
													sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
												}
											}
							else
							if ((it & 2048))
#else
							if ((it & 2048))
#endif
							{
								fl = 2048;
								local string stickycheck;
								stickycheck = infokey (world, "sticky");
								if ((stickycheck != "0"))
								{
												self.option4 = 1.000000;
								}
								self.weaponmode = 1;
								self.option = 0.000000;
								if ((self.ammo_rockets < 1))
								{
									am = 1;
								}
								else
								{
									sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
								}
							}
							else
							{
								fl = 512.000000;
								if ((self.ammo_nails < 1.000000))
								{
									am = 1.000000;
								}
								else
								{
									if ((self.playerclass != 8.000000))
									{
										sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
									}
								}
							}
						}
						else
						{
							if ((self.impulse == 5.000000))
							{
								if ((it & 1024.000000))
								{
									fl = 1024.000000;
									if ((self.ammo_nails < 2.000000))
									{
										am = 1.000000;
									}
									else
									{
										sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
									}
								}
								else
								{
									if ((it & 2048.000000))
									{
										fl = 2048.000000;
										if ((self.ammo_rockets < 3.000000))
										{
											am = 3.000000;
										}
										else
										{
											sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
										}
										self.weaponmode = 0.000000;
										self.option = 1.000000;
									}
									else
									{
										have_weapon = 0.000000;
									}
								}
							}
							else
							{
								if ((self.impulse == 6.000000))
								{
									if ((it & 4096.000000))
									{
										fl = 4096.000000;
										if ((self.ammo_cells < 1.000000))
										{
											am = 1.000000;
										}
										else
										{
											sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
										}
									}
									else
									{
										if ((it & 2048.000000))
										{
											fl = 2048.000000;
											if ((self.ammo_rockets < 1.000000))
											{
												am = 1.000000;
											}
											else
											{
												sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
											}
											self.weaponmode = 0.000000;
											self.option = 0.000000;
										}
										else
										{
											have_weapon = 0.000000;
										}
									}
								}
								else
								{
									if ((self.impulse == 7.000000))
									{
										if (it & #WEAP_ZEROGRAVITY)
										{
											fl = #WEAP_ZEROGRAVITY;
											am = 0;
										}
										else
										{
										if ((it & 16384.000000))
										{
											fl = 16384.000000;
											if ((self.ammo_rockets < 3.000000))
											{
												am = 1.000000;
											}
											else
											{
												sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
											}
										}
										else
										{
											if ((it & 8192.000000))
											{
												fl = 8192.000000;
												if ((self.ammo_rockets < 1.000000))
												{
													am = 1.000000;
												}
												else
												{
													sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
												}
											}
											else
											{
												if ((it & 32768.000000))
												{
													if (self.option4)
													{
														self.option4 = 0.000000;
														sprint (self, 2.000000, "Assault cannon selected.\n");
														if ((self.ammo_cells < 4.000000))
														{
															am = 2.000000;
														}
													}
													else
													{
														self.option4 = 1.000000;
														sprint (self, 2.000000, "20mm cannon selected.\n");
													}
													fl = 32768.000000;
													if ((self.ammo_shells < 1.000000))
													{
														am = 1.000000;
													}
													else
													{
														sound (self, 1.000000, "weapons/shotgr1a.wav", 0.800000, 1.000000);
													}
												}
												else
												{
													if ((it & 2048))
													{
														fl = 2048;
																	self.option4 = 0.000000;
														self.weaponmode = 1;
														self.option = 0.000000;
														if ((self.ammo_rockets < 1))
														{
															am = 1;
														}
														else
														{
															sound (self, 1.000000, "weapons/rocklr1a.wav", 0.800000, 1.000000);
														}
													}
													else
													{
														have_weapon = 0.000000;
													}
												}
											}
										}
									}
									}
									else
									{
										self.impulse = 8.000000;
										if (self.playerclass == 8.000000)
										{
											fl = 1.000000;
											if (!allow_hook)
											{
												am = 1.000000;
											}
										}
										else
										{
											self.impulse = 176.000000;
											if (self.impulse == 176.000000)
											{
												fl = 4.000000;
												if ((it & 4.000000))
												{
													usable = 1.000000;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	self.impulse = 0.000000;
	if ((!have_weapon || !(it & fl)))
	{
		sprint (self, 2.000000, "No weapon.\n");
		return;
	}
	if ((am == 1.000000))
	{
		sprint (self, 2.000000, "Not enough ammo.\n");
		return;
	}
	if ((am == 2.000000))
	{
		sprint (self, 2.000000, "Not enough cells to power assault cannon.\n");
		return;
	}
	if (self.current_weapon == #WEAP_ZEROGRAVITY && self.pickedupobject_hands != world)
		zg_drop (self, #FALSE);
	if (fl != self.current_weapon)
	{
	self.last_weapon = self.current_weapon;
	}
	self.current_weapon = fl;
	W_SetCurrentAmmo ();
	W_PrintWeaponMessage ();
	self.StatusRefreshTime = (time + 0.100000);
};
void () CycleWeaponCommand =
{
	local float it;
	local float am;
	local float cont;
	local float loopcount;
	local float lw;		// last weapon
	if (((self.weaponmodel == string_null) || (self.current_weapon == 0.000000)))
	{
		return;
	}
	if ((self.tfstate & 2))
	{
		return;
	}
	if ((self.tools == (self.tools | 32)))
	{
		return;
	}
	it = self.weapons_carried;
	self.impulse = 0.000000;
	loopcount = 0.000000;
	lw = self.current_weapon;		// last weapon
	while (1)
	{
		am = 0.000000;
		cont = 0.000000;
		if ((self.current_weapon == 16))
		{
			self.current_weapon = 8;
		}
		else
		{
			if ((self.current_weapon == 8))
			{
				self.current_weapon = 128;
				if ((self.ammo_shells < 1))
				{
					am = 1;
				}
			}
			else
			{
				if ((self.current_weapon == 128))
				{
					self.current_weapon = 524288;
					if ((self.ammo_nails < 1))
					{
						am = 1;
					}
				}
				else
				{
					if ((self.current_weapon == 524288))
					{
						self.current_weapon = 262144;
						if ((self.ammo_shells < 1))
						{
							am = 1;
						}
					}
					else
					{
						if ((self.current_weapon == 262144))
						{
							self.current_weapon = 32;
							if ((self.ammo_shells < 1))
							{
								am = 1;
							}
						}
						else
						{
							if ((self.current_weapon == 32))
							{
								self.current_weapon = 64;
								if ((self.ammo_shells < 1))
								{
									am = 1;
								}
							}
							else
							{
								if ((self.current_weapon == 64))
								{
									self.current_weapon = 256;
									if ((self.ammo_shells < 2))
									{
										am = 1;
									}
								}
								else
								{
									if ((self.current_weapon == 256))
									{
										self.current_weapon = 512;
										if ((self.ammo_nails < 1))
										{
											am = 1;
										}
									}
									else
									{
										if ((self.current_weapon == 512))
										{
											self.current_weapon = 1024;
											if ((self.ammo_nails < 2))
											{
												am = 1;
											}
										}
										else
										{
											if ((self.current_weapon == 1024))
											{
												self.current_weapon = 2048;
												self.weaponmode = 0.000000;
												if ((self.ammo_rockets < 1))
												{
													am = 1;
												}
											}
											else
											{
												if (((self.current_weapon == 2048) && (self.weaponmode == 0.000000)))
												{
													self.current_weapon = 2048;
													self.weaponmode = 1;
													if ((self.ammo_rockets < 1))
													{
														am = 1;
													}
												}
												else
												{
													if (((self.current_weapon == 2048) && (self.weaponmode == 0.000000)))
													{
														self.current_weapon = 2048;
														self.weaponmode = 0.000000;
														self.option = 1;
														if ((self.ammo_rockets < 1))
														{
															am = 1;
														}
													}
													else
													{
														if (((self.current_weapon == 2048) && (self.weaponmode == 1)))
														{
															self.current_weapon = 8192;
															if ((self.ammo_rockets < 1))
															{
																am = 1;
															}
														}
														else
														{
															if ((self.current_weapon == 8192))
															{
																self.current_weapon = 65536;
																if ((self.ammo_cells < 1))
																{
																	am = 1;
																}
															}
															else
															{
																if ((self.current_weapon == 65536))
																{
																	self.current_weapon = 4096;
																	if ((self.ammo_cells < 1))
																	{
																		am = 1;
																	}
																}
																else
																{
																	if ((self.current_weapon == 4096))
																	{
																		self.current_weapon = 16384;
																		if ((self.ammo_rockets < 3))
																		{
																			am = 1;
																		}
																	}
																	else
																	{
																		if ((self.current_weapon == 16384))
																		{
																			self.current_weapon = 32768;
																			if ((self.ammo_cells < 6))
																			{
																				am = 1;
																			}
																			if ((self.ammo_shells < 1))
																			{
																				am = 1;
																			}
																		}
																		else
																		{
																			if ((self.current_weapon == 32768))
																			{
																				self.current_weapon = 1;
																				if (!allow_hook)
																				{
																					am = 1;
																				}
																			}
																			else
																			{
																				if ((self.current_weapon == 1))
																				{
																					self.current_weapon = 2;
																				}
																				else
																				{
																					if ((self.current_weapon == 2))
																					{
																						self.current_weapon = 4;
																					}
																					else
																					{
																						if ((self.current_weapon == 4))
																						{
																							self.current_weapon = 16;
																						}
#ifdef NEW_CLASS1
																						else
																						{
																							if (((self.current_weapon == 8 || self.current_weapon == 16) && self.playerclass == #CLASS_SPECOP))
																							{
																								self.current_weapon = #WEAPON_THUMPER;
																							}
																							else
																							{
																								if ((self.current_weapon == #WEAPON_THUMPER))
																								{
																									self.current_weapon = #WEAPON_CROSSBOW;
																								}
																								else
																								{
																									if ((self.current_weapon == #WEAPON_CROSSBOW))
																									{
																										self.current_weapon = 16;
																									}
																								}
																							}
																						}
#endif
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((loopcount > 30))
		{
			return;
		}
		loopcount = (loopcount + 1);
		if (((self.weapons_carried & self.current_weapon) && (am == 0.000000)))
		{
			if ((self.current_weapon != 2048))
			{
				self.weaponmode = 0.000000;
			}
			if (self.last_weapon != lw)
{ self.last_weapon = lw; }
			W_SetCurrentAmmo ();
			W_PrintWeaponMessage ();
			self.StatusRefreshTime = (time + 0.1);
			return;
		}
	}
};
void() DeadImpulses;
void() FireUtil;
void() ImpulseCommands =
{
	local string _l_3204;
	local string lu;
	if (((!self.is_building && !self.is_detpacking) && !self.is_feigning))
	{
		if ((((((self.impulse >= 1) && (self.impulse <= 9)) && self.Aircraft_Owner) || (self.tools == (self.tools | 32))) || (self.impulse == 0)))
		{
			W_ChangeWeapon ();
		}
		else
if (self.impulse == 9)
			if (self.mtf_items & MTFITEM_NEEDLER || self.mtf_items & MTFITEM_LIGHTGUN)
			{
				if (self.mtf_items & MTFITEM_NEEDLER)
					self.mtf_items -= MTFITEM_NEEDLER;
				if (self.mtf_items & MTFITEM_LIGHTGUN)
					self.mtf_items -= MTFITEM_LIGHTGUN;
				sprint(self,2, "Special Weapons Disabled.\n");
			}
			else
			{
				if (self.coop_exp >= Coop_ExpReq(80))
//This is where you add weapons to items allowed per player when impulse 9 for special weapons is selected based on your player level -arg
//This is where new weapons could be added to the player loop of selectable ones. -arg
					self.mtf_items |= MTFITEM_NEEDLER;
		
				if (Coop_HasMasterSkill( self, #ATTRIB_QUICKSHOT ))
					self.mtf_items |= MTFITEM_LIGHTGUN;
//				if (self.coop_exp >= Coop_ExpReq(80))
//				{
//					if (self.playerclass == 3)  //This add the railgun to the soldier class as a test for over level 80. -arg
//					self.mtf_items |= MTFITEM_RAILGUN;  //rats, didnr work 9/25/21 -arg
//				}
				sprint(self,2, "Special Weapons Enabled. More coming soon.\n");
			}
	}
	if (self.Aircraft_Owner)
	{
		return;
	}
	if (self.tools == (self.tools | 32))
	{
		return;
	}
	_l_3204 = infokey (self, "tf_help");
	if (prematch)
	{
		if (((((((self.impulse == 120.000000) || (self.impulse == 136.000000)) || (self.impulse == 119.000000)) || (self.impulse == 186.000000)) || (self.impulse == 187.000000)) || ((self.impulse >= 236.000000) && (self.impulse <= 239.000000))))
		{
			DeadImpulses ();
		}
		if ((!(((self.impulse >= 1.000000) && (self.impulse < 9.000000)) || (self.impulse == 176.000000)) && !((self.impulse >= 100.000000) && (self.impulse <= 110.000000))))
		{
			self.impulse = 0.000000;
			return;
		}
	}
																								if ((self.impulse == 59.000000))
																								{
																									if (!drop3)
																									{
																										sprint (self, 2.000000, "Type 3 weapons disabled by Admin!\n");
																										self.impulse = 0.000000;
																										return;
																									}
																									if ((self.playerclass == 9.000000))
																									{
																										if ((self.last_used < time))
																										{
																											self.last_used = (time + 60.000000); // was 180 secs -arg
																											
																										}
																										else
																										{
																											lu = ftos ((self.last_used - time));
																											sprint (self, 2.000000, lu);
																											sprint (self, 2.000000, " seconds before reuse.\n");
																											stuffcmd (self, "play items/notify-1.wav\n");
																										}
																									}
																									else
																									{
																										if (self.is_feigning)
																										{
																										return;
																										}
																										
																										if (self.playerclass == 5)
																										{
																											Throw_Health(); self.impulse = 0.000000; return;
																										}
																									}
																								}
	if ((self.tools == (self.tools | 32.000000)))
	{
		return;
	}
	if (((self.last_impulse == 168.000000) && self.impulse))
	{
		TeamFortress_SetDetpack (self.impulse);
	}
	else
	{
		if (((self.last_impulse == 159.000000) && self.impulse))
		{
			TeamFortress_Scan (self.impulse);
		}
	}
	if ((((self.impulse == 8.000000) && (self.current_menu != 6.000000)) && (self.playerclass != 8.000000)))
	{
		self.current_menu = 6;
		self.menu_count = 25;
		self.menu_displaytime = 0;
	}
	if ((self.impulse == 171.000000))
	{
		UseSpecialSkill ();
	}
	if ((self.impulse == 240.000000))
	{
		bprint2 (1.000000, self.netname, " tried to cheat.\n");
		sprint (self, 2.000000, "You have been kicked for attempting to cheat. Don't do it.\n");
		stuffcmd (self, "disconnect\n");
		stuffcmd (self, "quit\n");
	}
	if (spycam)
	{
		if (((self.impulse == 55.000000) && (self.bugger > 0.000000)))
		{
			Cam ();
		}
		if ((((self.impulse == 55.000000) && (self.is_feigning == 1.000000)) && (self.bugger == 0.000000)))
		{
			Cam ();
		}
	}
	if ((((!self.is_building && !self.is_detpacking) && !self.is_feigning) && (self.bugger == 0.000000)))
	{
		if ((((self.impulse >= 1.000000) && (self.impulse < 9.000000)) || (self.impulse == 176.000000)))
		{
			if ((self.weaponmodel == "progs/proxgren.mdl"))
			{
				if ((self.oldweaponmodel != ""))
				{
					self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
				}
				self.weaponmodel = self.oldweaponmodel;
				self.currentammo = self.oldcurrentammo;
				self.StatusRefreshTime = (time + 0.100000);
			}
			if ((self.weaponmodel == "progs/spycamb.mdl"))
			{
				if ((self.oldweaponmodel != ""))
				{
					self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
				}
				self.weaponmodel = self.oldweaponmodel;
				self.currentammo = self.oldcurrentammo;
				self.StatusRefreshTime = (time + 0.100000);
			}
			W_ChangeWeapon ();
		}
		else
		{
			if ((self.impulse == 40.000000))
			{
				W_ChangeWeapon ();
			}
			else
			{
				if ((allow_hook && ((self.impulse == 22.000000) || (self.impulse == 39.000000))))
				{
					W_ChangeWeapon ();
				}
				else
				{
					if (((self.impulse == 10.000000) || (self.impulse == 12.000000)))
					{
						CycleWeaponCommand ();
					}
					else
					{
						if ((self.impulse == 150.000000))
						{
							TeamFortress_PrimeGrenade ();
						}
						else
						{
							if ((self.impulse == 151.000000))
							{
								TeamFortress_PrimeGrenade ();
							}
							else
							{
								if ((self.impulse == 173.000000))
								{
									TeamFortress_ReloadCurrentWeapon ();
								}
								else
								{
									if ((self.impulse == 162.000000))
									{
										TeamFortress_Scan (10.000000);
									}
									else
									{
										if ((self.impulse == 163.000000))
										{
											TeamFortress_Scan (30.000000);
										}
										else
										{
											if ((self.impulse == 164.000000))
											{
												TeamFortress_Scan (100.000000);
											}
											else
											{
												if ((self.impulse == 157.000000))
												{
													if ((self.last_saveme_sound <= time))
													{
														self.last_saveme_sound = (time + 5.000000);
														muzzleflash ();
														//sound (self, 0.000000, "speech/threat.wav", 0.700000, 0.000000);
														bprint (1, self.netname);
														bprint (1.000000, " says 'Are you threatening me?!'\n");
														self.impulse = 0.000000;
													}
												}
												else
												{
													if ((self.impulse == 156.000000))
													{
														if ((self.last_saveme_sound <= time))
														{
															self.last_saveme_sound = (time + 5.000000);
															muzzleflash ();
															bprint (1, self.netname);
															bprint (1.000000, " Hey! HEH HEH!!\n");
															self.impulse = 0.000000;
														}
													}
													else
													{
														if ((self.impulse == 58.000000))
														{
															if ((self.last_saveme_sound <= time))
															{
																self.last_saveme_sound = (time + 10.000000);
																muzzleflash ();
																bprint (1, self.netname);
																bprint (1.000000, " says 'Would like to see my bung hole?'\n");
																self.impulse = 0.000000;
															}
														}
														else
														{
															if ((self.impulse == 158.000000))
															{
																if ((self.is_squating == 1.000000))
																{
																	self.is_squating = 0.000000;
																	self.frame = 0.000000;
																	unlay ();
																	sprint (self, 2.000000, "Standing mode, (normal).\n");
																	VWEPS_SetModel ();
																}
																else
																{
																	if (laymode == 0)
																	{
																		sprint (self, 2, "Lay mode has been disabled by the admin!\n"); 
																	}
																	else
																	{
																		self.is_squating = 1.000000;
																		lay ();
																		sprint (self, 2.000000, "Laying mode, (stop walking to lay).\n");
																	}
																}
															}
															else
															{
																if ((self.impulse == 155.000000))
																{
																	if ((self.playerclass == 1.000000))
																	{
																		SuperLeap ();
																	}
																	if (infokey (world, "fteserver") != "1")
																	{
																	}
																	self.movetype = 3.000000;
																}
																else
																{
																	if ((self.impulse == 154.000000))
																	{
																		sprint (self, 2.000000, "--- Airscout Info ---\n");
																		sprint (self, 2.000000, "Def: A Scout that can jump very high\n");
																		sprint (self, 2.000000, "Cmd: 'jetjump' or Impulse 155.\n");
																		sprint (self, 2.000000, "    Uses 25 battery cells per jump.\n");
																		sprint (self, 2.000000, "    Aim higher than you want to go.\n");
																		sprint (self, 2.000000, "Use:  Must be a scout,\n");
																		self.impulse = 0.000000;
																	}
																	else
																	{
																		if (((self.impulse == 190.000000) && (self.flags & 512.000000)))
																		{
																			if (!drop1)
																			{
																				sprint (self, 2.000000, "Type 1 weapons disabled by Admin!\n");
																				self.impulse = 0.000000;
																				return;
																			}
																			if ((self.playerclass == 2.000000))
																			{
																				A_Mine ();
																				self.impulse = 0.000000;
																			}
																			else
																			{
																				if ((self.playerclass == 5.000000))
																				{
																					B_Mine ();
																					self.impulse = 0.000000;
																				}
																				else
																				{
																					if ((self.playerclass == 9.000000))
																					{
																						M_Mine ();
																						self.impulse = 0.000000;
																					}
																					else
																					{
																						if ((self.playerclass == 1.000000))
																						{
																							C_Mine ();
																							self.impulse = 0.000000;
																						}
																						else
																						{
																							if ((self.playerclass == 3.000000))
																							{
																								S_Mine ();
																								self.impulse = 0.000000;
																							}
																							else
																							{
																								if ((self.playerclass == 6.000000))
																								{
																									S_Mine ();
																									self.impulse = 0.000000;
																								}
																								else
																								{
																									if ((self.playerclass == 8.000000))
																									{
																										SpyPack ();
																										self.impulse = 0.000000;
																									}
																									else
																									{
																										if ((self.playerclass == 4.000000))
																										{
																											BalloonMIRV ();
																											self.impulse = 0.000000;
																										}
																										else
																										{
																											if ((self.playerclass == 7.000000))
																											{
																												LavaPool ();
																												self.impulse = 0.000000;
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																		else
																		{
																			if ((self.impulse == 201.000000))
																			{
																				W_LaunchStinger ();
																				self.impulse = 0.000000;
																			}
																			else
																			{
																				if ((self.impulse == 55.000000))
																				{
																					if (!drop3)
																					{
																						sprint (self, 2.000000, "Type 3 weapons disabled by Admin!\n");
																						self.impulse = 0.000000;
																						return;
																					}
																					if ((self.playerclass == 9.000000))
																					{
																						Drone ();
																					}
																					if ((self.playerclass == 5.000000))
																					{
																						HealSelf ();
																					}
																					if ((self.playerclass == 8.000000))
																					{
																						if (spycam)
																						{
																							Cam ();
																						}
																					}
																					if ((self.playerclass == 3.000000))
																					{
																						Prox ();
																					}
																					if ((self.playerclass == 4))
																					{
																						W_FireLTB ();
																					}
																					if ((self.playerclass == 1.000000))
																					{
																						DetpackDisarm ();
																					}
																					if (((self.playerclass == 2.000000) && (self.has_syringe == 1.000000)))
																					{
																						self.option = 9.000000;
																					}
																					self.impulse = 0.000000;
																				}
																				else
																				{
																					if ((self.impulse == 200.000000))
																					{
																						MakeHolo ();
																						self.impulse = 0.000000;
																					}
																					else
																					{
																						if ((self.impulse == 249.000000))
																						{
																							W_LaunchStinger ();
																						}
																						else
																						{
																							if ((self.impulse == 250.000000))
																							{
																								if ((self.last_saveme_sound <= time))
																								{
																									local string version_finder;
																									version_finder = infokey(world, "UBERTF");
																									
																									
																									self.last_saveme_sound = (time + 5.000000);
																									muzzleflash ();
																									//sound (self, 1.000000, "speech/pantsdwn.wav", 1.000000, 1.000000);
																									bprint (1.000000, "Come out with your pants down!\n");
																									sprint (self, 1.000000, "Uber Team Fortress ",version_finder,"\n");
																									self.impulse = 0.000000;
																								}
																							}
																							else
																							{
																								if ((self.impulse == 165.000000))
																								{
																									TeamFortress_SetDetpack (5.000000);
																								}
																								else
																								{
																									if ((self.impulse == 166.000000))
																									{
																										TeamFortress_SetDetpack (20.000000);
																									}
																									else
																									{
																										if ((self.impulse == 167.000000))
																										{
																											TeamFortress_SetDetpack (50.000000);
																										}
																										else
																										{
																											if ((self.impulse == 172.000000))
																											{
																												self.current_menu = 4.000000;
																												self.menu_count = 20.000000;
																											}
																											else
																											{
																												if ((self.impulse == 184.000000))
																												{
																													TeamFortress_Discard ();
																												}
																												else
																												{
																													if ((self.impulse == 57.000000))
																													{
																														if ((self.playerclass == 0.000000))
																														{
																															return;
																														}
																														self.current_menu = 20.000000;
																														self.menu_count = 20.000000;
																													}
																													else
																													{
																														if ((self.impulse == 53.000000))
																														{
																															if ((self.playerclass == 0.000000))
																															{
																																return;
																															}
																															self.current_menu = 21.000000;
																															self.menu_count = 20.000000;
																														}
																														else
																														{
																															if ((self.impulse == 56.000000))
																															{
																																if ((self.playerclass == 0.000000))
																																{
																																	return;
																																}
																																self.current_menu = 22.000000;
																																self.menu_count = 20.000000;
																															}
																															else
																															{
																																if ((self.impulse == 251))
																																{
																																	self.current_menu = 23;
																																	self.menu_count = 20;
																																}
																																else
																																{
																																	if ((self.impulse == 245))
																																	{
																																		voteyes ();
																																	}
																																	else
																																	{
																																		if ((self.impulse == 66))
																																		{
																																			pm_list ();
																																		}
																																		else
																																		{
																																			if ((self.impulse == 67))
																																			{
																																				drop_gravity();
																																			}
																																			else
																																			{
																																				if ((self.impulse == 68))
																																				{
																																					beartrap_dropBearTrap ();
																																				}
																																			}
																																		}
																																	}
																																}
																															}
																														}
																													}
																												}
																											}
																										}
																									}
																								}
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if ((self.impulse == 135))
	{
		TeamFortress_Inventory ();
	}
	else
	{
		if ((self.impulse == 181))
		{
			TeamFortress_SaveMe ();
		}
		else
		{
			if (((self.impulse == 50) || (self.impulse == 50)))
			{
				if ((self.vision != 1))
				{
					self.vision = 1;
					stuffcmd (self, "v_cshift 0 100 0 100\n");
				}
				else
				{
					self.vision = 0.000000;
					stuffcmd (self, "v_cshift 0 0 0 0\n");
				}
			}
			else
			{
				if ((self.impulse == 60))
				{
					TeamFortress_Spotlight();
					sprint (self, 2.000000, "Spot light On. Toggle to turn off.\n");
					self.impulse = 0.000000;
				}
				else
				{
					if (((self.impulse == 61) && (self.playerclass == 2)))
					{
						if ((self.option4 == 1.000000))
						{
							sprint (self, 2.000000, "Laser Sight On.\n");
							self.option4 = 0.000000;
						}
						else
						{
							sprint (self, 2.000000, "Laser Sight Off.\n");
							self.option4 = 1.000000;
						}
					}
					else
					{
							if ((self.impulse == 152))
							{
								TeamFortress_ThrowGrenade ();
							}
							else
							{
								if (self.impulse == 185)
								{
									TeamFortress_ID ();
								}
								else
								{
									if ((self.impulse == 170))
									{
										TeamFortress_DetonatePipebombs ();
									}
									else
									{
										if ((self.impulse == 169))
										{
											TeamFortress_DetpackStop ();
										}
										else
										{
											if ((((((self.impulse == 177) && (self.playerclass == 8))/* && (self.probe_active != 1)*/) && (self.Aircraft_Owner != 1)) && (self.tools != (self.tools | 32))))
											{
												TeamFortress_SpyGoUndercover ();
											}
											else
											{
												if ((((self.impulse == 178) && (self.playerclass == 8)) && !self.hook_out))
												{
													TeamFortress_SpyFeignDeath (0);
												}
												else
												{
												if ((((self.impulse == 180.000000) && (self.playerclass == 8.000000)) && !self.hook_out))
												{
													if ((self.weaponmodel != "progs/spycamb.mdl"))
													{
														TeamFortress_SpyFeignDeath (1.000000);
													}
												}
												else
												{
													if (((self.impulse == 179) && (self.playerclass == 9)))
													{
														TeamFortress_EngineerBuild ();
													}
													else
													{
														if ((self.impulse == 23))
														{
															if ((CTF_Map == 1))
															{
																TeamFortress_CTF_FlagInfo ();
															}
															else
															{
																TeamFortress_DisplayDetectionItems ();
															}
														}
														else
														{
															if ((self.impulse == 118))
															{
																display_location ();
															}
															else
															{
																if ((self.impulse == 191))
																{
																	FireUtil ();
																}
																else
																{
																	if ((self.impulse == 70 && self.last_weapon))
																	{
																		W_ChangeWeapon();
																	}
																	else
																	{
																		if (self.impulse != 245)
																		{
																			DeadImpulses ();
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (self.impulse == 189)
	{
		copb_eatCan();
		HealSelf();
	}
	if (self.impulse == 203)
	{
		DropFlag();
	}
	if (self.impulse == 206)
	{
		DropGoalItems();
	}
	if(self.impulse == 188)
	{
		Det_Disp();
	}
	if(self.impulse == 205)
	{
		Det_Sent();
	}
	if(self.impulse == 120)
	{
	turret_dropTurret();
	}
	if(self.impulse == 121)
	{
		if (self.playerclass == 8 || self.playerclass == 5 || self.playerclass == 1)
		{
		ScatterCaltrops();
		}
	}
	if(self.impulse == 204)
	{
		DropFlag();
	}
	if ((self.impulse == 168))
	{
		self.last_impulse = self.impulse;
	}
	if ((self.impulse == 159))
	{
		self.last_impulse = self.impulse;
	}
	self.impulse = 0.000000;
};
void() Show_Uptime;
void () Rank_ShowStats;
void () DeadImpulses =
{
	if ((self.impulse == 181))
	{
		TeamFortress_SaveMe ();
	}
	if ((self.impulse == 202))
	{
		self.current_menu = 3;
		self.menu_displaytime = 25;
		self.menu_count = 25;
		self.oldcurrentammo = 1;
	}
	if ((self.impulse == 245))
	{
		voteyes();
	}
	if ((self.impulse == 69))
	{
		Rank_ShowStats();
	}
	if ((self.impulse == 133))
	{
		Show_Uptime();
	}
	if ((self.impulse == 234.000000))
	{
		TeamFortress_ItemStatus (1);
	}
	if ((self.impulse == 235.000000))
	{
		
		TeamFortress_ItemStatus (0);
	}
	if ((self.impulse == 241.000000))
	{
		TeamFortress_ItemStatus (11.000000);
	}
	if ((self.impulse == 242.000000))
	{
		TeamFortress_ItemStatus (10.000000);
	}
	if ((self.impulse == 136))
	{
		TeamFortress_ShowTF ();
	}
	else
	{
		if ((self.impulse == 174))
		{
			TeamFortress_AutoZoomToggle ();
		}
		else
		{
			if ((self.impulse == 137))
			{
				TeamFortress_DisplayLegalClasses ();
			}
			else
			{
				if (((self.impulse >= 100) && (self.impulse <= (100 + 10))))
				{
					TeamFortress_ChangeClass ();
				}
				else
				{
					if ((self.impulse == 131))
					{
						TeamFortress_HelpMap ();
					}
					else
					{
						if ((self.impulse == 119))
						{
							TeamFortress_StatusQuery ();
						}
						else
						{
							if ((self.impulse == 140))
							{
								TeamFortress_TeamSet (1);
							}
							else
							{
								if ((self.impulse == 141))
								{
									TeamFortress_TeamSet (2);
								}
								else
								{
									if ((self.impulse == 142))
									{
										TeamFortress_TeamSet (3);
									}
									else
									{
										if ((self.impulse == 143))
										{
											TeamFortress_TeamSet (4);
										}
										else
										{
											if ((self.impulse == 145))
											{
												TeamFortress_TeamShowScores (0.000000);
											}
											else
											{
												if ((self.impulse == 144))
												{
													TeamFortress_TeamShowMemberClasses (self);
												}
												else
												{
													if ((self.impulse == 182))
													{
														self.StatusRefreshTime = (time + 0.2);
														self.StatusBarSize = (self.StatusBarSize + 1);
														if ((self.StatusBarSize > 2))
														{
															self.StatusBarSize = 1;
														}
													}
													else
													{
														if ((self.impulse == 183))
														{
															self.StatusRefreshTime = (time + 60);
															self.StatusBarSize = 0.000000;
														}
														else
														{
															if (((self.impulse >= 71) && (self.impulse <= 81)))
															{
																StatusRes ((self.impulse - 71));
															}
															else
															{
																if ((self.impulse == 13))
																{
																	sprint (self, 2, "Aliases checked.\n");
																	self.got_aliases = 1;
																	self.impulse = 0.000000;
																}
																else
																{
																	if ((self.impulse == 186.000000))
																	{
																		if ((self.autoid != 1.000000))
																		{
																			sprint (self, 2.000000, "Auto Identify On.\n");
																		}
																		self.autoid = 1.000000;
																		self.impulse = 0.000000;
																	}
																	else
																	{
																		if ((self.impulse == 187.000000))
																		{
																			if ((self.autoid != 0.000000))
																			{
																				sprint (self, 2.000000, "Auto Identify Off.\n");
																			}
																			self.autoid = 0.000000;
																			self.impulse = 0.000000;
																		}
																		else
																		{
																			if ((self.impulse == 236.000000))
																			{
																				if ((self.discard_max != 1.000000))
																				{
																					sprint (self, 2.000000, "Discarding set to Max.\n");
																				}
																				self.discard_max = 1.000000;
																				self.impulse = 0.000000;
																			}
																			else
																			{
																				if ((self.impulse == 237.000000))
																				{
																					if ((self.discard_max != 0.000000))
																					{
																						sprint (self, 2.000000, "Discarding set to Normal.\n");
																					}
																					self.discard_max = 0.000000;
																					self.impulse = 0.000000;
																				}
																				else
																				{
																					if ((self.impulse == 238.000000))
																					{
																						if ((self.autodiscard != 1.000000))
																						{
																							sprint (self, 2.000000, "Auto Discard ON.\n");
																						}
																						self.autodiscard = 1.000000;
																						self.impulse = 0.000000;
																					}
																					else
																					{
																						if ((self.impulse == 239.000000))
																						{
																							if ((self.autodiscard != 0.000000))
																							{
																								sprint (self, 2.000000, "Auto Discard OFF.\n");
																							}
																							self.autodiscard = 0.000000;
																							self.impulse = 0.000000;
																						}

																						else
																						{
																							if ((self.impulse == 128.000000))
																							{
																							}
																						}
																					}
																				}
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
void () W_WeaponFrame =
{
	local vector tv;
	local string he;
	he = infokey (self, "tf_help");
	if (!(self.tfstate & 2048.000000))
	{
		if (((self.height > 29.000000) && (self.height < 90.000000)))
		{
			self.height = (self.height + 8.000000);
			if ((self.height > 90.000000))
			{
				self.height = 90.000000;
			}
			TF_zoom (self.height);
		}
	}
	if ((self.current_menu > 0.000000))
	{
		Player_Menu ();
		if (((self.impulse > 0.000000) && (self.impulse < 11.000000)))
		{
			Menu_Input (self.impulse);
			if ((self.impulse != 0.000000))
			{
				if ((((self.team_no == 0.000000) && teamplay) && (self.lives != 0.000000)))
				{
					Menu_Team_Input (self.impulse);
				}
				else
				{
					if (((self.playerclass == 0.000000) && (self.lives != 0.000000)))
					{
						Menu_Class_Input (self.impulse);
					}
				}
			}
		}
	}
	if (self.tfstate & 32768) // if player is tranq'd, do not do this anti-sticky function
	{
		if ((time < self.attack_finished))
		{
			return;
		}
		if ((self.impulse != 0.000000))
		{
			ImpulseCommands ();
		}
	}
	else
	{
		if ((time < self.attack_finished))
		{
			if (self.impulse == 152 || self.impulse == 151 || self.impulse == 150 || self.impulse == 191)
			{
				ImpulseCommands ();
			}
			else
			{
				return;
			}
		}
	}
	if ((self.impulse != 0.000000))
	{
		ImpulseCommands ();
	}
	if ((((self.is_building != 0.000000) || (self.is_detpacking != 0.000000)) || (self.is_feigning != 0.000000)))
	{
		return;
	}
	if (self.button0)
	{
		if (self.Aircraft_Owner)
		{
			Aircraft_Attack ();
		}
		if (((self.playerclass == 6) && (self.tools == (self.tools | 32))))
		{
			Sub_Attack ();
		}
	}

	if (((!self.button0 && self.fire_held_down) && (self.current_weapon == 32768.000000)))
	{
		if ((self.tfstate & 131072.000000))
		{
			self.tfstate = (self.tfstate - 131072.000000);
		}
		self.fire_held_down = 0.000000;
		TeamFortress_SetSpeed (self);
		player_run ();
	}
	if ((self.button0 && !self.fire_held_down))
	{
		if (((self.current_menu == 6.000000) || (self.current_menu == 7.000000)))
		{
			self.current_menu = 8.000000;
			self.menu_count = 25.000000;
			Attack_Finished (0.200000);
		}
		else
		{
			if ((self.current_weapon == 32.000000))
			{
				if ((self.tfstate & 2048.000000))
				{
					if ((self.heat < 400.000000))
					{
						self.heat = (self.heat + 3.000000);
					}
					if ((self.height > 30.000000))
					{
						self.height = (self.height - 5.000000);
						TF_zoom (self.height);
					}
				}
				else
				{
					tv = self.velocity;
					tv_z = 0.000000;
					if ((vlen (tv) <= 50.000000))
					{
						SniperSight_Create ();
						self.heat = 50.000000;
						self.height = 90.000000;
						self.tfstate = (self.tfstate | 2048.000000);
						TeamFortress_SetSpeed (self);
					}
				}
			}
			else
			{
				if ((self.current_weapon == 32768))
				{
					if ((self.Aircraft_Owner || (self.tools == (self.tools | 32))))
					{
						return;
					}
					if ((self.flags & 512.000000))
					{
						SuperDamageSound ();
						W_Attack ();
					}
					else
					{
						if ((he != "off"))
						{
							if (self.offgroundmessage < time) 
							{
								sprint (self, 1.000000, "You cannot fire the assault cannon without\nyour feet on the ground...\n");
								self.offgroundmessage = time + .5;
							}
						}
					}
				}
				else
				{
					SuperDamageSound ();
					W_Attack ();
				}
			}
		}
	}
	else
	{
		if ((self.playerclass == 0.000000))
		{
			self.weaponmode = 0.000000;
		}
		else
		{
			if ((self.tfstate & 2048.000000))
			{
				W_Attack ();
				self.tfstate = (self.tfstate - 2048.000000);
				TeamFortress_SetSpeed (self);
				self.heat = 0.000000;
			}
		}
	}
};
void () SuperDamageSound =
{
	if ((self.super_damage_finished > time))
	{
		if ((self.super_sound < time))
		{
			self.super_sound = (time + 1);
			sound (self, 4, "items/damage3.wav", 1, 1);
		}
	}
	return;
};
void (float num_bubbles) DeathBubbles;
void (string gibname,float dm) ThrowGib;
void () SUB_Gib =
{
	local vector x;
	local vector y;
	local vector v;
	local float r_num;
	if ((other.team_no == self.team_no))
	{
		return;
	}
	r_num = random ();
	if ((r_num < 0.6))
	{
		x = '1 0 0';
		y = '0 1 0';
		v = ((x * (50 - (random () * 100))) + (y * (50 - (random () * 100))));
		r_num = random ();
		SpawnMeatSpray (self.origin, v);
	}
	else
	{
		if ((r_num >= 0.6))
		{
			ThrowGib ("progs/gib1.mdl", self.health);
		}
		else
		{
			ThrowGib ("progs/gib3.mdl", self.health);
		}
	}
};
void () LTB_Arm;
void () LTB_PreArm;
void () W_FireLTB =
{
	local vector source;
	local entity lasertrip;
	local entity te;
	local float numWires;
	numWires = 1;
	te = find (world, classname, "trip_bomb");
	while (te)
	{
		if ((te.real_owner == self))
		{
			numWires = (numWires + 1);
		}
		te = find (te, classname, "trip_bomb");
	}
	if ((self.no_grenades_2 < 2))
	{
		sprint (self, 2, "You need 2 Type 2 grenades\n");
		return;
	}
	if ((numWires > 1))
	{
		sprint (self, 2, "1 Laser Trip Wire at a time.\n");
		return;
	}
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if ((trace_fraction == 1))
	{
		sprint (self, 2, "Laser Trip Bomb needs to be placed on a straight wall.\n");
		return;
	}
	if ((trace_plane_normal_z != 0.000000))
	{
		sprint (self, 2, "Laser Trip Bomb needs to be placed on a straight wall.\n");
		return;
	}
	if ((trace_ent != world))
	{
		sprint (self, 2, "Laser Trip Bomb needs to be placed on a straight wall.\n");
		return;
	}
	self.no_grenades_2 = (self.no_grenades_2 - 2);
	lasertrip = spawn ();
	lasertrip.owner = self;
	lasertrip.real_owner = self;
	lasertrip.movetype = 0.000000;
	lasertrip.solid = 2;
	lasertrip.classname = "trip_bomb";
	lasertrip.team_no = self.team_no;
	lasertrip.angles = vectoangles (trace_plane_normal);
	lasertrip.takedamage = 1;
	lasertrip.health = 3;
	lasertrip.th_die = LTB_Detonate;
	lasertrip.think = LTB_PreArm;
	lasertrip.nextthink = time + .1;
	lasertrip.attack_finished = (time + 0.01);
	setmodel (lasertrip, "progs/charge.mdl");
	setsize (lasertrip, '0 0 0', '0 0 0');
	setorigin (lasertrip, trace_endpos);
	sound (self, 1, "weapons/deploy.wav", 1, 1);
	sprint (self, 2, "Laser Trip Wire bomb set.\n");
};
void () LTB_PreArm =
{
	local vector org;
	local vector targ;
	makevectors (self.angles);
	org = (self.origin + self.view_ofs);
	targ = (org + (v_forward * 187));
	traceline (org, targ, 0.000000, self);
	if ((trace_fraction == 1))
	{
		sprint (self.real_owner, 2, "Walls must be closer together.\n");
		if (self.real_owner.no_grenades_2 < 3)
			self.real_owner.no_grenades_2 = (self.real_owner.no_grenades_2 + 2);
		else
if (self.real_owner.no_grenades_2 == 3)
			self.real_owner.no_grenades_2 = (self.real_owner.no_grenades_2 + 1);
		dremove(self);
		return;
	}
	self.think = LTB_Arm;
	self.nextthink = time + .9;
};
void () LTB_Arm =
{
	local vector org;
	local vector targ;
	local float dist;
	makevectors (self.angles);
	org = (self.origin + self.view_ofs);
	targ = (org + (v_forward * 187));
	traceline (org, targ, 0.000000, self);
	if ((trace_fraction == 1))
	{
		sprint (self.real_owner, 2, "Walls must be closer together.\n");
		LTB_Explode ();
		return;
	}
	if ((trace_ent.team_no == self.team_no))
	{
		self.nextthink = (time + 1);
		self.think = LTB_Arm;
		return;
	}
	if ((self.weapon == 0.000000))
	{
		self.weapon = 1;
	}
	if ((self.attack_finished < time))
	{
		self.movetype = 0.000000;
		self.solid = 2;
		self.takedamage = 1;
		setmodel (self, "progs/tripbeam.mdl");
		dist = vlen(org - trace_endpos);
		if (dist > 150)
			self.frame = #FRAME_125PERCENT;
		else
		if (dist > 112)
			self.frame = #FRAME_100PERCENT;
		else
		if (dist > 75)
			self.frame = #FRAME_75PERCENT;
		else
		if (dist > 37)
			self.frame = #FRAME_50PERCENT;
		else
			self.frame = #FRAME_25PERCENT;
		self.skin = (self.owner.team_no - 1);
		sound (self, 3, "weapons/tlaser.wav", 0.5, 1);
		self.attack_finished = (time + 0.02);
	}
	self.think = LTB_Arm;
	self.nextthink = (time + 0.07);
	if (other.team_no == self.team_no || other.undercover_team == self.team_no)
	{
		return;
	}
	if (((trace_ent.velocity != '0 0 0') || (trace_ent.flags & 32)))
	{
		LTB_Explode ();
		return;
	}
};
void () LTB_Detonate =
{
	self.th_pain = SUB_Null;
	self.th_die = SUB_Null;
	deathmsg = 50;
	T_RadiusDamage (self, self.owner, 200, world);
	sprint (self.real_owner, 1, "Your laser trip wire bomb is gone.\n");
	WriteByte (0.000000, 23);
	WriteByte (0.000000, 3);
	WriteCoord (0.000000, self.origin_x);
	WriteCoord (0.000000, self.origin_y);
	WriteCoord (0.000000, self.origin_z);
	BecomeExplosion ();
};
void () LTB_Explode =
{
	sound (self, 3, "weapons/tarbeep.wav", 1, 1);
	self.nextthink = (time + 0.01);
	self.think = LTB_Detonate;
	deathmsg = 50;
};
void () LTB_Pain =
{
	self.nextthink = (time + 0.02);
	self.think = LTB_Detonate;
	self.health = 10;
	deathmsg = 50;
};
void () ParaGlide =
{
	if ((!(self.owner.flags & 512) && (self.owner.chute_active == 1)))
	{
		makevectors (self.owner.v_angle);
		self.owner.velocity = aim (self.owner, 1);
		self.owner.velocity = (self.owner.velocity * 200);
		self.owner.velocity_z = -80.000000;
		self.angles = self.owner.angles;
		setorigin (self, (self.owner.origin + '0 0 45'));
		self.nextthink = (time + 0.01);
		self.think = ParaGlide;
		if ((self.frame < 3))
		{
			if ((self.owner.chute_count < time))
			{
				self.owner.chute_count = (time + 0.1);
				self.frame = (self.frame + 1);
			}
		}
	}
	else
	{
		sound (self, 3, "utils/paraland.wav", 1, 1);
		self.owner.chute_count = 0.000000;
		self.owner.chute_active = 0.000000;
		self.think = SUB_Null;
		remove (self);
	}
};
void () PullCord =
{
	if ((self.chute_active == 1))
	{
		return;
	}
	if (allow_chute != 1)
	{
		sprint(self, 2, "Parachute Disabled.\n");
		return;
	}
	if (mapname == "hip2m2" && mapname != "hip1m4")
	{
		sprint(self, 2, "Parachute Disabled for this map.\n");
		return;
	}
	if ((self.flags & 512))
	{
		if (self.nextuse_para > time)
		{
			sprint (self, 2, "Parachute:  .\n");
		}
		else
		{
			sprint (self, 2, "Parachute: .\n");
		}
		return;
	}
	if (self.nextuse_para > time)
	{
		sprint (self, 2, "It takes 15 seconds to assemble a new Parachute..\n");
		return;
	}
	self.nextuse_para = time + 15; // we dont want people spamming parachutes now do we?
	player_run ();
	self.chute_active = 1;
	sound (self, 2, "utils/pullcord.wav", 1, 1);
	newmis = spawn ();
	newmis.classname = "chute"; 	//Added chute to classname for teleporters bring through.
	newmis.movetype = 0.000000;
	newmis.owner = self;
	newmis.solid = 0.000000;
	newmis.nextthink = time;
	newmis.think = ParaGlide;
	newmis.colormap = self.colormap;
	setmodel (newmis, "progs/chute.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	makevectors (self.v_angle);
};
void () FireUtil =
{
	if ((self.chute_active == 1))
	{
		self.chute_active = 0;
		return;
	}
	if (((self.playerclass == 8) && self.hook_out))
	{
		sprint (self, 2, "You must retract hook first!\n");
		return;
	}
	if (self.playerclass == 0)
	{
		return;
	}
	if ((self.tools == (self.tools | 32)))
	{
		return;
	}
	if ((self.chute_active == 0.000000))
	{
		if ((self.waterlevel > 0.000000))
		{
			return;
		}
		else
		{
			PullCord ();
		}
	}
};
void () TeamFortress_Discard =
{
	if (self.discard_next > time)
	{
		return;
	}
	newmis = spawn ();
	newmis.classname = "discard_ammo";
	if ((self.playerclass == 1.000000))
	{
		newmis.ammo_rockets = self.ammo_rockets;
		self.ammo_rockets = 0.000000;
		if (self.discard_max)
		{
			if ((self.ammo_shells > 10.000000))
			{
				newmis.ammo_shells = (self.ammo_shells - 10.000000);
				self.ammo_shells = 10.000000;
			}
		}
	}
	else
	{
		if ((self.playerclass == 2.000000))
		{
			newmis.ammo_rockets = self.ammo_rockets;
			self.ammo_rockets = 0.000000;
			if (self.discard_max)
			{
				if ((self.ammo_shells > 40.000000))
				{
					newmis.ammo_shells = (self.ammo_shells - 40.000000);
					self.ammo_shells = 40.000000;
				}
			}
		}
		else
		{
			if ((self.playerclass == 3.000000))
			{
				newmis.ammo_cells = self.ammo_cells;
				newmis.ammo_nails = self.ammo_nails;
				self.ammo_cells = 0.000000;
				self.ammo_nails = 0.000000;
				if (self.discard_max)
				{
					if ((self.ammo_shells > 40.000000))
					{
						newmis.ammo_shells = (self.ammo_shells - 40.000000);
						self.ammo_shells = 40.000000;
					}
				}
			}
			else
			{
				if ((self.playerclass == 4.000000))
				{
					newmis.ammo_cells = self.ammo_cells;
					newmis.ammo_nails = self.ammo_nails;
					self.ammo_cells = 0.000000;
					self.ammo_nails = 0.000000;
					if (self.discard_max)
					{
						if ((self.ammo_shells > 40.000000))
						{
							newmis.ammo_shells = (self.ammo_shells - 40.000000);
							self.ammo_shells = 40.000000;
						}
					}
				}
				else
				{
					if ((self.playerclass == 5.000000))
					{
						newmis.ammo_rockets = self.ammo_rockets;
						self.ammo_rockets = 0.000000;
						if (!medicarmorheal)
						{
							newmis.ammo_cells = self.ammo_cells;
							self.ammo_cells = 0.000000;
						}
						if (self.discard_max)
						{
							if ((self.ammo_shells > 40.000000))
							{
								newmis.ammo_shells = (self.ammo_shells - 40.000000);
								self.ammo_shells = 40.000000;
							}
						}
					}
					else
					{
						if ((self.playerclass == 6.000000))
						{
							newmis.ammo_rockets = self.ammo_rockets;
							self.ammo_rockets = 0.000000;
							if (self.discard_max)
							{
								if ((self.ammo_cells > 10.000000))
								{
									newmis.ammo_cells = (self.ammo_cells - 10.000000);
									self.ammo_cells = 10.000000;
								}
							}
						}
						else
						{
							if ((self.playerclass == 7.000000))
							{
								newmis.ammo_nails = self.ammo_nails;
								self.ammo_nails = 0.000000;
								if (self.discard_max)
								{
									if ((self.ammo_shells > 20.000000))
									{
										newmis.ammo_shells = (self.ammo_shells - 20.000000);
										self.ammo_shells = 20.000000;
									}
								}
							}
							else
							{
								if ((self.playerclass == 8.000000))
								{
									newmis.ammo_rockets = self.ammo_rockets;
									self.ammo_rockets = 0.000000;
								}
								else
								{
									if ((self.playerclass == 9.000000))
									{
										newmis.ammo_rockets = self.ammo_rockets;
										self.ammo_rockets = 0.000000;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (!(((newmis.ammo_shells + newmis.ammo_nails) + newmis.ammo_rockets) + newmis.ammo_cells))
	{
		dremove (newmis);
		return;
	}
	W_SetCurrentAmmo ();
	sound (self, 3.000000, "weapons/lock4.wav", 1.000000, 1.000000);
	if ((self.team_no != 0.000000))
	{
		increment_team_ammoboxes (self.team_no);
		if ((num_team_ammoboxes (self.team_no) > (20.000000 / number_of_teams)))
		{
			RemoveOldAmmobox (self.team_no);
		}
	}
	else
	{
		num_world_ammoboxes = num_world_ammoboxes + 1.000000;
		if ((num_world_ammoboxes > 20.000000))
		{
			RemoveOldAmmobox (0.000000);
		}
	}
	newmis.enemy = self;
	newmis.health = time;
	newmis.weapon = 0.000000;
	newmis.movetype = 6.000000;
	newmis.solid = 1.000000;
	newmis.classname = "ammobox";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = ((v_forward * 400.000000) + (v_up * 200.000000));
	}
	else
	{
		newmis.velocity = aim (self, 10000.000000);
		newmis.velocity = (newmis.velocity * 400.000000);
		newmis.velocity_z = 200.000000;
	}
	if (newmis.ammo_rockets > 0)
	{
		newmis.avelocity = '0.000000 300.000000 0.000000';
		setsize (newmis, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
		setorigin (newmis, self.origin);
		newmis.nextthink = (time + 30.000000);
		newmis.think = SUB_Remove;
		newmis.touch = TeamFortress_AmmoboxTouch;
		setmodel (newmis, "progs/backpack.mdl");
	}
	else
	{
		newmis.avelocity = '0.000000 300.000000 0.000000';
		setsize (newmis, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
		setorigin (newmis, self.origin);
		newmis.nextthink = (time + 2.000000);
		newmis.think = PackCheck;
		newmis.touch = TeamFortress_AmmoboxTouch;
		setmodel (newmis, "progs/backpack.mdl");
	}
	self.discard_next = time + .25;
};
void () TeamFortress_SaveMe =
{
	local entity te;
	local entity tl;
	if (self.bugger == 8)	// player is looking through spycam
		return;
	if (self.team_no == 0)
		return;
	if (survival_mode)
		if (self.deadflag >= 2)
{
			te = find(world, classname, "resdummy");
			while (te)
			{
				if (te.owner == self)
				{
					WriteByte(4, 23);
					WriteByte(4, 11);
					WriteCoord(4, te.origin_x);
					WriteCoord(4, te.origin_y);
					WriteCoord(4, te.origin_z);
					if ((self.last_saveme_sound < time))
					{
						sound (te, TF_FLARE_OFF, "speech/saveme1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
						self.last_saveme_sound = (time + 4);
					}
					return;
				}
				te = find(te, classname, "resdummy");
			}
		}
		
	if (self.health <= 0 && self.playerclass > 0)	// player is dead and waiting for a resurrect
	{
	te = findradius(self.origin, 350);
	while (te)
	{
		if (te.classname == "player" && te.current_menu == 0)
		{
			if (!survival_mode)
				te.current_menu = 41;
		}
		te = te.chain;
	}
		WriteByte(4, 23);
		WriteByte(4, 11);
		WriteCoord(4, self.origin_x);
		WriteCoord(4, self.origin_y);
		WriteCoord(4, self.origin_z);
		multicast(self.origin, TF_FLARE_OFF);
		return;
	}
	if ((self.last_saveme_sound < time))
	{
		sound (self, TF_FLARE_OFF, "speech/saveme1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		self.last_saveme_sound = (time + 4);
	}
	
	te = find (world, classname, "player");
	while (te)
	{
		if (((((self == te) || (te.playerclass == 5)) || (te.playerclass == 9)) || (te.playerclass == 8)))
		{
			if ((((te.team_no == self.team_no) && (self.team_no != TF_FLARE_LIT)) || (te.playerclass == 8)))
			{
				if (visible (te))
				{
					msg_entity = te;
					tl = spawn ();
					tl.origin = self.origin;
					tl.origin_z = (tl.origin_z + 32);
					WriteByte (TF_FLARE_OFF, 23);
					WriteByte (TF_FLARE_OFF, 9);
					WriteEntity (TF_FLARE_OFF, tl);
					WriteCoord (TF_FLARE_OFF, tl.origin_x);
					WriteCoord (TF_FLARE_OFF, tl.origin_y);
					WriteCoord (TF_FLARE_OFF, (tl.origin_z + 24));
					WriteCoord (TF_FLARE_OFF, self.origin_x);
					WriteCoord (TF_FLARE_OFF, self.origin_y);
					WriteCoord (TF_FLARE_OFF, self.origin_z);
					dremove (tl);
				}
			}
		}
		te = find (te, classname, "player");
	}
};
void () TeamFortress_ID =
{
	local vector src;
	src = (self.origin + (v_forward * 10));
	src_z = (self.absmin_z + (self.size_z * 0.7));
	traceline (src, (src + (v_forward * 2048)), TF_FLARE_LIT, self);
	if (((trace_ent != world) && (trace_ent.origin != world.origin)))
	{
	if (trace_ent.classname == "player" && trace_ent.playerclass == 8)	//Do not ID spies, let the player shoot them to find out. -arg
	{
		return;
	}
	if (trace_ent.classname == "player" && (trace_ent.invisible_finished > time))	//Do not ID invisible players. Let the viewer shoot them to find out. -arg
	{
		return;
	}
	if (((trace_ent.classname == "player") && (trace_ent.health > TF_FLARE_LIT)))
		{
			self.StatusRefreshTime = (time + .25);
			centerprint (self, "\n\n\n", trace_ent.netname, "\n");
			return;
		}
	if ((trace_ent.classname == "building_dispenser"))
				{
				self.StatusRefreshTime = (time + 1.5);
				if ((self == trace_ent.real_owner))
				{
					centerprint (self, "\n\n\n\nYour Dispenser");
				}
				else
				{
					centerprint (self, "\n\n\n\nDispenser made by ", trace_ent.real_owner.netname);
				}
			}
			else
			{
				if (((trace_ent.classname == "building_sentrygun") || (trace_ent.classname == "building_sentrygun_base")))
				{
					self.StatusRefreshTime = (time + 1);
					if ((self == trace_ent.real_owner))
					{
						centerprint (self, "\n\n\n\nYour SentryGun");
					}
					else
					{
						if (!teamplay)
						{
							centerprint (self, "\n\n\n\nSentrygun made by\n", trace_ent.real_owner.netname);
						}
						else
						{
							if (((self.team_no != TF_FLARE_LIT) && (self.team_no == trace_ent.team_no)))
							{
								centerprint (self, "\n\n\n\nFriendly Sentrygun made by\n", trace_ent.real_owner.netname);
							}
							else
							{
								centerprint (self, "\n\n\n\nEnemy Sentrygun made by\n", trace_ent.real_owner.netname);
							}
						}
					}
				}
				else
				{
					if ((trace_ent.classname == "building_tesla"))
					{
						self.StatusRefreshTime = (time + 1);
						if ((self == trace_ent.real_owner))
						{
							centerprint (self, "\n\n\n\nYour Tesla Coil");
						}
						else
						{
							if (!teamplay)
							{
								centerprint (self, "\n\n\n\nTesla Coil made by\n", trace_ent.real_owner.netname);
							}
							else
							{
								if (((self.team_no != TF_FLARE_LIT) && (self.team_no == trace_ent.team_no)))
								{
									centerprint (self, "\n\n\n\nFriendly Tesla made by\n", trace_ent.real_owner.netname);
								}
								else
								{
									centerprint (self, "\n\n\n\nEnemy Tesla made by\n", trace_ent.real_owner.netname);
								}
							}
						}
					}
				}
			}
		}
};
void () TeamFortress_ReloadCurrentWeapon =
{
	local float rt;
	local entity tWeapon;
	if ((self.current_weapon == 128))
	{
		if ((self.reload_shotgun == TF_FLARE_LIT))
		{
			sprint (self, 2, "Magazine full. Groovy.\n");
			return;
		}
		if ((self.reload_shotgun < self.ammo_shells) || (self.reload_shotgun >= GetClipSize(128)))
		{
			Attack_Finished (0.4);
			rt = ((GetClipSize(128) - self.reload_shotgun) / GetClipSize(128));
			rt = (2 - (2 * rt));
			self.reload_shotgun = TF_FLARE_LIT;
			if ((self.ammo_shells < GetClipSize(128)))
			{
				self.reload_shotgun = (GetClipSize(128) - self.ammo_shells);
			}
			sprint (self, 2, "reloading...\n");
			self.tfstate = (self.tfstate | 2);
			tWeapon = spawn ();
			tWeapon.owner = self;
			tWeapon.classname = "timer";
			rt = ( rt / MTF_Coop_AttribGain(self, #ATTRIB_RELOAD) );
			tWeapon.real_owner = self;
			tWeapon.nextthink = (time + rt);
			tWeapon.think = W_Reload_shotgun;
			self.weaponmodel = "";
			self.weaponframe = TF_FLARE_LIT;
		}
		else
		{
			sprint (self, 2, "Not enough ammo to reload.\n");
		}
	}
	else
	{
		if ((self.current_weapon == 256))
		{
			if ((self.reload_super_shotgun == TF_FLARE_LIT))
			{
				sprint (self, 2, "Magazine full. Groovy.\n");
				return;
			}
			if ((self.reload_super_shotgun < self.ammo_shells) || (self.reload_super_shotgun >= GetClipSize(256)))
			{
				Attack_Finished (0.7);
				rt = ((GetClipSize(256) - self.reload_super_shotgun) / GetClipSize(256));
				rt = (3 - (3 * rt));
				self.reload_super_shotgun = TF_FLARE_LIT;
				if ((self.ammo_shells < GetClipSize(256)))
				{
					self.reload_super_shotgun = (16 - self.ammo_shells);
				}
				sprint (self, 2, "reloading...\n");
				self.tfstate = (self.tfstate | 2);
				tWeapon = spawn ();
				tWeapon.owner = self;
				tWeapon.classname = "timer";
				rt = ( rt / MTF_Coop_AttribGain(self, #ATTRIB_RELOAD) );
				tWeapon.real_owner = self;
				tWeapon.nextthink = (time + rt);
				tWeapon.think = W_Reload_super_shotgun;
				self.weaponmodel = "";
				self.weaponframe = TF_FLARE_LIT;
			}
			else
			{
				sprint (self, 2, "Not enough ammo to reload.\n");
			}
		}
		else
		{
			if ((self.current_weapon == 2048))
			{
				if ((self.reload_grenade_launcher == TF_FLARE_LIT))
				{
					sprint (self, 2, "Magazine full. Tear em up!\n");
					return;
				}
				if ((self.reload_grenade_launcher < self.ammo_rockets)  || (self.reload_grenade_launcher >= GetClipSize(2048)))
				{
					Attack_Finished (0.6);
					rt = ((GetClipSize(2048) - self.reload_grenade_launcher) / GetClipSize(2048));
					rt = (4 - (4 * rt));
					self.reload_grenade_launcher = TF_FLARE_LIT;
					if ((self.ammo_rockets < GetClipSize(2048)))
					{
						self.reload_grenade_launcher = (GetClipSize(2048) - self.ammo_rockets);
					}
					sprint (self, 2, "reloading...\n");
					self.tfstate = (self.tfstate | 2);
					tWeapon = spawn ();
					tWeapon.owner = self;
					tWeapon.classname = "timer";
					rt = ( rt / MTF_Coop_AttribGain(self, #ATTRIB_RELOAD) );
					tWeapon.real_owner = self;
					tWeapon.nextthink = (time + rt);
					tWeapon.think = W_Reload_grenade_launcher;
					self.weaponmodel = "";
					self.weaponframe = TF_FLARE_LIT;
				}
				else
				{
					sprint (self, 2, "Not enough ammo to reload.\n");
				}
			}
			else
			{
				if ((self.current_weapon == 8192))
				{
					if ((self.reload_rocket_launcher == TF_FLARE_LIT))
					{
						sprint (self, 2, "Magazine full. Go get some.\n");
						return;
					}
					if ((self.reload_rocket_launcher < self.ammo_rockets) || (self.reload_rocket_launcher >= GetClipSize(8192)))
					{
						Attack_Finished (0.8);
						rt = ((GetClipSize(8192) - self.reload_rocket_launcher) / GetClipSize(8192));
						rt = (5 - (5 * rt));
						self.reload_rocket_launcher = TF_FLARE_LIT;
						if ((self.ammo_rockets < GetClipSize(8192)))
						{
							self.reload_rocket_launcher = (GetClipSize(8192) - self.ammo_rockets);
						}
						sprint (self, 2, "reloading...\n");
						self.tfstate = (self.tfstate | 2);
						tWeapon = spawn ();
						tWeapon.owner = self;
						tWeapon.classname = "timer";
						rt = ( rt / MTF_Coop_AttribGain(self, #ATTRIB_RELOAD) );
						tWeapon.real_owner = self;
						tWeapon.nextthink = (time + rt);
						tWeapon.think = W_Reload_rocket_launcher;
						self.weaponmodel = "";
						self.weaponframe = TF_FLARE_LIT;
					}
				}
			}
		}
	}
	if ((self.current_weapon == 524288))
	{
		if ((self.reload_rail_gun == TF_FLARE_LIT))
		{
			sprint (self, 2, "Clipazine full. This is the way.\n");
			return;
		}
		if ((self.reload_rail_gun < self.ammo_cells) || (self.reload_rail_gun >= GetClipSize(524288)))
		{
			Attack_Finished (0.7);
			rt = ((GetClipSize(524288) - self.reload_rail_gun) / GetClipSize(524288));
			rt = (1.5 - (1.5 * rt));
			self.reload_rail_gun = TF_FLARE_LIT;
			if ((self.ammo_cells < GetClipSize(524288)))
			{
				self.reload_rail_gun = (16 - self.ammo_cells);
			}
			sprint (self, 2, "reloading...\n");
			self.tfstate = (self.tfstate | 2);
			tWeapon = spawn ();
			tWeapon.owner = self;
			tWeapon.classname = "timer";
			rt = ( rt / MTF_Coop_AttribGain(self, #ATTRIB_RELOAD) );
			tWeapon.nextthink = (time + rt);
			tWeapon.think = W_Reload_rail_gun;
			self.weaponmodel = "";
			self.weaponframe = TF_FLARE_LIT;
		}
		else
		{
			sprint (self, 2, "Not enough ammo to reload.\n");
		}
	}
	CSQC_SendReloadBar(self, time+rt);
	if (tWeapon != world && tWeapon.nextthink <= time)
	{
		bprint(2,"tWeapon.nextthink is less than or equal to time..  - TELL DEV this.\n");
		tWeapon.nextthink = time + 0.01;
	}
	if (tWeapon != world)
	{
		self.reload_ent = tWeapon;
		self.reload_finished_func = tWeapon.think;
	}
};
void () Drone =
{
	if (self.ammo_cells < 100)
	{
		sprint (self, 2, "You need 100 Cells to launch the Reaper Drone.\n");
		return;
	}
	if ((self.last_used > time))
	{
		sprint (self, 2, "Not finished building new drone yet... takes .75 minute.\n");
		return;
	}
	sprint (self, 2, "Reaper Laser Drone away!\n");
	self.last_used = (time + 45);
	self.no_grenades_1 = (self.no_grenades_1 - TF_FLARE_OFF);
	self.ammo_cells = (self.ammo_cells - 100);
	newmis = spawn ();
	newmis.owner = self;
	newmis.weapon = 41;
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.classname = "bot";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = (v_forward * 200);
	}
	else
	{
		newmis.velocity = aim (self, 10000);
		newmis.velocity = (newmis.velocity * 200);
	}
	newmis.option = TF_FLARE_OFF;
	newmis.health = 90; //was 30
	newmis.takedamage = 2;  //can be damaged and taken out.
	newmis.th_die = DroneDie;
	setsize (newmis, '-8 -8 -8', '12 12 12');
	setorigin (newmis, ((self.origin + (v_forward * 8)) + '0 0 20'));
	newmis.angles_x = self.angles_x;
	newmis.angles_y = self.angles_y;
	newmis.angles_z = self.angles_z;
	sound (newmis, TF_FLARE_LIT, "weapons/chngnu1a.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis.nextthink = (time + 0.8);
	newmis.playerclass = TF_FLARE_LIT;
	newmis.think = DroneJet;
	newmis.touch = BalloonMIRVtouch;
	newmis.skin = TF_FLARE_LIT;
	setmodel (newmis, "progs/lsrdrone.mdl");
};
void () Drone_Laser_Touch =
{
	local vector org;
	if ((other == self.owner))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	sound (self, TF_FLARE_OFF, "enforcer/enfstop.wav", TF_FLARE_OFF, 3);
	org = (self.origin - (8 * normalize (self.velocity)));
	if (other.health)
	{
		SpawnBlood (org, 15);
		deathmsg = 41;
		self.weapon = 41;
		if (((other.classname == "building_sentrygun") || (other.classname == "building_tesla") || (other.classname == "turret")))
		{
			T_RadiusDamage (self, self.owner.owner, 100, world);
		}
		else
		{
			T_Damage (other, self, self.owner.owner, 150); // was 25. Thinking of adding quad damage when player's quad is on instead. -arg
		}
	}
	dremove (self);
};
void (vector org,vector vec) DroneLaunchLaser =
{
	sound (self, TF_FLARE_OFF, "enforcer/enfire.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	vec = normalize (vec);
	newmis = spawn ();
	newmis.owner = self;
	newmis.team_no = self.team_no;
	newmis.movetype = 5;
	newmis.solid = 2;
	newmis.effects = 8;
	newmis.weapon = 41;
	newmis.classname = "drone_laser";
	newmis.skin = (self.owner.team_no - TF_FLARE_OFF);
	setmodel (newmis, "progs/beam.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = (vec * 2500);
	newmis.angles = vectoangles (newmis.velocity);
	newmis.nextthink = (time + 4);
	newmis.think = SUB_Remove;
	newmis.touch = Drone_Laser_Touch;
};
void () DroneDoneTouch =
{
	if (self.velocity_z)
	{
		sound (self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
};
void () DroneDie =
{
	ThrowGib ("progs/tgib2.mdl", -70.000000);
	ThrowGib ("progs/dgib2.mdl", -70.000000);
	ThrowGib ("progs/dgib3.mdl", -70.000000);
	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);
	multicast (self.origin, TF_FLARE_OFF);
	T_RadiusDamage (self, self.owner.owner, 90, world); //Do some shrapnel damage when crashed. Game Over Man! -arg
	MushroomFlame(); // Make a pretty fireball with explosion. -arg
	TeamFortress_DetpackExplode(); //make a crowd pleaser of a boom. -arg
};
void () DroneFall =
{
	sound (self, TF_FLARE_LIT, "weapons/chngnu1a.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	self.movetype = 10;
	self.avelocity = '200 0 300';
	setsize (self, '-8 -8 -8', '8 8 8');
	self.takedamage = 2;
	self.skin = TF_FLARE_OFF;
	self.th_die = DroneDie;
	self.touch = DroneDoneTouch;
	self.think = DroneDie;
	self.nextthink = (time + 10); //was 20, get rid of it so we don't have too many entities. -arg
};
void () DroneJet =
{
	local entity te;
	local float i;
	self.playerclass = (self.playerclass + TF_FLARE_OFF);
	self.nextthink = (time + .9); // was .9 faster firing rate -arg
	sound (self, TF_FLARE_LIT, "weapons/drone.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	te = find (world, classname, "player");
	while (te)
	{
		if ((self != te))
		{
			if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
			{
				if (te.health)
				{
					if (visible (te))
					{
						if ((te.is_undercover != TF_FLARE_OFF))
						{
							DroneLaunchLaser (self.origin, (te.origin - self.origin));
						}
					}
				}
			}
		}
		te = find (te, classname, "player");
	}
	te = find (world, classname, "building_sentrygun");
	while (te)
	{
		if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
		{
			if (te.health)
			{
				if (visible (te))
				{
					DroneLaunchLaser (self.origin, ((te.origin + '0 0 24') - self.origin));
				}
			}
		}
		te = find (te, classname, "building_sentrygun");
	}
	te = find (world, classname, "building_tesla");
	while (te)
	{
		if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
		{
			if (te.health)
			{
				if (visible (te))
				{
					DroneLaunchLaser (self.origin, ((te.origin + '0 0 24') - self.origin));
				}
			}
		}
		te = find (te, classname, "building_tesla");
	}
	te = find (world, classname, "bot");
	while (te)
	{
		if ((self != te))
		{
			if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
			{
				if (te.health)
				{
					if (visible (te))
					{
						DroneLaunchLaser (self.origin, (te.origin - self.origin));
					}
				}
			}
		}
		te = find (te, classname, "bot");
	}
		te = find (world, classname, "turret");
	while (te)
	{
		if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
		{
			if (te.health)
			{
				if (visible (te))
				{
					DroneLaunchLaser (self.origin, ((te.origin + '0 0 24') - self.origin));
				}
			}
		}
		te = find (te, classname, "turret");
	}
// monster string defines monsters and not minions. No point having the drone shoot your own minions. -arg
// was defined as is_monster in parameter 2 of find, which needs to be a .string -arg
	te = find (world, monster_string, "on");
	while (te)
	{
		if ((self != te))
		{
			if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
			{
				if (te.health)
				{
					if (visible (te))
					{
						if (i < 2)
							DroneLaunchLaser (self.origin, (te.origin - self.origin));
						i++;
					}
				}
			}
		}
		te = find (te, monster_string, "on");
	}
	if ((self.playerclass > 10))
	{
		self.think = DroneFall;
	}
//Added search and fire on bosses with drone. An oversight fixed 10/2020. -arg
		te = find (world, classname, "monster_boss");
	while (te)
	{
		if (((te.team_no != TF_FLARE_LIT) && (te.team_no != self.team_no)))
		{
			if (te.health)
			{
				if (visible (te))
				{
					DroneLaunchLaser (self.origin, ((te.origin + '0 0 24') - self.origin));
				}
			}
		}
		te = find (te, classname, "monster_boss");
	}
};
vector (vector ang) SUB_NormalizeAngles =
{
	while ((ang_x > 360))
	{
		ang_x = (ang_x - 360);
	}
	while ((ang_x < TF_FLARE_LIT))
	{
		ang_x = (ang_x + 360);
	}
	while ((ang_y > 360))
	{
		ang_y = (ang_y - 360);
	}
	while ((ang_y < TF_FLARE_LIT))
	{
		ang_y = (ang_y + 360);
	}
	while ((ang_z > 360))
	{
		ang_z = (ang_z - 360);
	}
	while ((ang_z < TF_FLARE_LIT))
	{
		ang_z = (ang_z + 360);
	}
	return (ang);
};
void () Prox_Disarm =
{
	if ((other.classname != "player"))
	{
		return;
	}
	if (((other.playerclass == 1.000000) && (other.team_no != self.team_no)))
	{
		sound (other, 2.000000, "items/flare1.wav", 1.000000, 1.000000);
		other.real_frags = (other.real_frags + 1.000000);
		dremove (self);
	}
	return;
};
void () ProxiDie =
{
	self.effects = 4;
	make_explosion ();
	self.takedamage = TF_FLARE_LIT;
	deathmsg = 45;
	T_RadiusDamage (self, self.owner, 350, world);
	sprint (self.owner, 2, "Your Proximity Mine is gone...\n");
	dremove (self);
};
void () FoundBastard =
{
	local float _l_11382;
	self.touch = Prox_Disarm;
	sound (self, 3.000000, "effects/beep.wav", 1.000000, 1.000000);
	self.skin = (self.owner.team_no + 3.000000);
	_l_11382 = vlen ((self.enemy.origin - self.origin));
	if ((_l_11382 <= self.height))
	{
		self.height = _l_11382;
		self.nextthink = (time + ((_l_11382 / 1000.000000) * 1.500000));
		self.think = FoundBastard;
	}
	else
	{
		self.effects = 4.000000;
		make_explosion ();
		MushroomFlame ();
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 3.000000);
		WriteCoord (4.000000, self.origin_x);
		WriteCoord (4.000000, self.origin_y);
		WriteCoord (4.000000, self.origin_z);
		multicast (self.origin, 1.000000);
		deathmsg = 45.000000;
		self.takedamage = 0.000000;
		T_RadiusDamage (self, self.owner, 200.000000, world);
		dremove (self);
	}
};
void () ProxArmed =
{
	local entity _l_11392;
	local vector _l_11394;
	self.velocity = '0.000000 0.000000 0.000000';
	self.nextthink = (time + 1.000000);
	self.think = ProxArmed;
	sound (self, 3.000000, "effects/beep.wav", 0.300000, 1.000000);
	self.playerclass = (self.playerclass + 1.000000);
	if ((self.skin == self.owner.team_no))
	{
		self.skin = 0.000000;
	}
	else
	{
		self.skin = self.owner.team_no;
	}
	_l_11392 = find (world, classname, "player");
	while (_l_11392)
	{
		if ((self.owner != _l_11392))
		{
			if ((((_l_11392.team_no != 0.000000) && (_l_11392.team_no != self.team_no)) && (_l_11392.bugger == 0.000000)))
			{
				if ((_l_11392.health > 1.000000))
				{
					if (visible (_l_11392))
					{
						if ((_l_11392.undercover_team != self.team_no))
						{
							_l_11394 = _l_11392.origin - self.origin;
							if ((vlen (_l_11394) < 200.000000))
							{
								self.height = vlen (_l_11394);
								self.enemy = _l_11392;
								self.nextthink = 0.200000;
								self.think = FoundBastard;
							}
						}
					}
				}
			}
		}
		_l_11392 = find (_l_11392, classname, "player");
	}
		_l_11392 = findradius(self.origin, 200);
		while (_l_11392)
		{
			if (_l_11392.is_monster == 1)
			{
				if ((_l_11392.health > 1.000000))
				{
					if (visible (_l_11392))
					{
						_l_11394 = _l_11392.origin - self.origin;
						if ((vlen (_l_11394) < 200.000000))
						{
							self.height = vlen (_l_11394);
							self.enemy = _l_11392;
							self.nextthink = 0.200000;
							self.think = FoundBastard;
						}
					}
				}
			}
			_l_11392 = _l_11392.chain;
		}
	if (((self.playerclass > 300.000000) || (self.owner.playerclass != 3.000000)))
	{
		dremove (self);
	}
};
void () ProxAttach =
{
	self.touch = SUB_Null;
	self.think = ProxArmed;
	self.nextthink = (time + 0.5);
	sound (newmis, TF_FLARE_LIT, "buttons/switch02.wav", TF_FLARE_OFF, TF_FLARE_OFF);
};
void () OneProx =
{
		sprint (self, 2.000000, "1 proximity grenade at a time!\n");
		if ((self.weaponmodel == "progs/proxgren.mdl"))
		{
			self.current_weapon = W_BestWeapon ();
			self.weaponmodel = "progs/v_rock2.mdl";
			self.currentammo = self.ammo_rockets;
			Attack_Finished (0.700000);
			self.impulse = 0.000000;
			self.StatusRefreshTime = (time + 0.100000);
		}
};
void () Prox =
{
	local vector _l_11458;
	local vector _l_11461;
	local entity _l_11464;
	_l_11464 = find (world, classname, "bot");
	while (_l_11464)
	{
		if ((_l_11464.owner == self))
		{
			local vector source;
			makevectors (self.v_angle);
			source = (self.origin + '0 0 16');
			traceline (source, (source + (v_forward * 64)), 0, world);
			if (trace_fraction == 1)
			{
				OneProx();
				return;
			}
			if (trace_ent.classname == "bot" && trace_ent.owner == self)
			{
				sprint(self, 2, "You disarm your proxy grenade.\n");
				self.no_grenades_2 = self.no_grenades_2 + 2;
				dremove(trace_ent);
				return;
			}
			else
			{
				OneProx();
				return;
			}
		}
		_l_11464 = find (_l_11464, classname, "bot");
	}
	if ((self.no_grenades_2 < 2.000000))
	{
		sprint (self, 2.000000, "Not enough type 2 grenades... get more\n");
		if ((self.weaponmodel == "progs/proxgren.mdl"))
		{
			self.weaponmodel = "progs/v_rock2.mdl";
			self.currentammo = self.ammo_rockets;
			Attack_Finished (0.700000);
			self.impulse = 0.000000;
			self.StatusRefreshTime = (time + 0.100000);
			self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
		}
		return;
	}
	if ((self.weaponmodel != "progs/proxgren.mdl"))
	{
		self.tfstate = (self.tfstate | 2.000000);
		self.oldweaponmodel = self.weaponmodel;
		self.oldcurrentammo = self.currentammo;
		self.currentammo = 1.000000;
		self.weaponmodel = "progs/proxgren.mdl";
		self.weaponframe = 0.000000;
		VWEPS_SetModel ();
		return;
	}
	makevectors (self.v_angle);
	_l_11458 = self.origin + (v_forward * 10.000000);
	_l_11458_z = self.absmin_z + (self.size_z * 0.700000);
	traceline (_l_11458, (_l_11458 + (v_forward * 70.000000)), 0.000000, self);
	_l_11461 = trace_endpos - (v_forward * 8.000000);
	if ((trace_fraction != 1.000000))
	{
		sound (self, 3.000000, "buttons/switch02.wav", 1.000000, 1.000000);
		sprint (self, 2.000000, "Proximity mine set!\n");
		self.no_grenades_2 = (self.no_grenades_2 - 2.000000);
		newmis = spawn ();
		newmis.owner = self;
		newmis.weapon = 41.000000;
		newmis.movetype = 0.000000;
		newmis.solid = 2.000000;
		newmis.classname = "bot";
		newmis.netname = "proxi";
		newmis.team_no = self.team_no;
		newmis.health = 3.000000;
		newmis.takedamage = 2.000000;
		newmis.th_die = ProxiDie;
		setsize (newmis, '-3.000000 -3.000000 -3.000000', '3.000000 3.000000 3.000000');
		newmis.angles = '0.000000 0.000000 0.000000';
		newmis.nextthink = (time + 1.000000);
		newmis.playerclass = 0.000000;
		newmis.think = ProxAttach;
		newmis.skin = 0.000000;
		newmis.frame = 1.000000;
		setmodel (newmis, "progs/proxgren.mdl");
		setorigin (newmis, _l_11461);
		if ((self.oldweaponmodel != ""))
		{
			self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
		}
		self.weaponmodel = self.oldweaponmodel;
		self.currentammo = self.oldcurrentammo;
		Attack_Finished (0.300000); //was .7 -arg
		self.impulse = 0.000000;
		self.StatusRefreshTime = (time + 0.100000);
	}
		VWEPS_SetModel ();
};
void (vector _p_11412, float _p_11415) BigAssBullet;
void () W_FireBigAss =
{
	local vector dir;
	if ((self.ammo_shells < 10))
	{
		make_explosion ();
		sound (self, 1, "weapons/asscan4.wav", 1, 1);
		stuffcmd (self, "bf\n");
		self.option4 = 0;
		return;
	}
	if (!old20mm)
		self.nojumptime = (time + 0.750000);
	if (infokey(world, "newsounds") == "1" || infokey(world, "newsounds") == "on")
	{
		sound (self, 1, "weapons/20mm.wav", 1, 1);
	}
	else
	{
		sound(self, TF_FLARE_OFF, "weapons/sgun1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	KickPlayer (-5, self);
	muzzleflash ();
	stuffcmd (self, "bf\n");
	self.currentammo = self.ammo_shells = self.ammo_shells - 10;
	makevectors (self.v_angle);
	dir = v_forward *3; //now 3x range. Shotgun high psi rounds are a thing now. -arg
	deathmsg = 46;
	BigAssBullet (dir, 90);  //was 70 tungsten slugs -arg
	EjectShell ();
	if (old20mm)
		self.velocity = (self.velocity - (v_forward * 400));
	else
		self.velocity = (self.velocity - (v_forward * 200));
	if ((self.ammo_shells == 0))
	{
		self.ammo_shells = 1;
	}
};
void () BigAssCarry =
{
	makevectors (self.owner.v_angle);
	setorigin (self, (((self.owner.origin + (v_forward * 12)) + '0 0 20') + (v_right * 5)));
	self.angles = self.owner.angles;
	self.think = BigAssCarry;
	self.nextthink = (time + 0.02);
};
void () CanisterTouch =
{
	sound (self, 1, "weapons/tink1.wav", 1, 1);
	if ((self.velocity == '0 0 0'))
	{
		self.avelocity = '0 0 0';
	}
};
void () CaltropTouch =
{
	if ((((other.classname != "player") || !(other.flags & 512)) || other.deadflag))
	{
		return;
	}
	if (((((teamplay & 16) && (other != self.owner)) && (other.team_no == self.owner.team_no)) && (self.owner.team_no != 0.000000)))
	{
		return;
	}
	if ((other.team_no == self.team_no))
	{
		return;
	}
	sprint (other, 2, "Ow, Ow, Ow! Caltrops!\n");
	other.leg_damage = (other.leg_damage + 2);
	TeamFortress_SetSpeed (other);
	deathmsg = 48; //added to clientobituary and female versions.
	T_Damage (other, self, self.owner, 20); //was 10 -arg
	dremove (self);
};
void () CaltropScatterThink =
{
	self.nextthink = (time + 0.2);
	if ((self.velocity == '0 0 0'))
	{
		if ((self.flags & 512))
		{
			self.nextthink = ((time + 10) + (random () * 5));
			self.think = SUB_Remove;
			self.solid = 1;
			self.movetype = 6;
			self.touch = CaltropTouch;
			self.angles = '90 90 90';
			sound (self, 0.000000, "weapons/tink1.wav", 1, 1);
			setorigin (self, self.origin);
			return;
		}
		else
		{
			self.nextthink = ((time + 10) + (random () * 5));
			self.think = SUB_Remove;
			self.solid = 1;
			self.movetype = 6;
			self.touch = CanisterTouch;
			setorigin (self, self.origin);
			return;
		}
	}
	traceline (self.movedir, self.origin, 1, self);
	if ((trace_fraction == 1))
	{
		self.movedir = self.origin;
		return;
	}
	self.velocity = (self.velocity * -1.000000);
	self.heat = (self.heat + 1);
	if ((self.heat > 10))
	{
		remove (self);
		return;
	}
};
void () ScatterCaltrops =
{
	local float num;
	if ((self.no_grenades_1 < 0.000000))
	{
		sprint (self, 2, "No Caltrops canisters left.\n");
		return;
	}
	if ((self.last_used > time))
	{
		sprint (self, 2, "Caltrops not ready...takes 5 seconds.\n");
		return;
	}
	sprint (self, 2, "Opening Caltrop canister...\n");
	self.no_grenades_1 = (self.no_grenades_1 - 1);
	self.last_used = (time + 5);
	num = 6;
	while ((num > 0.000000))
	{
		newmis = spawn ();
		newmis.classname = "grenade";
		newmis.weapon = 10;
		newmis.owner = self;
		newmis.team_no = self.team_no;
		newmis.movetype = 10;
		newmis.solid = 0.000000;
		makevectors (self.v_angle);
		if (self.v_angle_x)
		{
			newmis.velocity = ((((v_forward * 600) + (v_up * 200)) + ((crandom () * v_right) * 10)) + ((crandom () * v_up) * 10));
		}
		else
		{
			newmis.velocity = aim (self, 10000);
			newmis.velocity = (newmis.velocity * 300);
			newmis.velocity_z = 200;
		}
		setorigin (newmis, self.origin);
		newmis.nextthink = (time + 0.2);
		newmis.heat = 0.000000;
		newmis.mins = '-4 -4 -8';
		newmis.maxs = '4 4 4';
		newmis.angles = '0 0 0';
		newmis.angles_x = (crandom () * 360);
		newmis.velocity_x = (crandom () * 100);
		newmis.velocity_y = (crandom () * 100);
		newmis.velocity_z = (200 + (crandom () * 100));
		newmis.avelocity_x = (crandom () * 400);
		newmis.avelocity_y = (crandom () * 400);
		newmis.avelocity_z = (crandom () * 400);
		newmis.movedir = newmis.origin;
		newmis.touch = CaltropTouch;
		newmis.think = CaltropScatterThink;
		setmodel (newmis, "progs/spike.mdl");
		num = (num - 1);
	}
};
void (entity rhook) Reset_Grapple =
{
	sound (rhook.owner, TF_FLARE_OFF, "doors/ddoor2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	rhook.owner.on_hook = TF_FLARE_LIT;
	rhook.owner.hook_out = TF_FLARE_LIT;
	rhook.owner.fire_held_down = TF_FLARE_LIT;
	rhook.owner.weaponframe = TF_FLARE_LIT;
	rhook.think = SUB_Remove;
	rhook.nextthink = time;
};
void () Grapple_Track =
{
	if ((!self.owner.on_hook || (self.owner.health <= TF_FLARE_LIT)))
	{
		Reset_Grapple (self);
		return;
	}
	if ((self.enemy.classname != "player"))
	{
		self.velocity = self.enemy.velocity;
	}
	self.nextthink = (time + 0.1);
};
entity (float head) MakeLink =
{
	newmis = spawn ();
	newmis.movetype = 9;
	newmis.solid = 0.000000;
	newmis.owner = self;
	newmis.team_no = self.team_no; // Hey the rope is on our team, don't shoot it with minisentry. -arg
	setmodel (newmis, "progs/rope.mdl");
	setorigin (newmis, self.origin);
	setsize (newmis, '0 0 0', '0 0 0');
	newmis.angles = vectoangles (newmis.velocity);
	return (newmis);
};
void () Remove_Chain =
{
	self.think = SUB_Remove;
	self.nextthink = time;
	if (self.goalentity)
	{
		self.goalentity.think = SUB_Remove;
		self.goalentity.nextthink = time;
		if (self.goalentity.goalentity)
		{
			self.goalentity.goalentity.think = SUB_Remove;
			self.goalentity.goalentity.nextthink = time;
		}
	}
};
void () Update_Chain =
{
	local vector temp;
	if (!self.owner.hook_out)
	{
		self.think = Remove_Chain;
		self.nextthink = time;
		return;
	}
	temp = (self.owner.hook.origin - self.owner.origin);
	setorigin (self, (self.owner.origin + (temp * 0.3)));
	self.goalentity.team_no = self.team_no; // Hey the rope is on our team, don't shoot it with minisentry. -arg
	setorigin (self.goalentity, (self.owner.origin + (temp * 0.6)));
	setorigin (self.goalentity.goalentity, (self.owner.origin + (temp * 0.9)));
	self.goalentity.goalentity.team_no = self.team_no;
	self.angles = vectoangles (temp);
	self.goalentity.angles = vectoangles (temp);
	self.goalentity.goalentity.angles = vectoangles (temp);
	self.nextthink = (time + 0.2);
};
void () Build_Chain =
{
	self.goalentity = MakeLink ();
	self.goalentity.think = Update_Chain;
	self.goalentity.nextthink = (time + 0.1);
	self.goalentity.owner = self.owner;
	
	self.goalentity.goalentity = MakeLink ();
	self.goalentity.goalentity.goalentity = MakeLink ();
};
float () Check_Overhead =
{
	local vector src;
	local vector end;
	makevectors (self.owner.angles);
	src = (self.owner.origin - '0 0 24');
	end = (self.owner.origin - '0 0 24');
	traceline (src, end, TF_FLARE_LIT, self.owner);
	if ((trace_fraction != TF_FLARE_OFF))
	{
		return (TF_FLARE_LIT);
	}
	src = ((self.owner.origin - '0 0 24') - (v_forward * 16));
	end = (((self.owner.origin - '0 0 24') - (v_forward * 16)) + '0 0 58');
	traceline (src, end, TF_FLARE_LIT, self.owner);
	if ((trace_fraction != TF_FLARE_OFF))
	{
		return (TF_FLARE_LIT);
	}
	src = ((self.owner.origin - '0 0 24') + (v_forward * 16));
	end = (((self.owner.origin - '0 0 24') + (v_forward * 16)) + '0 0 58');
	traceline (src, end, TF_FLARE_LIT, self.owner);
	if ((trace_fraction != TF_FLARE_OFF))
	{
		return (TF_FLARE_LIT);
	}
	src = ((self.owner.origin - '0 0 24') - (v_right * 16));
	end = (((self.owner.origin - '0 0 24') - (v_right * 16)) + '0 0 58');
	traceline (src, end, TF_FLARE_LIT, self.owner);
	if ((trace_fraction != TF_FLARE_OFF))
	{
		return (TF_FLARE_LIT);
	}
	src = ((self.owner.origin - '0 0 24') + (v_right * 16));
	end = (((self.owner.origin - '0 0 24') + (v_right * 16)) + '0 0 58');
	traceline (src, end, TF_FLARE_LIT, self.owner);
	if ((trace_fraction != TF_FLARE_OFF))
	{
		return (TF_FLARE_LIT);
	}
	return (TF_FLARE_OFF);
};
void () Anchor_Grapple =
{
	local float test;
	if ((other == self.owner))
	{
		return;
	}
	if (((((other.classname == "missile") || (other.classname == "grenade")) || (other.classname == "spike")) || (other.classname == "hook")))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		Reset_Grapple (self);
		return;
	}
	self.health = TF_FLARE_OFF;
	self.takedamage = 2;
	self.th_die = Reset_My_Grapple;
	if (other.takedamage)
	{
		sound (self, TF_FLARE_OFF, "shambler/smack.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	else
	{
		sound (self, TF_FLARE_OFF, "player/axhit2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	if (other.takedamage)
	{
		deathmsg = 205; // for obituary "pooned". 
		T_Damage (other, self, self.owner, 250);  //was 10 -arg 150 should kill most monsters but all good players. newb players are pooned.
	}
	self.velocity = '0 0 0';
	self.avelocity = '0 0 0';
	sound (self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	sound (self.owner, TF_FLARE_LIT, "weapons/retract.wav", 0.8, TF_FLARE_OFF);
	self.ammo_cells = self.ammo_cells - 33;
	W_SetCurrentAmmo ();
	if (!self.owner.button0)
	{
		Reset_Grapple (self);
		return;
	}
	test = Check_Overhead ();
	if (!test)
	{
		Reset_Grapple (self);
		return;
	}
	self.owner.on_hook = TF_FLARE_OFF;
	if ((self.owner.flags & 512))
	{
		self.owner.flags = (self.owner.flags - 512);
		setorigin (self.owner, (self.owner.origin + '0 0 1'));
	}
	self.owner.lefty = TF_FLARE_OFF;
	self.enemy = other;
	self.think = Grapple_Track;
	self.nextthink = time;
	self.touch = SUB_Null;
};
void () Throw_Grapple =
{
	if (self.hook_out)
	{
		return;
	}
	KickPlayer (-1.000000, self);
	newmis = spawn ();
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.owner = self;
	self.hook = newmis;
	newmis.classname = "hook";
	makevectors (self.v_angle);
	newmis.velocity = (v_forward * 2000);
	newmis.angles = vectoangles (newmis.velocity);
	newmis.team_no = self.team_no;  // prevents auto sentry from firing on hook. For that matter, any new toy that wants to fire on other teams. -arg
	newmis.touch = Anchor_Grapple;
	newmis.think = Build_Chain;
	newmis.nextthink = (time + 0.1);
	setmodel (newmis, "progs/hook.mdl");
	setorigin (newmis, ((self.origin + (v_forward * 16)) + '0 0 16'));
	setsize (newmis, '-1 -1 -1', '1 1 1');
	self.hook_out = TF_FLARE_OFF;
	self.fire_held_down = TF_FLARE_OFF;
};
void () Service_Grapple =
{
	local vector hook_dir;
	if (!self.button0)
	{
		self.fire_held_down = TF_FLARE_LIT;
		if ((self.current_weapon == TF_FLARE_OFF))
		{
			Reset_Grapple (self.hook);
		}
	}
	if (((self.hook.enemy.classname == "player") || (self.hook.enemy.classname == "bot")))
	{
		if ((self.hook.enemy.health > TF_FLARE_OFF))
		{
			hook_dir = (self.hook.enemy.origin - self.origin);
		}
		else
		{
			Reset_Grapple (self.hook);
		}
	}
	else
	{
		if ((self.hook.enemy.classname != "player"))
		{
			hook_dir = (self.hook.origin - self.origin);
		}
	}
	self.velocity = ((normalize (hook_dir) * self.maxfbspeed) * 2);
	if (((vlen (hook_dir) <= 100) && self.lefty))
	{
		if (self.hook.goalentity)
		{
			self.hook.goalentity.think = Remove_Chain;
			self.hook.goalentity.nextthink = time;
		}
		self.lefty = TF_FLARE_LIT;
	}
};
#ifdef NEW_CLASS1
float CLASS_PROJECTILE = 6;
float WEAPON_SHOTGUN    = 1;
float WEAPON_ROCKET    = 2;
float WEAPON_SPIKES    = 4;
void () GoSmoke =
{
	dremove(self);
};
void (float shotcount, vector dir, vector spread) FireDiamonds =
{
	local vector direction;
	local vector src;
	makevectors (self.v_angle);
	src = (self.origin + (v_forward * 10));
	src_z = (self.absmin_z + (self.size_z * 0.7));
	ClearMultiDamage ();
	traceline (src, (src + (dir * 2048)), 0.000000, self);
	puff_org = (trace_endpos - (dir * 4));
	while ((shotcount > 0))
	{
		direction = ((dir + ((crandom () * spread_x) * v_right)) + ((crandom () * spread_y) * v_up));
		traceline (src, (src + (direction * 2048)), 0, self);
		if ((trace_fraction != 1))
		{
			TraceAttack (8, direction);
		}
		shotcount = (shotcount - 1);
	}
	ApplyMultiDamage ();
	Multi_Finish();
};
void () W_FireThumper =
{
	local vector dir;
	local entity muz;
	muz = spawn ();
	muz.owner = self;
	muz.movetype = MOVETYPE_NONE;
	muz.solid = 0;
	muz.velocity = '0 0 75';
	setorigin (muz, (((self.origin + (v_right * CLASS_PROJECTILE)) + (v_forward * 26)) + '0 0 11'));
	setmodel (muz, "progs/s_muzz.spr");
	setsize (muz, VEC_ORIGIN, VEC_ORIGIN);
	muz.think = GoSmoke;
	muz.nextthink = (time + 0.04);
	setorigin (muz2, (((self.origin + (v_right * CLASS_PROJECTILE)) + (v_forward * 26)) + '0 0 18'));
	setmodel (muz2, "progs/s_muzz.spr");
	setsize (muz2, VEC_ORIGIN, VEC_ORIGIN);
	muz2.think = GoSmoke;
	muz2.nextthink = (time + 0.04);*/
	sound (self, 1, "weapons/shotg3.wav", 1, 1);
	self.velocity = (self.velocity - (v_forward * 400));
	self.ammo_shells = (self.ammo_shells - 2);
	self.currentammo = (self.ammo_shells - 2);
	dir = aim (self, 100000);
	FireDiamonds (CLASS_PROJECTILE, dir, '0.05 0.05 0');
};
float (entity poorguy) HitLocation =
{
	local vector f;
	local vector g;
	local vector h;
	local float x;
	local float zdif;
	if ((((((((((poorguy.classname != "monster_dog") && (poorguy.classname != "monster_fish")) && (poorguy.classname != "monster_demon1")) && (poorguy.classname != "monster_shalrath")) && (poorguy.classname != "monster_tarbaby")) && (poorguy.classname != "monster_oldone")) && (poorguy.classname != "monster_dragon")) && (poorguy.classname != "monster_vomit")) && ((((poorguy.flags & FL_MONSTER) || (poorguy.classname == "player")) || (poorguy.flags & FL_CLIENT)) || (poorguy.classname == "monster_zombie"))))
	{
		f = (self.origin - self.origin);
		g_x = self.origin_x;
		g_y = self.origin_y;
		g_z = 0;
		h_x = poorguy.origin_x;
		h_y = poorguy.origin_y;
		h_z = 0;
		x = vlen ((g - h));
		f = ((normalize (f) * x) + self.origin);
		zdif = (f_z - poorguy.origin_z);
		if (((zdif < 0) && (poorguy.classname != "monster_wizard")))
		{
			sprint (self.owner, "You damaged its leg.\n");
			sound (poorguy, CHAN_WEAPON, "weapons/legshot.wav", WEAPON_SHOTGUN, ATTN_NORM);
			return (0.25);
		}
		else
		{
			if (((zdif > 20) && (poorguy.classname != "monster_shambler")))
			{
				sprint (self.owner, "Looks like you shot its head.....\n");
				sound (poorguy, CHAN_WEAPON, "weapons/headshot.wav", WEAPON_SHOTGUN, ATTN_NORM);
				return (WEAPON_ROCKET);
			}
			else
			{
				if (((zdif > /*svc_showlmp*/35) && (poorguy.classname == "monster_shambler")))
				{
					sprint (self.owner, "You shot it in the mouth.\n");
					sound (poorguy, CHAN_WEAPON, "weapons/headshot.wav", WEAPON_SHOTGUN, ATTN_NORM);
					return (WEAPON_ROCKET);
				}
			}
		}
	}
	if (((((((((poorguy.classname == "monster_dog") || (poorguy.classname == "monster_fish")) || (poorguy.classname == "monster_demon1")) || (poorguy.classname == "monster_shalrath")) || (poorguy.classname == "monster_tarbaby")) || (poorguy.classname == "monster_oldone")) || (poorguy.classname == "monster_dragon")) || (poorguy.classname == "monster_vomit")))
	{
		sound (poorguy, CHAN_WEAPON, "weapons/shot.wav", WEAPON_SHOTGUN, ATTN_NORM);
		return (WEAPON_SHOTGUN);
	}
	else
	{
		sound (poorguy, CHAN_WEAPON, "weapons/shot.wav", WEAPON_SHOTGUN, ATTN_NORM);
		return (WEAPON_SHOTGUN);
	}
};
void () FSnipe_Touch =
{
	local float ldmg;
	local float hitd;
	if (other.takedamage)
	{
		hitd = HitLocation (other);
		ldmg = (self.heat * hitd);
		spawn_touchblood (ldmg);
		T_Damage (other, self, self.owner, ldmg);
	}
	else
	{
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 0.000000);
		WriteCoord (4.000000, self.origin_x);
		WriteCoord (4.000000, self.origin_y);
		WriteCoord (4.000000, self.origin_z);
		multicast (self.origin, 1.000000);
	}
	remove (self);
};
void (vector org, vector dir) launch_arrow =
{
	newmis = spawn ();
	newmis.owner = self;
	newmis.movetype = MOVETYPE_BOUNCE;
	newmis.solid = SOLID_BBOX;
	newmis.angles = vectoangles (dir);
	newmis.touch = FSnipe_Touch;
	newmis.classname = "spike";
	newmis.think = SUB_Remove;
	newmis.nextthink = (time + 65);
	setmodel (newmis, "progs/spike.mdl");
	setsize (newmis, VEC_ORIGIN, VEC_ORIGIN);
	setorigin (newmis, org);
	newmis.velocity = (dir * 1000);
};
void () W_FireCrossbowArrow =
{
	if ((self.ammo_nails < WEAPON_SHOTGUN))
	{
		W_SetCurrentAmmo ();
		return;
	}
	self.ammo_nails = (self.ammo_nails - WEAPON_SHOTGUN);
	self.currentammo = (self.ammo_nails - WEAPON_SHOTGUN);
	sound (self, CHAN_WEAPON, "weapons/arrow.wav", WEAPON_SHOTGUN, ATTN_NORM);
	makevectors (self.v_angle);
	launch_arrow ((self.origin + '0 0 16'), v_forward);
	newmis.movetype = MOVETYPE_BOUNCE;
	newmis.touch = FSnipe_Touch;
	newmis.velocity = (v_forward * 2000);
	newmis.heat = 65;
	self.punchangle_x = CONTENT_SOLID;
};
void () W_FireDoubleThumper =
{
	local vector dir;
	local entity muz;
	if ((self.currentammo == WEAPON_SHOTGUN))
	{
		W_FireThumper ();
		return;
	}
	muz = spawn ();
	muz.owner = self;
	muz.movetype = MOVETYPE_NONE;
	muz.solid = SOLID_NOT;
	muz.effects = EF_ADDITIVE;
	muz.velocity = '0 0 75';
	setmodel (muz, "progs/s_muzz.spr");
	setsize (muz, VEC_ORIGIN, VEC_ORIGIN);
	muz.nextthink = (time + 0.04);
	muz.think = SUB_Remove;
	sound (self, CHAN_WEAPON, "weapons/shotg4.wav", WEAPON_SHOTGUN, ATTN_NORM);
	makevectors (self.v_angle);
	self.velocity = (self.velocity - (v_forward * 700));
	self.ammo_shells = (self.ammo_shells - WEAPON_SPIKES);
	self.currentammo = (self.ammo_shells - WEAPON_SPIKES);
	dir = aim (self, 100000);
	FireDiamonds (14, dir, '0.15 0.09 0');
};
#endif
#ifdef LTB2
void () LTB_Detonate =
{
	self.th_pain = SUB_Null;
	self.th_die = SUB_Null;
	self.owner = self.enemy;
	T_MissileTouch ();
};
void () LTB_Explode =
{
	sound (self, CHAN_AUTO, "weapons/tripbeep.wav", WEAPON_SHOTGUN, ATTN_NORM);
	self.nextthink = (time + 0.2);
	self.think = LTB_Detonate;
};
void () LTB_Explode2 =
{
	self.nextthink = (time + 0.2);
	self.think = LTB_Detonate;
};
void () LTB_Pain =
{
	self.health = WEAPON_SHOTGUN;
};
void () LTB_Arm =
{
	local vector org;
	local vector targ;
	makevectors (self.angles);
	org = (self.origin + self.view_ofs);
	targ = (org + (v_forward * 2000));
	traceline (org, targ, FALSE, self);
	if ((trace_fraction == WEAPON_SHOTGUN))
	{
		LTB_Explode ();
		return;
	}
	if (((trace_ent == self.enemy) && (self.weapon == FALSE)))
	{
		self.nextthink = (time + WEAPON_SHOTGUN);
		self.think = LTB_Arm;
		return;
	}
	if ((self.weapon == FALSE))
	{
		self.weapon = TRUE;
	}
	if (((trace_ent.velocity != VEC_ORIGIN) || (trace_ent.flags & FL_MONSTER)))
	{
		LTB_Explode ();
		return;
	}
	if ((self.attack_finished < time))
	{
		if (detail)
		{
			WriteByte (MSG_BROADCAST, SVC_TEMPENTITY);
			WriteByte (MSG_BROADCAST, TE_LIGHTNING1);
			WriteEntity (MSG_BROADCAST, self);
			WriteCoord (MSG_BROADCAST, org_x);
			WriteCoord (MSG_BROADCAST, org_y);
			WriteCoord (MSG_BROADCAST, org_z);
			WriteCoord (MSG_BROADCAST, trace_endpos_x);
			WriteCoord (MSG_BROADCAST, trace_endpos_y);
			WriteCoord (MSG_BROADCAST, trace_endpos_z);
		}
		self.attack_finished = (time + 0.2);
	}
	self.think = LTB_Arm;
	self.nextthink = (time + 0.07);
};
void () W_FireLTB =
{
	local vector source;
	local entity lasertrip;
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * AI_SURFACE)), FALSE, self);
	if ((trace_fraction == WEAPON_SHOTGUN))
	{
		return;
	}
	if ((trace_plane_normal_z != nnum))
	{
		return;
	}
	if ((trace_ent != world))
	{
		return;
	}
	self.ammo_rockets = (self.ammo_rockets - WEAPON_SHOTGUN);
	self.currentammo = (self.ammo_rockets - WEAPON_SHOTGUN);
	lasertrip = spawn ();
	lasertrip.owner = world;
	lasertrip.enemy = self;
	lasertrip.movetype = MOVETYPE_NONE;
	lasertrip.solid = SOLID_BBOX;
	lasertrip.classname = "laser_trip_bomb";
	lasertrip.angles = vectoangles (trace_plane_normal);
	lasertrip.weapon = FALSE;
	lasertrip.takedamage = DAMAGE_YES;
	lasertrip.health = WEAPON_SHOTGUN;
	lasertrip.th_pain = LTB_Pain;
	lasertrip.th_die = LTB_Explode2;
	lasertrip.think = LTB_Arm;
	lasertrip.nextthink = (time + WEAPON_SHOTGUN);
	lasertrip.attack_finished = (time + WEAPON_SHOTGUN);
	setmodel (lasertrip, "progs/tripbomb.mdl");
	setsize (lasertrip, VEC_ORIGIN, VEC_ORIGIN);
	setorigin (lasertrip, trace_endpos);
	sound (self, CHAN_WEAPON, "weapons/tripplac.wav", WEAPON_SHOTGUN, ATTN_NORM);
};
#endif
void () TeamFortress_Timeleft =
{
	local string st;
	local float seconds;
	local float remaining;
	local float intplaceholder;
	local float intseconds;
	local entity te;
	st = infokey (world,"time");
	te = find (world,classname,"countdown");
	if ((st == "off") && (te == world))
	{
		sprint(self,2,"Timeleft has been disabled.\n");
		return;
	}
	else
	if ((st != "off") && (te == world))
	{
		sprint(self,2,"Unknown.\n");
		return;
	}
	st = infokey (world,"timelimit");
	if (st == "0")
	{
		sprint(self,2,"There is no timelimit.\n");
		return;
	}
	seconds = stof(st);
	seconds = seconds * 60;
	st = ftos(seconds);
	remaining = seconds - te.no_grenades_1;
	if (remaining <= 0) 
	{
		sprint(self,2,"Time is up.\n");
		return;
	}
	sprint(self,2," ");
	intplaceholder = remaining;
	remaining = remaining / 60;
	seconds = 0;
	while (seconds < remaining)
	{
		seconds = seconds + 1;
	}
	seconds = seconds - 1;
	intseconds = seconds * 60;
	intseconds = intplaceholder - intseconds;
	if (seconds > 0) 
	{
		st = ftos(seconds);
		sprint(self,2,st);
		if (st == "1")
		{
			sprint(self,2," minute");
		}
		else
		{
		    sprint(self,2," minutes");
		}
		st = ftos(intseconds);
		if (st != "60")
		{
			sprint (self,2,", ");
			sprint(self,2,st);
			if (st == "1")
			{
			   sprint(self,2," second");
			}
			else
			{
			   sprint(self,2," seconds");
			}
		}
		sprint(self,2," remaining.\n");
	}
	else
	{
		st = ftos(intplaceholder);
		sprint(self,2,st);
		sprint(self,2," seconds remaining.\n");
	}
};
void() copb_eatCan =
{
	if (self.pk_canpabammo < 1)
	{
		self.pk_canpabammo = 0;
		return; 
	}
	self.pk_canpabammo = self.pk_canpabammo - 1;
	other = self;
	T_Heal (self, 150, 1); 
	self.copb_timeout = time + 30;
	self.search_time = time + (random() * 5);
	copb_checkFart();
};
void (entity inflictor, entity attacker, float damage, entity ignore, float radius) T_BeanDamage =
{
	local entity head;
	head = findradius (inflictor.origin, radius);
	if (damage < 1)
		return;
	while (head)
	{
		if (head != ignore)
		if (head.team_no != self.team_no)  // Don't damage players/minions on the same team.
		{
			if (head.takedamage)
			{
				if (CanDamage (head, inflictor))
				{
						if (head.classname != "turret")
							if (head.classname != "turret_base")
							{
								deathmsg = 203;
								T_Damage (head, inflictor, attacker, damage);
							}
				}
			}
		}
		head = head.chain;
	}
};
void() copb_checkFart =
{
	if (self.copb_nextFartTimeout < time) 
	{	
		if (self.search_time < time)
		{ 
			local string fartNoise;
					fartNoise = "weapons/copb/copb_4.wav";
				deathmsg = 203;
				T_BeanDamage (self, self, 22, self, 110); 								// EFC little fart damage/range
				self.search_time = time + 0.4 + (random() * 0.25);
		}
		else
		{
					fartNoise = "weapons/copb/copb_4.wav";
				deathmsg = 203;
				T_BeanDamage (self, self, 88, self, 290); 									// EFC BIG fart damage/range 
				self.search_time = time + 1 + (random() * 0.75);
		}
			sound (self, CHAN_AUTO, fartNoise, 1, ATTN_NORM);
			if (self.flags & FL_ONGROUND)
			{
				if (self.waterlevel > 2)
				{
					DeathBubbles(10);
				}
				setorigin (self, self.origin + '0 0 0'); // was 0 0 1 SH* test unstick
			self.velocity_z = self.velocity_z + 220 + (random() * 100);
			self.copb_nextFartTimeout = time + 2.4 + rint(random() * 1);
			}
	}	
};
//END