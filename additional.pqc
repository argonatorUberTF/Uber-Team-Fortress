// Uber Team Fortress - Open Sourced from:
//
// Mega Team Fortress, Coop vs monsters, added 4 player deathmatch, with or without bots, battle royale mode. 12-2019
// Author: Avirox (a.k.a. XavioR) up to 1-2015 with many others.
// Special thanks to Ratbert fo rguidance and some source from previous mods.
// Original MegaTeam Fortress Programmers: Ambush, Plexi, mod3m, Plasticity 1997
// Additional addons by Ratbert, Argonator, Agent, Pablo, Cloud, Doc 2010-2019, Often, Aberrant.
// Credits also to Hipnotic, Mega Team Fortress PTY LTD, Gold, Sh1thead. 
// Special thanks to Kevin(server admin), Shark(for putting up with me), Alissa(original MEGATF CE code, deadly sniper).
// Special thanks to Human[RUS](lotric) for remote testing server and hosting for bug sweeping.
// Cheers to fortressone.org for breathing new life into the client and server engines.
// Added painkeep weapons and impulse bindings from pk666 thanks to NIB and Shithead (SH), DOC (painkeep).
// Beartraps, gravity well, can of pork n beans, auto sentry guns added.  
//
// Original credit for Painkeep from Team Evolve. (also available for Quake 3). It's public domain now. 2015
// cmd changeteam blue, red, green, and yellow always enabled. You can fight alongside the monsters or summon more.
// Removed sounds for taunts, yells.
// Added two whole pounds of semicolons at the end of functions to not spazz out modern compilers. -arg
// It worked ok in 2008-2015 for that old compiler, but not by today's standards.
//
// Fixed grenade allocation at spawn based on 3 X ammo attribute with a minimum of 3 of each type.
// Now you can plant a prox at even newb levels regardless of ammo pack settings within each map.
//
// Edited monster summon time, damage, quantity based on attribute summon.
// Fixed the attribute saving feature for each player name logged on.
// It's important to remember your Quake name with special characters.
//
// "cmd telem" has been modified for survival mode to enabled.
// In survival mode, if you get disconnected or dropped, you can "cmd beg" to be let back in because,
// sometimes other players can't find or see your corpse. Or your player died and fell into an unobtainable area.
// Even if you use the resurrection cube, sometimes the player would spawn and just die again. :{
// Updated gibs to be tossed out (pk666), upgraded shotgun damage for tough monsters/players.
// Added splash effects for dropped entities/models into lava and water. addtosplash() .
// Fixed missing precached models, sounds, added VWEP support for Painkeep and Mega TF weapons.
// Typos and grammar of text notifications cleaned by unknown, and argonator.
// Addons and variables used by some modules that are commented out but need to be declared after defs.pqc
// Also added on painkeep vars for their modules of .qc code for functions.
// Use "cmd changeteam (color)" to join any 4 teams. You can load any non-coop map and just frag or CTF.
// You can even CTF/deathmatch with "coop" maps by not loading the .ENT file for that map.
// Regular deathmatch is possible by just loading a map without monsters.
// The medic class can heal with masters skill "cmd aura" when spawned.							
//		Quirks:
//	Summoned monsters might only target the RED team if monster maps are selected.
//	Beartraps stick where you place them and cannot be shot off you once clamped.
//	Beartraps will follow you through the teleporters once clamped.
//	Regular sentry guns and tesla coils envy the auto sentry guns and will target them as an enemy on your team.
//	This prevent someone just ganging a huge armada of sentry guns of both types along with the
//	Auto sentry guns are waterproof and cannot be toastered.
//  Removed the following monsters to free up precache for sounds and models:
//  Ogre cook, Vermis(lame), eel,and gremlin which didn't work.
//
//			
//BUGS:		
//			New bugs can be submitted to Github for tracking and resolution unbiased.
//			Volunteer devs of code/fixes/features gladly accepted.
//
//								TODO:
//	Clean up source code for easy compiliation in fteccgui and possibly 64bit versions.
// 	- Down to 4 warnings on ftegccui compiler in Windows.
//  Obtain source of mvdsv that will compile with newer versions with same xav tweaks.
//	Made the auto sentry guns and beartraps do Quad damage when that player is buffed with quad. -auto sentry done -arg
//	Add Painkeep explosive shotgun ammo when you pick up a pack from monsters. A few shells with rekt most monsters in a few shots.
//	If possible upgrade the lightning gun to the painkeep chain lightning gun.
//	Upgraded medic nail gun to lava nails ala rogue. - Set to 2.5 damage per nail now -arg
//	Adjust starting armor and speeds to rebalance things.
//	Add another weapon to the Pyro for even destructive backup. multi pyro rockets?
//  partial - sped up flame rockets and flamethrower. -arg 3/2020
//	Add Ratbert's nuke grenades to drop4 for demoman or pyro.  ?
//	Add Prozac/Ratbert's mini sentry guns of differing types. Some monsters/players are affected more
//	by plasma or fire damage than blast/nail damage.
//	Tame down the survival mode with less extra monster spawns to stay under the 512 entities limit.
//	Then again, the map makers should be aware of this and not use so many spawns.
//	Finish HALF-LIFE support. (A long march if asked for)
//	Add the Air fist weapon ala pain keep. 
//
//					Changes to existing classes:
//GOAL - Make it tougher to last to capture the flag with faster action, heinous
// amounts of weapons. Forcing the team to play as a team, not solo runners or rambos
// that take advantage of the bunny hop.
// All classes spawn with a minimum of 3 type 1, and 3 type 2 grenades.
// If a map doesn't have ammo bags that give grenades, fix the maps.
// The amount of additional grenades is 3X your ammo attribute gained from experience.
// All classes get bonus health, armor, ammo, reload time, summoning etc from the 
// attribute system based on experience points gain for frags.
// At level 80 you get the Xav Needler gun and lightning gun weapons. Bringover from Mega COOP.
// Achievement system similar to Xbox for bragging rights just like MegaTF COOP was.
// Scout has a bat for the axe, jetpack uses less cells, a bit more fire damage.
// Sniper had little changed. Already powerful and deadly enough. 
// Soldier. The attributes system can boost this class to very powerful levels.
// Demoman. Sticky pipebombs and laser trip bombs added.
// Medic can heal with cmd aura regardless of level, further than players can with attribute of masters of healing.
// Medic gets an upgrade of the super nailgun with 2.5 X "lava" nails.
// Heavy Weapons Guy can spool up assault cannon a bit faster, and uses less ammo per shot on 20mm mode.
// Pyro can fire faster flame rockets, has a chainsaw, and gets results.
// Spy has a grappling hook that uses less cells, and can "poon" enemies for gibs.
// Engineer can launch drones in a shorter timeframe, does a bit more damage per beam.
// Engineer gets a gravity gun, and can have a Tesla and Sentry built at the same time.
// All classes can buy weapon upgrades, powerups, and inventory then with the merchant
// and used them with cmd inv.
// Custom player skins are possible. Not restricted per class.
// Pants color is still enforced like usual for regular TF classes if no custom skin.
// Spies can change either pants color or skins or have custom skins.
// Spies do not show up on auto_id which was a dead giveaway spy checker.
// Some admin surely had a boner for spy reduction, just catch them and whack them.
// Spies however, do not get a spot player fob marker when undercover. Gun check them.
// The Scout can still detect spies.
//
//						CODING TIPS
// Don't leave blank lines, or use /* /* comments, adds to code size by 12%, slows things down a lot.
// For the love of god, use // for comments instead. Sparingly.
// Production/release code should only have the minimum comments to speed up the code.
// This particular build only runs in window with MSDSV .28BXE build.
// XAV did some tweaks to that build used here.
// Don't change defs.pqc or run the risk of the dreaded, "You must have progs.dat installed" server error/crash messages.
// Add additional variables HERE, additional code or #includes here. Not in defs.pqc.  
// Global variables merged into this file can be then referenced by all functions which makes it easier to
// write newer functions.  Sorted by mod addons. Basic functions are here that were referenced several times throughout
// many mods. 
// Generally in this order:
// #defines, .floats, .entities, vectors, static floats , floats, float functions, and then void().
// Commented where applicable in which mod genre. Nehara, rogue, painkeep, lms, etc.
#define mtf_coop_hipnotic
#define MENU_ENGINEER_FIX_TELEPORTER	33 // in customTF this value is different.
#define LIGHTNING_ADD	7		//from player.pqc
#define TRAIN_RETRIGGER		1 //johnfitz -- retriggerable trains plats.pqc
#define ZG_PICKUPDIST_EXTRA			48	// extra distance added to pickupee's maxs, was 32
#define TFI_MAXLINES		350			// no TFI file should exceed this many lines
#define LOAD_THINKWALK					1
#define LOAD_THINKSTAND					2
#define	CheckScoreCVAR
#define LAZY_WAY			// client number hax
//#define HL_MAP		cvar("halflifebsp") == 1  //Defines map as a half life map. A switch, no longer used. -arg
#define next_push_time lefty
#define FIRST_AWD_LINE		7
#define true 1
#define TELEPORTER_CELLS	8 //How many cells to use on teleport
#define TELEPORTER_WAIT		2  //How long to wait after teleport (whole number)
#define SCREWUP_ONE     1
#define SCREWUP_TWO     2
#define FL_ONGROUND	    512 // standing on something
#define SOLID_BBOX	    2
#define CUSTOM_BUILDING 4
#define PC_UNDEFINED	0 
#define PC_CIVILIAN		12	// Civilians are a special class. They cannot be chosen by players, only enforced by maps
#define EF_BRIGHTFIELD	1 
#define EF_MUZZLEFLASH	2 
#define EF_BRIGHTLIGHT	4 
#define EF_DIMLIGHT	    8
#define CONTENT_EMPTY	-1 
#define CONTENT_SOLID	-2 
#define CONTENT_SKY	-6 
#define TE_EXPLOSION		3 
#define SVC_TEMPENTITY		23 
#define MSG_BROADCAST 4 // not sure about this - XavioR
#define MWEAPON_ROCKETLAUNCHER	1	// rocket grunt
#define MWEAPON_LRG			2	// long-range gren ogre	// 01/02/2009: Now a permanent weapon for ogre
#define MWEAPON_FIREBALL		4	// fireball fiend
#define MWEAPON_FASTSHOT		8	// Fast-shot hell knight
#define MWEAPON_SNIPER			16	// Sniper Enforcer
#define MWEAPON_PLAGUE			32	// Plague Zombie
#define MWEAPON_FLAME			64	// Flame Shambler
#define MWEAPON_MIRV			128	// MIRV Ogre
#define MWEAPON_BOUNCEMISSILE	256	// Bouncing Projectiles (monster_wizard)
#define loot_owner 		saboteur
#define loot_owner_time	chute_count
#define COOP_LEVEL_ONE		250	// moved to top.. 
#define COOP_LEVEL_TWO		750
#define COOP_LEVEL_THREE	2000
#define COOP_LEVEL_FOUR		4000
#define COOP_LEVEL_FIVE		8000
#define COOP_LEVEL_SIX		15000
#define COOP_LEVEL_SEVEN	25000
#define COOP_LEVEL_EIGHT	40000
#define COOP_LEVEL_NINE		70000
#define COOP_LEVEL_TEN		120000
#define COOP_LEVEL_AFTERTEN	200000
#define MAX_RANKS			20
#define MAX_MAPRANKS		250
#define MAX_LEVEL			120
#define	MAX_SPEND			10			// max you can spend on any single attribute
#define	MASTERS_LEVEL		7			// you need this many of an attribute to unlock its master skill
#define fixflags rs_g
#define mtf_coop_rogue
#define lm_next_check_time		quickshot_attr
#define next_warning_time 	has_voted
#define last_health			vote_wait
#define RETURN_HEAD_NORMAL	1
#define RETURN_HEAD_ZOMBIE	0
#define MAX_INV_START		3
#define RETURN_ITEM_NO		0
#define RETURN_FREE_SLOT	1
#define SELL_TO_MERCHANT	0
#define SELL_TO_PLAYER		1
#define P_TO_ALL 			0
#define P_TO_SELF 			1
#define FRAME_25PERCENT		3
#define FRAME_50PERCENT		2
#define FRAME_75PERCENT		1
#define FRAME_100PERCENT	0
#define FRAME_125PERCENT	4
#define NO_SUICIDE_WAIT
#define EF_BRIGHTFIELD=1;
#define EF_MUZZLEFLASH=2;
#define EF_BRIGHTLIGHT=4;
#define EF_DIMLIGHT=8;
//
//					ENGINE HOOKS not defined in defs.pqc .

//
//
//							ENTITIES
.entity lastplayer;		//for half-life, also required for misc.pqc functions -arg
.entity pickedupobject_hands;
.entity pickupthink_hands;
.entity _oldowner;
.entity burn_flame;				// Nehara
.entity burn_flame2;			// Nehara
.entity objekt;					// Nehara
.entity pest;					// Nehara
.entity threat;					// Nehara
.entity building; 				// sentrygun stuff
.entity pickedupobject_hands;
.entity old_owner; // Lets not forget that most quakeworld servers have entity limits..
.entity lastvictim;				// Hipnotic 
.entity spawnmaster;			// Hipnotic 
.entity charmer;				// Hipnotic horn of conjuring
.entity next_ent;				// used for linked list of entities // Hipnotic
.entity owned_vehicle;
.entity lastmiss;
.entity real_owner;
.entity building;				//engineer stuff
.entity tent;
.entity camera_list;
.entity hook;					//grappling hook
.entity My_Old_Plane;			//btf
.entity Stinger_Target;			//btf
.entity helo_owner;				//btf
.entity holo_owner;				//btf
.entity linked_list;
.entity observer_list;
.entity pickedupobject_hands;
.entity pickupthink_hands;
.entity _oldowner;
.entity wooha;
.entity	shield_entity;				//MTF ROGUE
.entity nutarget;					// Rogue cutscene.qc
.entity beartrap_target;				//Painkeep
.entity playerfob_target;				//player fob to follow player
.entity turret_base;					// PAINKEEP
.entity turret_base;					//PAINKEEP
//entity playerfob;  //The color coded sprite for team that follows players except when invisible or in spy disguise.
entity rift;							//azothfight.qc -arg
entity bodyque_head; //From world.pqc -arg
entity egravity;						//needs to be an entity for collision detection with backbacks and other things. -arg
entity bt;								//the beartrap is an entity with a team_no now. -arg
entity tesla_target;					//hiptems.qc
entity lastspawn_team1, lastspawn_team2, lastspawn_team3, lastspawn_team4;
entity multi_ent;  //from weapons.pqc in the middle of the code.  Like everyone knows about it. -arg
entity lastspawn;
entity	le1, le2;
entity sight_entity;
entity nullentity;			//hipdefs.qc
entity bulletholes;			//hipdefs.qc
entity lastbullet;			//hipdefs.qc
entity hipdecoy;			//hipdefs.qc
entity tracetossent;			// Nehara
//entity rune_spawn_spot;					//spawn spot for runes	//runes.qc unused?
entity horn_charmer;			// horn of conjuring hipnotic hipitems.qc -arg
//entity mini_f_client; // for mini sentry guns from defs.qc -arg
//entity damage_inflictor;  //unused ? -arg
//.entity bolt_target; // PK current player firing at ...
//.entity bolt_targetNext; // PK next target in the chain...
//.entity bolt_targetTimeoutEntity; // PK Entity timeout, used just for the nextthink!
//.entity bolt_lightningFire;  // Used as the lightning fire source entity so that the "player" can fire lightning himself
//
//							.floats go here
//
.float ident;					//From travail_defs_funcs.qc -arg
.float temp6;					//From travail_defs_funcs.qc -arg
.entity ubs_point;				//From travail_defs_funcs.qc -arg
.float ubs_deflapped;			//From travail_defs_funcs.qc -arg
.float is_poisoned;				//From travail_defs_funcs.qc -arg
.float pcolor;					//From travail_defs_funcs.qc -arg
.float poison_time;				//From travail_defs_funcs.qc -arg
.float fob;  //player's colored fob dot status, 0 = off 1= has one already. -arg
.float DropFlagDelay;		//camera.pqc
.float nojumptime; //moved here from client.pqc
.float saved_ent;
.float old_movetype;			//bigtank.qc
.float shield; 					//travail gug.qc, was also used in vermis, but that's been removed -arg 
.float disconnectPlayer; // for pk beartrap stuff and client.pqc -arg
.float copb_timeout;							// PAINKEEP
.float copb_nextFartTimeout;					// PAINKEEP
.float inwater; 								// PK The water type the entity was in at last check
.float beartrapdmg_time;				// PAINKEEP
.float dodmg;							// PAINKEEP beartrap
.float pk_gravitywellammo, pk_turretammo, pk_canpabammo, pk_beartrapammo;	// PAINKEEP
.float beartrap_time;					// PAINKEEP
.float bt_immune_time;					// PAINKEEP beartrap
.float pk_currentitem;					//PAINKEEP
.float turret_timeout;					//PAINKEEP  
.float turret_soundtimeout;				//PAINKEEP
.float turret_ownertimeout;				//PAINKEEP	
.float inwater; // The water type the entity was in at last check. pk from splash.qc
.float beartrapdmg_time;				//Painkeep	
.float dodmg;							//Painkeep
.float brain;					// Nehara
.float frolic;					// Nehara
.float weld_light_time;			// Nehara	
.float burn_burning;			// Nehara
.float burn_painsound_time;		// Nehara
.float burn_damage_time;		// Nehara
.float burn_lifetime1;			// Nehara
.float burn_lifetime2;			// Nehara
.float burn_lifetime4;			// Nehara
.float tolerate;				// Nehara
.float talk_finished;			// Nehara
.float regen;					// Nehara
.float relations;				// Nehara
.float nojump;					// Nehara
.float boost;					// Nehara
.float tactic;					// Nehara
.float fangle;					// Nehara
.float fullbright;				// Nehara
.float method;					// Nehara
.float blink;					// Nehara
.float fog_enable;				// Nehara
.float fog_start;				// Nehara
.float fog_end;					// Nehara
.float fog_density;				// Nehara
.float fog_red;					// Nehara
.float fog_green;				// Nehara
.float fog_blue;				// Nehara
.float clfog_enable;			// Nehara
.float clfog_start;				// Nehara
.float clfog_end;				// Nehara
.float clfog_density;			// Nehara
.float clfog_red;				// Nehara
.float clfog_green;				// Nehara
.float clfog_blue;				// Nehara
.float walpha;					// Nehara
.float alpha;					// Nehara
.float dlmp;					// Nehara
.float script_count;			// Nehara
.float script_delay;			// Nehara
.float script_time;				// Nehara
.float wripple;					// Nehara
.float playerInRoom;			// dragon specific fields mtf_rogue
.float playerInTransit;			// dragon specific fields mtf_rogue
.float dragonInRoom;			// dragon specific fields mtf_rogue
.float dragonInTransit;			// dragon specific fields mtf_rogue
.float dragonAttacking;			// dragon specific fields mtf_rogue
.float dragonPainSequence;		// dragon specific fields mtf_rogue
//.float rune;					// what rune does this guy have? 	//runes.qc unused? -arg
//.float runetime;				// last time we told him he's already got a rune	//runes.qc
//.float rune1_last_noise_time;		//runes.qc unused?
//.float rune2_last_noise_time;		//runes.qc unused?
//.float rune3_last_noise_time;		//runes.qc unused?
//.float rune4_last_regen_time;		//runes.qc unused?
.float childrenSpawned;	// Other Rogue Fields
.float ltrailLastUsed;		// Other Rogue Fields
.float shield_death_time;	// Other Rogue Fields
.float shieldSoundTime;	// Other Rogue Fields
.float dragonDeathState;	// Other Rogue Fields
.float orbitPosition;		// new AI fields mtf_rogue
.float oldmovetype;
.float has_syringe, option, option5, is_squating;
.float last_used, tools, option4, vision, maxfbspeed;
.float useclip;
.float nojumptime;		 //moved here from client.pqc
.float flags2;			//BTF Stuff --
.float aagun;			//BTF Stuff --	
.float thingtype;		//BTF Stuff --	
.float pdmg;			//BTF Stuff --
.float Aircraft_Owner;	//BTF Stuff --
.float check_ok;		//BTF Stuff --
.float probe_active;	//BTF Stuff --
.float out_of_control;	//helo
.float Aircraft_Fuel;
.float Current_Speed;
.float flash;
.float Aircraft_Speed;
.float Aircraft_Falltime;
.float Old_Armor;
.float nextservice;
.float Old_Shells;
.float last_side;
.float Aircraft_Weapon;
.float ffar_reloaded;
.float vulcan_reloaded;
.float bullets_fired;
.float Stinger_LockTime;
.float tube_wing;
.float ammo_stingers;
.float voided;
.float tube_load;
.float aqua_sound;				//sub
.float aquamon;
.float Sub_Weapon;
.float fspec;					//light
.float fspec2;
.float tfstate;
.float	elevatorLastUse;		// elevator fields mtf_rogue
.float	elevatorOnFloor;		// elevator fields mtf_rogue
.float	elevatorToFloor;		// elevator fields mtf_rogue
.float	plat2Called;			// plat2 fields mtf_rogue
.float	plat2LastMove;			// plat2 fields mtf_rogue
.float	plat2GoTime;			// plat2 fields mtf_rogue
.float	plat2GoTo;				// plat2 fields mtf_rogue
.float	shield_finished, antigrav_finished;	//MTF ROGUE
.float	shield_time, antigrav_time;	//MTF ROGUE
.float	items2;					//MTF_ROGUE
.float 		inpain;					//MTF_ROGUE mummy.qc	
.float		ammo_shells1, ammo_nails1, ammo_rockets1, ammo_cells1; //MTF_ROGUE
.float		ammo_lava_nails;		//MTF_ROGUE
.float		ammo_multi_rockets;		//MTF_ROGUE
.float		ammo_plasma;			//MTF_ROGUE
.float maxammo_shells;
.float maxammo_nails;
.float maxammo_cells;
.float maxammo_rockets;
.float items_allowed;
.float armor_allowed;
.float maxarmor;
.float maxspeed;
.float weaponmode;			//End BTF Stuff
//
//megatf coop vars and such
.float oframe; // for doom and wolfd3d stuff
.float stats_on;
.float autoid;
.float autodiscard;
.float discard_max;
.float bugger;
.float active_grenades_1;
.float active_grenades_2;
.float tp_grenades_1;
.float tp_grenades_2;
.float got_aliases;
.float cheat_check;
.float is_removed;
.float is_undercover;
.float is_building;
.float is_detpacking;
.float is_feigning;		// The switch to determine if a player is feigning death as spy.
.float is_fob_disabled;	// If this gets turned on with cmd "dfob" it moves the colored player fob away from player. -arg
.float is_unabletospy;
.float has_disconnected;
.float has_dispenser;
.float has_sentry;
.float has_holo;
.float oldweapon;
.float oldcurrentammo;
.float dmgtime, gravity;
.float oframe;
.float playerclass;
.float nextpc;
.float last_impulse;
.float armorclass;
.float tf_items;
.float tf_items_flags;
.float no_grenades_1;	// The amount of type 1 grenades.
.float no_grenades_2;	// The amount of type 2 grenades.
.float h_i_g, r_i_g, a_s, a_n, a_r, a_c, rv_s_h, rs_s_h, rv_gr, rs_gr, rs_g;
.float rv_g;
.float area;
.float area;
.float area1;
.float area2;
.float temparea;
.float area_finished;
.float team_no;  // defines team numbers for entities like players, monsters, bots, and who created them. -arg
.float lives;
.float infection_team_no;
.float building_wait;
.float real_frags;
.float respawn_time;
.float suicide_time;
.float weapons_carried;
.float current_weapon;
.float ammo_medikit;
.float maxammo_medikit;
.float ammo_detpack;
.float maxammo_detpack;
.float reload_shotgun;
.float reload_super_shotgun;
.float reload_grenade_launcher;
.float reload_rocket_launcher;
.float heat;
.float immune_to_check;
.float last_saveme_sound;
.float goal_no;
.float group_no;
.float goal_state;
.float owned_by;
.float goal_activation;
.float goal_effects;
.float goal_result;
.float goal_group;
.float else_goal;
.float if_goal_is_active;
.float if_goal_is_inactive;
.float if_goal_is_removed;
.float if_group_is_active;
.float if_group_is_inactive;
.float if_group_is_removed;
.float activate_goal_no;
.float inactivate_goal_no;
.float remove_goal_no;
.float restore_goal_no;
.float activate_group_no;
.float inactivate_group_no;
.float remove_group_no;
.float restore_group_no;
.float has_item_from_group;
.float remove_item_group;
.float return_item_no;
.float if_item_has_moved;
.float if_item_hasnt_moved;
.float remove_spawnpoint;
.float restore_spawnpoint;
.float remove_spawngroup;
.float restore_spawngroup;
.float display_item_status1;
.float display_item_status2;
.float display_item_status3;
.float display_item_status4;
.float ex_skill_min;
.float ex_skill_max;
.float increase_team1;
.float increase_team2;
.float increase_team3;
.float increase_team4;
.float all_active;
.float item_list;
.float numflames;
.float delay_time;
.float dont_do_triggerwork;
.float g_a;
.float g_e;
.float undercover_team;
.float undercover_skin;
.float hook_out;
.float camdist;
.float on_hook;
.float fire_held_down; //btf
.float leg_damage;
.float FlashTime;
.float StatusRefreshTime;
.float StatusBarSize;
.float StatusBarRes;
.float Old_Health;
.float motd;
.float menu_count;
.float menu_displaytime;
.float inwater;				 // The water type the entity was in at last check
.float wetsuit_finished;
.float wetsuit_time;
.float color;
.float inpain;
.float endtime;		// Rotation	
.float rotate_type;	// Rotation
.float huntingcharmer;		// Hipnotic horn of conjuring	
.float charmed;			// Hipnotic horn of conjuring
.float duration;				// Hipnotic misc
.float items2;				// Hipnotic entry
.float gorging;			// Hipnotic 
.float stoleweapon;		// Hipnotic 
.float spawnsolidtype;		// Hipnotic 
.float spawnsilent;		// Hipnotic
.float spawnmulti;			// Hipnotic	
.float gravity;
.float DropFlagDelay; 			// from actions.pqc where this was hiding in duplicate code commented out ? -arg
.float idealpitch;				// calculated pitch angle for lookup up slopes
.float aagun_nextfire; 		   //btf?
.float fEnterTime, fUserID, fClientNo;
.float struck_by_mjolnir;	// Mjolnir
.float ishuman;					// frik code
.float Next_Aircraft_Time;		// next time player can enter helo after ejecting - should fix some bugs i hope
.float rotate_type;				//from hiprot.pqc
.float endtime;					//from hiprot.pqc
.float duration;				//from hiprot.pqc
.float healamount, healtype;
.float active_vehicle;
.float resup_vehicle;
.float color, option2; 			//func_rotating
.float oldmovetype; 			//gweapons.qc
.float option3;
.float	maxstrafespeed;			// Maximum side speed
.float nojumptime; 				//from client.pqc
.float fClientNo;
.float is_monster;
.float tools;					// TEMP HERE
// megatf coop carry-overs (AKA stuff that I was too lazy to change)
.float has_tesla;
.float distance;
.float rv_s_h;
.float mtf_items;
.float current_menu;			// ADDME, ok, added, organized -arg :}
//.float reloaded;			  // was hexen2.qc code, it's here, but unused -arg
//.float pk_currentInventory;		//pk Unused for now, -arg
//.float bolt_targetTimeout; 		// PK used to timeout the bolt_target...
//.float bolt_targetNextTimeout; 	// PK used to timeout the bolt_targetNext...
//.float bolt_conduitTimeout; 		// PK Entity conduit timeout if the entity handles it...
//.float bolt_changeModelTimeout; 	// PK used to change the view weapon modal timeout.
//.float last_teleport_time;		// teleport invulnerability UNUSED?
.float empathy_finished;			//hipitems.qc -arg
.float empathy_time;				//hipitems.qc -arg
//.float empathy_sound;
//.float pk_items; 					// Items used for impulse 1 //unused for now -arg
//.float display_msg_next;			// the next time the "you must be scout..." message can appear. unused var -arg
//.float is_mini; //For removed mini sentry guns and bot version -arg It was junk and didn't target monsters right.
//.float shieldOn;
.float() customizeentityforclient; 	//unused from wolf3d addon not included to reduce precache size. -arg
//.float mlah;							//from quoth monsfade.qc. unused -arg
//.float statevis;					// from polyp.qc, unused -arg
//.float polyp_speed;				// from polyp.qc, unused -arg
//.float (entity tcl) hlt_think;	//used only in half-life switched mode, unused -arg
//.float m_fMoveTo;					//for half life maps, unused -arg
//.float m_flRadius;
//.float radius;
// General doors/buttons
//.float rotation;					//for half-life, unused -arg
//.float locked_sound;				//for half-life, unused -arg
//.float initialstate;				//for half-life, unused -arg
//.float activated;					//for half-life, unused -arg	
//.float triggerstate;				// used for half-life, unused -arg
// Misc
//.float buoyancy;					// for func_pushable for half-life, unused -arg
//.float type;						// used with world_items
//.float vmultiplier;
//.float vsightmultiplier;
//.float client_gaunt_swoop_time;
//.float drole_searchtime;  		// from drole.qc unused in quoth -arg
//.float badhealth;					// from drole.qc -arg
//.float dlord_firecnt; 			// from dlord.qc -arg
//.float dlord_searchtime; 			// from dlord.qc -arg
//.float dlord_playervis; 			// from dlord.qc -arg
//.float grappleupdatetime;			//unknown unused variable -arg
//.float barrel;					// length of the barrel, half life functions, unused -arg
//.float yawtolerance;				// for hl_tankmotar for half-life, unused -arg
//.float pitchtolerance;			// for hl_tankmotar for half-life, unused -arg
//.float firerate;					// for hl_tankmotar for half-life, unused -arg
//.float m_accel;					// for half-life unused -arg
//.float m_distance;				// for half-life unused -arg
//.float m_time;					// for half-life unused -arg
//.float damp;						// for half-life unused -arg
//.float m_damp;					// for half-life unused -arg
//.float m_maxSpeed;				// for half-life unused -arg
//.float m_dampSpeed;				// for half-life unused -arg
//.float monstercount;				// for half-life unused -arg
//.float m_imaxlivechildren;		// max spawned ents that can be alive. // for half-life unused -arg
//.float drag;						// for half-life unused -arg
//water
//.float outwsound, inwsound, uwmuffle;	// for half-life unused -arg
//.float damagetype;				// for half-life unused -arg
//.float rendermode;				// for half-life unused -arg
//.float renderamt;					// for half-life unused -arg
//.float friction;					// for half-life unused -arg	
//.float friction_time;				// for half-life unused -arg
//.float friction_new;				// for half-life unused -arg
//.float modifier;					// for half-life unused -arg
// Ladder and water stuff (from extras quake mod)
//.float fwatershifttime;			// for half-life unused -arg
//.float ladderjump;				// for half-life unused -arg
//.float laddertime;				// for half-life unused -arg
//.float zerogtime;					// for half-life unused -arg
//.float fwatershift;				// for half-life unused -arg
//.float oldgravity;				// for half-life unused -arg
//.float m_fControl;				// for half-life unused -arg
//.float m_iCount;					// for half-life unused -arg
//.float m_flSpread;				// for half-life unused -arg
.string old_wpn_mdl;				//camera.pqc
#ifdef weapon_bat
.float FlashTime;
void () FlashTimer;
#endif
.string item;						//quake2.qc
.string client;
.string clientv;
.string undercover_name;
.string broadcast;
.string team_broadcast;
.string non_team_broadcast;
.string owners_team_broadcast;
.string netname_broadcast;
.string netname_team_broadcast;
.string netname_non_team_broadcast;
.string netname_owners_team_broadcast;
.string team_drop;
.string non_team_drop;
.string netname_team_drop;
.string netname_non_team_drop;
.string team_str_home;
.string team_str_moved;
.string team_str_carried;
.string non_team_str_home;
.string non_team_str_moved;
.string non_team_str_carried;
.string t_s_h;
.string t_s_m;
.string t_s_c;
.string n_s_h;
.string n_s_m;
.string n_s_c;
.string b_b;
.string b_t;
.string b_n;
.string b_o;
.string n_b;
.string n_t;
.string n_n;
.string n_o;
.string d_t;
.string d_n;
.string d_n_t;
.string d_n_n;
.string flame_id;
.string wad;
.string water_notify; // Set to "yes" to make a splash splash.qc -arg
.string active_all_message;		// (some of) ETF's goal properties
.string carried_message; //YOU have the flag
.string carried_sound;
.string allowteams;
.string spawnmodel;			// Hipnotic 
.string spawnclassname;		// Hipnotic 
.string path;			// Rotation
.string group;			// Rotation
.string event;			// Rotation
.string	wad;
.string oldweaponmodel;
.string path;		//from hiprot.pqc
.string event;		//from hiprot.pqc
.string group;		//from hiprot.pqc
.string soul;					// Nehara
.string sky;					// Nehara
.string script_num;				// Nehara
.string script;					// Nehara
.string next_script;			// Nehara
.string script_num;				// Nehara
.string script;					// Nehara
.string target2;				// Nehara
.string old_model; // After monster dies, revert its model
.string monster_string;
//.string m_iszEntity;		//for half-life, unused -arg
//.string landmark;		//used only in half-life-maps , unused -arg
//.string reachtarget;		// for half-life unused -arg
//.string cshift;			// for half-life unused -arg
//.string globalname;		// for half-life unused -arg
//.string changetarget;		// for half-life unused -arg
//.string globalstate;		// for half-life unused -arg
//.string LightningEnd, LightningStart;	// for half-life unused -arg
//.string TriggerTarget;	// for half-life unused -arg
//.string m_iszYController;	// for half-life unused -arg
//.string m_iszXController;	// for half-life unused -arg
//
//REGULAR STRINGS AND STRING FUNCTIONS.
string burn_pain_sound_1;				// Nehara
string burn_pain_sound_2;				// Nehara
string burn_extinguish_sound;			// Nehara
string burn_light_sound;				// Nehara
string weld_fire_sound_1;				// Nehara
string weld_fire_sound_2;				// Nehara
string weld_explode_sound;				// Nehara
string nextmap;
//string (string packet_cmd) Packet_Slashpass; // not used really since the funcs are disabled -arg
string() votesneededtostring; // for rpg.pqc
//VECTORS
.vector aether;					// Nehara
.vector xtrace;					// Nehara
.vector xgoal;					// Nehara
.vector dragonLastVelocity;		// dragon specific fields mtf_rogue
.vector	elevatorDestination; 	// elevator fields mtf_rogue
.vector punchangle;				//BTF Stuff, chopper, sub
.vector NoFuel_Velocity;		//BTF Stuff, chopper, sub
.vector old_position;
.vector camangle;
.vector proj_ofs;
.vector goal_min, goal_max;
.vector head_shot_vector;
.vector oldangle;
.vector cam_origin;
.vector old_velocity;				//laser cannon Hipnotic
.vector neworigin;					// Rotation
.vector rotate;						// Rotation
.vector spawnmins;					// Hipnotic
.vector spawnmaxs;					// Hipnotic
.vector neworigin;					//from hiprot.pqc
.vector rotate;						//from hiprot.pqc
.vector orig_origin;
//.vector oldenemyorigin;			// was used in vermis. quoth and other routines, unused -arg
//.vector oldangles;				// from dog.pqc, rat.pqc, and shambler.qc unused vars -arg
//.vector origin2;					// from gaunt.qc not used? -arg
//.vector origin3;					// from gaunt.qc not used? -arg
//.vector orig_angles;				// angles that an entity spawns with, generally. unused -arg
//.vector spawnorigin;				// used for half-life, unused -arg
//.vector rendercolor;				// for half-life unused -arg marioworld maps from agent.
//.vector m_center;					// for half-life unused -arg
//.vector m_start;					// for half-life unused -arg
//.vector g_vecZero;				// for half-life unused -arg
vector blood_org /* = '0 0 0' */;
vector puff_org /* = '0 0 0' */;
vector tower    = '1664 -1664 0';	//azothfight.qc
vector gate    = '2600 -2600 250';	//azothfight.qc
vector (float dm) VelocityForDamage;
vector GUN_FLAGROOM    = '325 -3280 -428'; //from frik2.qc -arg
//FLOAT CONSTANTS
float TF_FLARE_OFF    = 1;
float	MASK_ENGINE		= 1;	//this is special. Any entities known by the engine but not the csqc will be added.
//you can add any other masks below, remember, use bits. from csqc.defs -arg
float	MASK_NORMAL		= 2;
float ITEM_RUNE1 = 1;				// Rune of Earth Magic:  Resistance		//runes.qc
float ITEM_RUNE2 = 2;				// Rune of Black Magic:  Strength		//runes.qc
float ITEM_RUNE3 = 4;				// Rune of Hell Magic:  Haste			//runes.qc
float ITEM_RUNE4 = 8;				// Rune of Edler Magic:  Regeneration	//runes.qc
float IT_SWORD   = 4096;			//Nehara
float MC_CONTROL = 1;				//Nehara
float MC_UP      = 2;				//Nehara
float NAVLOGIC   = 1;				//Nehara
float INTREPID   = 2;				//Nehara
float BLINK      = 4;				//Nehara
float TRIGGER_SPAWN = 32;			//Nehara
float EF_NODRAW  = 16;				//Nehara
float NO_SWIM	 = 16;				//Nehara
float FL_BLOODLESS = 8192;			//Nehara
float FL_FLEE      = 16384;			//Nehara
float FL_FREE      = 32768;			//Nehara
float FL_COMMAND   = 65536;			//Nehara
float FL_STRAT   = 131072;			//Nehara
float IT_AUTO_SHOTGUN    = 8388608;	//Nehara
float IT_SPROCKET  = 128;			//Nehara
float WELD_DAMAGE_RADIUS    = 70;	//Nehara	
float IT_FLIGHT = 8388608;		//Nehara
float IT_KNIFE	= 4096;
float IT_PISTOL	= 1;
float IT_MACHINEGUN			= 2;
float IT_CHAINGUN				= 4;
float ip_timeout = 0.25;			// the timeout (in mins) where items move back to their original position...
float DOOR_START_OPEN = 1;
float DOOR_GOLD_KEY = 8;
float DOOR_SILVER_KEY = 16;
float DOOR_TOGGLE = 32;
float TF_FLARE_LIT = 0.000000;
float AS_STRAIGHT = 1;
float AS_SLIDING = 2;
float AS_MISSILE = 4;
float SPAWN_CRUCIFIED    = 1;		//from zombie.qc
//float SPAWNFLAG_SUPERSPIKE	= 1; // Hipnotic Constants
//float SPAWNFLAG_LASER = 2;
float SPAWNFLAG_LAVABALL = 4;
float SPAWNFLAG_ROCKET = 8;
float SPAWNFLAG_SILENT = 16;
float PK_IT_BEARTRAP = 128;		//Painkeep -arg
float MIN_ANGLE_DELTA = 10;
float START_OFF = 1;
float EF_BLUE =	64;
float AA_GUN_HEALTH =			450;
float AA_GUN_ROF =			.15;
float fMaxClients2 = 24;	// xavior: ADDME: dynamicize
//float SECRET_NO_SHOOT = 8.00000;  //unused
float START_ON = 1;				// flag. abe thinks right.
float TOGGLE = 1;				// flag. abe thinks right.
float ROTATION = 1;
float ANGLES = 2;				// flag. from abe.
float STOP = 4;
float NO_ROTATE = 8;
float VISIBLE = 1;
float DAMAGE = 2;
float TOUCH = 2;				// this one too.
float SET_DAMAGE = 4;			// i made this one up. -xav?
float MOVETIME = 32;
float NONBLOCKING = 4;
float STAYOPEN = 4;
float OBJECT_MOVEWALL = 2;
float OBJECT_ROTATE = 3;
float STATE_SPEEDINGUP = 4;
float STATE_ACTIVE = 5;
float OBJECT_SETORIGIN = 6;
float STATE_WAIT = 7;
float STATE_SLOWINGDOWN = 8;
float STATE_INACTIVE = 9;
float STATE_OPENING = 10;
float STATE_CLOSING = 11;
float STATE_MOVE = 12;
float STATE_STOP = 13;
float STATE_NEXT = 14;
float STATE_FIND = 15;
float STATE_OPEN = 16;
float STATE_CLOSED = 17;
float AS_MELEE    = 3;				// from fireworks.pqc
float SPAWNFLAG_SUPERSPIKE = 1;
float DOOR_DONT_LINK = 4;
float SPAWNFLAG_LASER = 2;
float FILE_READ = 0;
float FILE_APPEND = 1;
float FILE_WRITE = 2;
float RANK_ONE =		100;
float RANK_TWO =		250;
float RANK_THREE =	500;
float RANK_FOUR =		1000; 		// from rpg.pqc
float BOT_TOP_ELEV    = 1;  		//from frik2.qc -arg
float BOT_TOP_SPIRAL    = 2;
float BOT_FLAGROOM    = 4;
float BOT_BOTTOM_ELEV    = 8;
float BOT_BOTTOM_SPIRAL    = 16;
float BOT_BASEMENT    = 32;
float BOT_RAMPROOM    = 64;
float SVC_UPDATESTATLONG =	38;
float KILLINFWATER = 64;
float EASEUNDERCURRENT = 16;
float IT_LASER_CANNON = 8388608;
float IT_MJOLNIR = 128;
float IT_PROXIMITY_GUN = 65536;
float HIP_IT_WETSUIT = 2;
float HIP_IT_EMPATHY_SHIELDS = 4;
float HIP_IT_HORN_OF_CONJURING = 8;
float STAT_TOTALMONSTERS = 12;
float STAT_TOTALSECRETS = 11;
float AS_DODGING     = 5;
float CHARMED_RADIUS = 1500;
float MAX_CHARMER_DISTANCE = 200;
float MIN_CHARMER_DISTANCE = 150;
float TOOCLOSE_CHARMER_DISTANCE = 120;
float SVC_UPDATESTAT = 3;
float SVC_CUTSCENE   = 34;
float PK_BT_TIMETOFOLLOW = 30; 						// was 15 secs changed 1/19/2009 SH*
float PK_BT_DMG = 25; 								// was 2 SH*		2 is default in 1.1 now 4 -argonator for monsters/uber dm																
float PK_TP_SPARKSFLASH = 64;
float BT_BUFFER = 1.2;
float PK_GRAVITYWELLAMMO_MAX = 4;  // Not limited yet.
float PK_TURRETAMMO_MAX = 12;
float PK_CANPABAMMO_MAX = 4;
float PK_BEARTRAPAMMO_MAX = 12;
float EF_RED    = 128; //effects
//
//float SECRET_NO_SHOOT = 8.00000;	//unused
//						END FLOAT CONSTANTS
//
//
//FLOATS REGULAR
//float runespawn;	// have we spawned runes?	//runes.qc old ? unused? -arg
float horn_active;					//hipitems.qc -arg
float global_noticedelay;			//ai.pqc
float strategy_move;				// Nehara
float hknight_type;					// Nehara
float panzy_mode;					// Nehara
float irespawn;						// Nehara
float tesla_numtargets;				//hipitems.qc
float CHOOSE_ATMOS;					//thunder.qc
float FLASH_ON;						//thunder.qc
float COUNT_ON;						//thunder.qc
float COUNT_THUNDER;				//thunder.qc
float OFFSET_RAND;					//thunder.qc
entity theMachine;					//used for timemachine code. -arg
//float actorStage;					//Rogue ending.qc Not compiled until code is added/fixed -arg 11/2020
//float STAGE_START = 0;				//Rogue ending.qc Not compiled until code is added/fixed ending.qc -arg 11/2020
//float STAGE_TO_POINT1 = 1;			//Rogue ending.qc Not compiled until code is added/fixed -arg 11/2020
//float STAGE_AT_POINT1 = 2;			//Rogue ending.qc Not compiled until code is added/fixed -arg 11/2020
//float STAGE_TO_POINT2 = 3;			//Rogue ending.qc Not compiled until code is added/fixed -arg 11/2020
//float STAGE_AT_POINT2 = 4;			//Rogue ending.qc Not compiled until code is added/fixed ending.qc -arg 11/2020
//float STAGE_FIRING	= 5;			//Rogue ending.qc Not compiled until code is added/fixed ending.qc -arg 11/2020
float MUMMY_STRONG = 4;				//Rogue mummy.qc
float earthquake_active;			//MTF ROGUE
float earthquake_intensity;			//MTF ROGUE
float cutscene_running;				//MTF ROGUE
float IT2_ARMOR1				= 1;	//24 Other Rogue Fields
float IT2_ARMOR2				= 2;	// Other Rogue Fields
float IT2_ARMOR3				= 4;	// Other Rogue Fields
float IT2_LAVA_NAILS			= 8;	// Other Rogue Fields
float IT2_PLASMA_AMMO			= 16;	// Other Rogue Fields
float IT2_MULTI_ROCKETS			= 32;	//29
float IT2_SHIELD				= 64;	// Other Rogue Fields
float IT2_ANTIGRAV				= 128;	// Other Rogue Fields
float IT2_SUPERHEALTH			= 256;	//32
float IT2_EARTHQUAKE			= 512;	// Other Rogue Fields		
float IT2_V_SPHERE				= 1024;	// Other Rogue Fields
float IT_LAVA_NAILGUN			= 4096;	// xavior: er.. no..
float IT_GRAPPLE				= 8388608;
float SPAWN_LYING = 2;				//MTF ROGUE
float SPAWN_AMBUSH = 4;				//MTF ROGUE
float SPAWN_SNEAKY = 8;				//MTF ROGUE
float MUL_PHS    = 1;					//MTF ROGUE
float MUL_PVS    = 2;					//MTF ROGUE
float PLAT_LOW_TRIGGER = 1;				//MTF ROGUE
float   TE_EXPLOSION2   = 12;			//MTF ROGUE
float MULTI_USE = 1;					//hip_brk.qc
float INVISIBLE = 2;					//hip_brk.qc
float USE_PARTICLES = 0;				// xav: noooo?
float COUNTER_TOGGLE = 1;				//Hipnotic hipcount.qc
float COUNTER_LOOP = 2;					//Hipnotic hipcount.qc
float COUNTER_STEP = 4;					//Hipnotic hipcount.qc
float COUNTER_RESET = 8;				//Hipnotic hipcount.qc
float COUNTER_RANDOM = 16;				//Hipnotic hipcount.qc
float COUNTER_FINISHCOUNT = 32;			//Hipnotic hipcount.qc
float COUNTER_START_ON = 64;			//Hipnotic hipcount.qc
float UNDERWATER = 2;					//Hipnotic hipitems.qc
float LIGHTNING_RANDOM = 1;				//Hipnotic hipitems.qc
float LIGHTNING_BOOM = 2;				//Hipnotic hipitems.qc
float USE_COUNT = 1;					//Hipnotic hip_part.qc
float ATTN_ARMAGON = 0.5;				//Hipnotic hiparma.qc
float SERVO_VOLUME = 0.5;				//Hipnotic hiparma.qc
float USE_GOLD_KEY = 1;					//Hipnotic hiptrig.qc
float DN_N_WAIT 	= 1;				//Hipnotic newplats.qc
float PLT_TOGGLE 	= 2;				//Hipnotic newplats.qc
float ELEVATOR		= 4;				//Hipnotic newplats.qc
float START_AT_TOP  = 8;				//Hipnotic newplats.qc
float PLAT2			= 16;				//Hipnotic newplats.qc
float PLAT2_BOTTOM  = 32;				//Hipnotic newplats.qc
float ELV_BUTN_DIR;						//Hipnotic newplats.qc
float ELVTR_DOWN = 1;					//Hipnotic elevator.qc
float PEND_X = 1;						// Rogue pendulum.qc
float PEND_Y = 2;						// Rogue pendulum.qc
float PEND_Z = 4;						// Rogue pendulum.qc
float PEND_TRG = 8;						// Rogue pendulum.qc
float LT_TOGGLE =	1;					// Rogue lightning.qc
float LT_ACTIVE = 	2;					// Rogue lightning.qc
float DDIE_FALLING = 	1;				// Rogue dragon.qc
float DDIE_STOPPED =	2;				// Rogue dragon.qc
float DDIE_EXPLODED = 	3;				// Rogue dragon.qc
float DT_ROOM_A = 	1;					// Rogue dragon.qc
float DT_ROOM_B = 	2;					// Rogue dragon.qc
float DT_ROOM_C = 	4;					// Rogue dragon.qc
float FIRE_PLASMA =		1;				// Rogue dragon.qc
float FIRE_FIREBALL =	2;				// Rogue dragon.qc
float EQ_RANDOM 		= 1;			// Rogue earthq.qc
float poison_globaltime;				// From travail_defs_funcs.qc -arg
float numbulletholes;
float hknight_type;
float COUNT_MOOD_EFX;		// mood.. cuz im moody! TEEHEE
float achievements_enabled;		// can achievements be used?
float item_list_bit;
float num_world_flames;
float num_world_pipebombs;
float num_team_pipebombs_1;
float num_team_pipebombs_2;
float num_team_pipebombs_3;
float num_team_pipebombs_4;
float num_world_ammoboxes;
float num_team_ammoboxes_1;
float num_team_ammoboxes_2;
float num_team_ammoboxes_3;
float num_team_ammoboxes_4;
float spy_off;
float invis_only;
float allow_hook;
float live_camera;
float RUN_STRAIGHT;
float last_level;				// LMS STUFF
float lms_team1lives;
float lms_team1lives;			//LMS STUFF
float modelindex_hover;			// Malice
float modelindex_scuba;			// Malice	
float total_static_decor;
float NumProximityGrenades; // from hipmtf.qc -arg
float cr_scout, cr_sniper, cr_soldier, cr_demoman, cr_medic, cr_hwguy, cr_pyro, cr_spy, cr_engineer;
float clr_enabled;
float already_cycled;
float footsteps, old_gl, exec_class;
float coloredlights;
float FTE_Server;
#ifdef PL_FEM
float modelindex_player_f_blue, modelindex_player_f_red;
#endif
float modelindex_sub;
float headkick;
float BTF_Cached;
float numbulletholes;				//from hipdefs
float already_chosen_map;
float deathmsg;
float cycle_wrapped = 0;		//BTF Stuff
float toggleflags;
float respawn_delay_time;
float number_of_teams;
float illegalclasses;
float illegalclasses1;
float illegalclasses2;
float illegalclasses3;
float illegalclasses4;
float civilianteams;
float team1col;
float team2col;
float team3col;
float team4col;
float team1score;
float team2score;
float team3score;
float team4score;
float team1lives;
float team2lives;
float team3lives;
float team4lives;
float team1maxplayers;
float team2maxplayers;
float team3maxplayers;
float team4maxplayers;
float team1advantage;
float team2advantage;
float team3advantage;
float team4advantage;
float CTF_Map;
float coop;
float rj;
float pc2; 				// The content type the last entity to be checked just entered for pk splash effects. -arg
float splash_count; 	// The amout of splashes around. Used to keep the number down so we don't get any "No Free Edicts" messages
float footsteps;
float team1frags;		// added from tf 2.9:
float team2frags;
float team3frags;
float team4frags;
float PLAYER_COUNT;				// frik code
float userid2, fActiveClients2, fActiveClients1;		// frik code
float old20mm;					//used in weapons.pqc -arg
float (entity mnst) Is_Monster;  // oh joy another capitlization confused version of another similar variable. Not smart. -arg
float discharged;				//MED 01/05/97 added discharge variable
float multi_damage;
float blood_count;
float puff_count;
float current_yaw;
float enemy_vis, enemy_infront, enemy_range;
float enemy_yaw;
float dripsnd;
float suckwind;
float teamfrags;
float airscout, drop3;
float prematch; 
float lightning_end;
float sight_entity_time;
float nomap;
float intermission_running;
float intermission_exittime;
float modelindex_eyes, modelindex_player, modelindex_null;
float modelindex_plyr;				//BTF thing
float modelindex_aircraft; 			//BTF thing
float TurretNailSpeed = 1550;  // efc - PK Turret aiming. Was 450, but we are dealing with bots and cracked out monsters -arg
float intermission_running;						// PAINKEEP
float intermission_exittime;					// PAINKEEP
float turret_clearGround (entity head);			// PAINKEEP
float NOT_IN_WATER = 1;							// PAINKEEP
float (entity e) turret_inFront;				// PAINKEEP
// 					Unused defined floats
//float USE_PARTICLES = 1;				//HIP_EXPL.QC Particles?
//float SPAWNFLAG_SUPERSPIKE	= 1;
//float SPAWNFLAG_LASER = 2;
//float quakeactive; 				//from hipquake.qc, unused  -arg
// 							Triggers and such
//float useType; 			// used for half-life, unused -arg
//float NumGremlins;	  	//removed from code to free up precache for gremlins. -arg
//float NumSpawnGremlins;  //gremlin removed. -arg
//float visible_distance;	//was used in hipgrem.qc, removed from code -arg
//float landmarked; //Tells us that there is a landmark entity in the map being used for halflife maps. -arg
//
//				Unused function with float returns.
//float (entity check, entity checkFor) bolt_checkForLoops;		// PAINKEEP chain lightning gun,not yet
//float (entity targetEntity) bolt_infront;						// PAINKEEP
//
//===============================================================================
//Generally from here down is functions from Mega, Mega TF, Mega 2K, calling basic functions
//which were included in this file to make it debuggable and usable throughout any other mod or addon.
//
//void() func_pendulum;		 // for half-life unused -arg
// func_mortar_field 		//HALF-LIFE UNUSED -ARG
// func_tankmortar  		//from half-life ?
// func_friction		 	// for half-life unused -arg
//major .voids
.void() th_turn;			//From hipdefs.qc -arg
.void() spawnfunction;		//From hipdefs.qc -arg
.void() th_weapon;
.void() oldthink;
.void() spawnthink;			// Hipnotic
.void() th_wins;			//From neh_defsfuncs.qc -arg
.void() th_greet;			//From neh_defsfuncs.qc -arg
.void() th_special;			//From neh_defsfuncs.qc -arg
.void() th_mourn;			//From neh_defsfuncs.qc -arg
.void() th_back;			//From neh_defsfuncs.qc -arg
.void() th_runfire;			//From neh_defsfuncs.qc -arg
void () ai_turn;			//From neh_defsfuncs.qc -arg
void (vector dest3) ChooseTurn;	//From neh_defsfuncs.qc -arg
vector ( vector ang ) SUB_NormalizeAngles;	//From hipdefs.qc -arg
void (entity srcent, entity destent) SUB_CopyEntity;	//From hipdefs.qc -arg
void( vector loc, float rad, float damage, float dur, float pause, float vol) multi_explosion;	//From hipdefs.qc -arg
void(string targ, vector orig) become_decoy;	//From hipdefs.qc -arg
void() RotateTargets;		//From hipdefs.qc -arg
void() RotateTargetsFinal;	//From hipdefs.qc -arg
void() SetTargetOrigin;		//From hipdefs.qc -arg
void() LinkRotateTargets; 	//From hipdefs.qc -arg
.void() th_jugg;			//From travail_defs_funcs.qc -arg
.void() splash_func; // The function to call to make the splash splash.qc -arg
entity(float team_num) FindTeamSpawnPoint;
void () ScatterCaltrops;
void () removeplayerfob;
void () playerfob_think;
void () attachplayerfob; //The colored dot fob thing that tracks players even though their skin or colors are changed.
void () Merchant_SayWares;
void () Merchant_GenerateEntity ;
void () respawn;  //client.pqc but can be addressed here now. -arg
entity() SelectSpawnPoint;
entity() FindIntermission;
entity(entity scanner, float scanrange, float enemies, float friends) T_RadiusScan;
entity (float gno) Findgoal;
void () monster_spawner_spawn; //fix for 2fortfood_coop.bsp -arg
void () BTF_Precache;
//void () W_FireRocket;
void () missing_precaches;  //put sounds and models missing here to load first absolutely -arg
//						FLOAT FUNCTIONS and voids
void () EntityCount;
void () MTF_RemoveMonster;  //This was called in middle of mtf_coop.qc But should be defined first for summon_think to
// prevent crashes -arg
void( float howmany ) MTF_Coop_ViewTopRanks;
float( float currexp ) Coop_ExpForNextLevel;
void (float rank_pos, string nname, float exp) MTF_Coop_WriteNewRank;
void () MTF_Resurrect_Player_Find;
void () Vote_CheckWin;
void () summon_think;
void ( entity newmon, string newmon_cln ) SetSpawnFunc;		// FIXME: This is assuming that we're compiling with LMS mode..
//It is impossible almost to remove LMS code from the main loop. -arg
void(entity Item) mtf_tfgoalitem_drop;
void () tfgoalitem_remove;
void () tfgoalitem_dropthink;
void() HuntTarget;
void() ai_run_melee;
void() ai_run_missile;
void() ai_run_slide;
void() ai_run_fire;
void() ai_run_dodge;
void() ai_turn_in_place;
void(vector dest3) ChooseTurn;
void() ai_turn;
void() ai_stand;
void(float dist) ai_forward;
void(float dist) ai_back;
void () ChangePitch;
void (float dist) old_ai_walk;
float() FindTarget;
void(float dist) ai_walk;
void(float dist) ai_run;
void(float dist) ai_pain;
void(float dist) ai_painforward;
void () respawn_think;
void () respawn_monster;
float (entity ent) InSolid;
void() SightSound;
void() FoundTarget;
void() monster_use;
void() set_monster_health;
void () walkmonster_start_go;
void() item_megahealth_rot;
void() walkmonster_start;
void (float playerid, float item_slot, float item_price) Inventory_TradeItem;
void (entity loadent, string strflgs) ParseLoadFlags;
float (entity checkme) Set_SaveFlags;
void () PreMonsterItemTouch;
void (float can_be_dead) MonsterItemTouch;
float (string cln, string mdln) SaveLevel_CanWrite;
float ( float item_no ) Inventory_SelfUse;
void () TradeThink;
void ( ) MTF_Resurrect_Player_Find;
void (string cname) FindEntsWithClassname;
void (entity t_src) DisplayUseEntity;
float () Changelevel_SaveMapData;  		// was in hexen2.qc -arg
float () Changelevel_GetMapData;		// was in hexen2.qc -arg
void ( float sell_type, float slot_no, entity seller, entity buyer ) Inventory_SellItem;
float ( string nname, float inv_slot, float return_type ) Inventory_GetItem;
float ( float slot_no ) Inventory_UseItem;
void (float accept) Inventory_TradeItemDecision;
void (float playerid, float item_slot, float item_price)  Inventory_TradeItem;
float (string s1, string s2, string s3, string s4, string s5, string s6) More_Commands;
float(float num_args, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7) ClientCommand;
float() crandom;
void() Menu_StuffClassHelp;
void ( entity to_summon ) BeginSummon;
void () MTF_Coop_SummonMinion;
float() DoorShouldOpen; // from doors.pqc
float() Sentry_FindTarget;
float( entity counter ) counter_GetCount;
float( float pclass ) COOP_GetMaxGrensForClass;
float(float v) anglemod; // from fight.pqc
float() GetGrenadePossibility;
float() W_BestWeapon;
float(float orighp) MTF_Monster_Health2;
float()	DogCheckAttack;
float(string id_flame) RemoveFlameFromQueue;
float() DemonCheckAttack;
float(entity targ) range;
float(entity targ) infront;
float (entity targ, entity check) visible2;		//CH so you can check other then self
float /*WARNING: could not determine return type*/ () Tesla_Fire; //tesla.pqc
float /*WARNING: could not determine return type*/ () Tesla_FindTarget;
float /*WARNING: could not determine return type*/ () Security_Camera_FindTarget; //security.pqc
float (entity test) ZG_ItemType; //gweapons.qc 
void SV_ParseClientCommand (string st);
float(string mapstr) validatemap; // rpg.pqc
float(entity the_player, float amount, string give_what) Extra_Stuff;		// More Stuff Command goodness!
float(string votemap_name) Check_For_Bmodel;		// so players cant vote on bmodels
float() mtf_saveentity;
float(float v) anglemod;
float(entity targ) visible;
float(entity targ) visible;
float(entity Goal,entity AP) Activated; //from combat.pqc
float(entity targ,entity attacker,float damage) TeamEqualiseDamage;
float(float tno) num_team_ammoboxes;
float(entity atckr, entity inflictor, entity targ, float origdmg) MTF_Monster_Damage;
float(entity atckr, entity targ, float origdmg) MTF_Monster_Take_Damage;
float(entity from_ent, entity to_ent) coop_visible;
float()	DogCheckAttack;  //from ai.pqc
float() CheckExistence;
void(entity hit,float damage) AddMultiDamage;
void() check_shot_idle;
void() TeamFortress_NightVision;
void(entity e) AddToSplashBig;
void(entity e) AddToSplash;
void (entity ment) Coop_ClientFixRankings;  // from client.pqc
float (string nname) MTF_Coop_GetExperience;
void(entity plyr, entity targ, float override_amount) MTF_Coop_AddExperience;
void(float clientno, float clientfrags) svcUpdateFrags;
void(entity mnst) Monster_Stats_Send_Full;
string substr(string str, float start, float len);
float Coop_ExpForNextLevel (float exp);
void() Multi_Finish;
void() ApplyMultiDamage;
void(entity Goal,entity AP) DoGoalWork;
void(entity Goal,entity AP) DoGroupWork;
void(void() thinkst) SUB_CheckRefire;
void() ClearMultiDamage;
void(entity p) TeamFortress_SetSpeed;
void() s_explode1;
void() s_explode2;
void() s2_explode1;
void(vector org, float damage) SpawnBlood;
void() monster_death_use;
void (entity targ,entity attacker) ClientObituary;
void (float respawntime, void() spawn_func) COOP_SetupRespawn;
void()NormalGrenadeTouch;
void()NormalGrenadeExplode;
void()PlayerObserverMode;
void()MTF_RemoveMonster;
void(float damage,vector dir) TraceAttack;
void()ConcussionGrenadeTouch;
void()ConcussionGrenadeExplode;
void()ConcussionGrenadeTimer;
void(float scanrange) TeamFortress_Scan;
void(entity inflictor, entity attacker, float bounce, entity ignore) T_RadiusBounce;
void ()FlameMonster_Flame;
void ()changelevel_touch;
void()NailGrenadeTouch;
void(string halias, float himpulse1, float himpulse2) TeamFortress_Alias;
void()TeamFortress_Regenerate;
void()TeamFortress_RegenerateCells;
void(entity p) bound_other_ammo;
void (string gibname,float dm) ThrowGib;
void()lvl1_sentry_atk1;
void()ReCheckRestrictions;
void()turret_searchForEnemy;
void()turret_findTarget;
void()turret_attackEnemy;
void()turret_deathAnim;
void()turret_deathAnimBase;
void (vector org, vector vec) turret_launchNail;
void()turret_nailTouch;
void()turret_checkIfCanBeSolid;
void()turret_gibTouch;
void (float type) TeamFortress_DropAmmo;
void()make_explosion;
void()Sentry_HuntTarget;
void(float tno) RemoveOldAmmobox;
void (string gibname, float dm) turret_throwGib;
void (float shotcount,vector dir,vector spread) FireBullets;
void()Sentry_Rotate;
void()Sentry_Pain;
void()Sentry_Die;
float()Sentry_Fire;
void()lvl2_sentry_atk1;
void()lvl2_sentry_atk3;
void()lvl3_sentry_atk1;
void()lvl3_sentry_atk3;
void(entity gunhead) CheckSentry;
void(entity bld) CheckBelowBuilding;
void()Reset_My_Grapple;
void()Sentry_FoundTarget;
void()TeamFortress_AmmoboxTouch;
void(float tno)increment_team_ammoboxes;
void(float tno)decrement_team_ammoboxes;
void()SetMovedir;
float(float pc) IsRestrictedClass;
string(float pc) TeamFortress_GetClassName;
void(string halias, float himpulse1, float himpulse2) TeamFortress_Alias;
void()make_bubbles;
void()bubble_remove;
void()bubble_bob;
void(vector tdest, float tspeed, void() func) SUB_CalcMove;
void()SUB_CalcMoveDone;
void(vector destangle, float tspeed, void() func) SUB_CalcAngleMove;
void()SUB_CalcAngleMoveDone;
void()SUB_Null;
void()SUB_UseTargets;
void()SUB_Remove;
void()TeamFortress_ChangeClass;
void(entity Player) TeamFortress_TeamShowMemberClasses;
void(entity p) TeamFortress_SetSkin;
void() execute_changelevel;
void(entity Viewer, float pc, float rpc, float xavior_Var) TeamFortress_PrintClassName;
void(entity Goal) UpdateAbbreviations;
float(float pc) IsLegalClass;
void()TeamFortress_DisplayLegalClasses;
void()KickHead;
void()setup_strcat;
void()FixSoundCrap;
void()AC_Eject;
void()Stinger_TryLock;
void(float modelindex_ac)AC_MaintainAircraft;
void(entity rank_ent)Rank_FindStats;
void(entity rank_ent)Rank_UpdateStats;
void(entity rank_ent, float addscore)Rank_AddRank;
void(entity rank_ent, float addscore)Rank_AddFrags;
void(entity rank_ent, float addscore)Rank_AddFers;
void(entity rank_ent, float addscore)Rank_AddDeaths;
void()respawn_think;
void()SetUpPrematch;
void()set_suicide_frame;
void()player_touch;
void()TeamFortress_SetEquipment;
void()TeamFortress_SetHealth;
void()PlayerDie;
void() ferdisplay;
void(entity ritem, entity act) Respawn_Item;
void()ammo_touch;
void()SUB_regen;
void(float old, float new) Deathmatch_Weapon;
void(entity pl, float typ) PrintGrenadeType;
void()PlaceItem;
void()W_WeaponFrame;
void()W_SetCurrentAmmo;
void()player_pain;
void()BackpackTouch;
void()player_stand1;
void()TeamFortress_DetpackExplode;
void(float damage)spawn_touchblood;
void(entity vwup)VWEPS_Update;
void(vector org)spawn_tfog;
vector() wall_velocity;
void (vector org, entity death_owner) spawn_tdeath;
void(entity spy) TeamFortress_SpyCalcName;
void()EMPExplode;
void()weapon_touch;
void(entity this) FlameDestroy;
void(string nname, float exp)MTF_Coop_RanksExperience;
void( entity t_player, entity t_monster, float exptotal, float sayamount)MTF_Coop_AddExpAndWrite;
void()StartItem;
string substr(string str, float start, float len) = #116;
void( float howmany ) MTF_Coop_ViewTopRanks; //might help prevent a crash -arg
void(string nname, float exp) MTF_Coop_WriteExperience;
float( float currexp ) Coop_GetLevel;
void()MTF_Coop_ShowAttrib;
void()TeamFortress_MOTD;
void()TeamFortress_CheckTeamCheats;
float(float tno) TeamFortress_TeamGetColor;
void(entity Viewer, float pc, float rpc, float xavior_Var) TeamFortress_PrintClassName;
void()TeamFortress_RemoveTimers;
void(float Suicided) TeamFortress_SetupRespawn;
void()TeamFortress_ShowTF;
float(float pc) IsLegalClass;
void()FlareGrenadeThink;
void()Remove;  // pyro shit , why not just use #15 ?
void()superspike_touch;
void(vector org,vector dir) launch_spike;
void()SetupTeamEqualiser;
void()HallucinationTimer;
void(entity p) SetTeamName;
void(entity spy) Spy_RemoveDisguise;
void()Service_Grapple;
void()GrenadeTouch;
void()review_timeleft;
void(entity AD) ParseTFDetect;
entity(float ino) Finditem;
void(entity Item, entity AP, entity Goal) tfgoalitem_GiveToPlayer;
void(entity Goal, entity AP, entity ActivatingGoal) AttemptToActivate;
void()CTF_FlagCheck;
void () exit_vehicle;
void () Sub_Speed;
void()WorldFlame_touch;
void (entity t_plyr, float t_exp) CSQC_SendExperience;
void (entity plyr, float amnt, float rcrd) Record_Check;
void ()MTF_Priority_Precache;
entity(string type, entity p_owner) FlameSpawn;
void()DelayedResult;
float()Coop_ExpCurve;
void(float origexp, float newexp) MTF_Coop_CheckNewLevel;
void() FlameFollow;
void( float exptotal, string reason, float sayamount ) MTF_Coop_AddExpToAll;
void()FlashGrenadeExplode;
vector(entity proj) bounce_off_wall;
void()OnPlayerFlame_touch;
void()FlashGrenadeTouch;
void()FlareGrenadeExplode;
void()T_MissileTouch;
void()InitBodyQue;
void()NailGrenadeLaunchNail;
void()EMPGrenadeExplode;
void()FlareGrenadeTouch;
void(entity plyr, string nname, float exp) MTF_Coop_PreWriteExperience;
void() MTF_Coop_UpdateMapRanks;
void() GasGrenadeMakeGas;
void(float rcrd, float amnt, entity plyr) Record_Add;
void(float tno, float scoretoadd) TeamFortress_TeamIncreaseScore;
void(float all) TeamFortress_TeamShowScores;
float ( float getlevel ) Coop_ExpReq;
void()TF_PlaceItem;
void()TF_StartItem;
void()TF_PlaceGoal;
void()TF_StartGoal;
void()info_tfdetect;
void()info_player_teamspawn;
void()info_tfgoal;
void()info_tfgoal_timer;
void()item_tfgoal;
void(entity _p_1249, entity _p_1250) Killed;
void(entity AD) ParseTFDetect;
void(entity _p_1249, entity _p_1250) Killed;
entity(float ino) Finditem;
entity(float gno) Findgoal;
entity(float gno) Findteamspawn;
void(entity Goal) InactivateGoal;
void(entity Goal) RestoreGoal;
void(entity Goal) RemoveGoal;
float(entity Goal, entity Player, entity AP) IsAffectedBy;
void(entity Goal, entity Player, entity AP, float addb) Apply_Results;
float(entity Goal, entity AP) APMeetsCriteria;
void(entity Goal) SetupRespawn;
void()DoRespawn;
void(entity Goal, entity AP) DoGoalWork;
void(entity Goal, entity AP) DoGroupWork;
void(entity Item, entity AP) DoItemGroupWork;
void(entity Goal, entity AP) DoTriggerWork;
void(entity Goal, entity AP, float addb) DoResults;void(entity Goal, entity Player) RemoveResults;
void()tfgoal_touch;
void()info_tfgoal_use;
void()tfgoal_timer_tick;
void()item_tfgoal_touch;
void(entity Item, entity AP, entity Goal) tfgoalitem_GiveToPlayer;
void(entity Item, entity AP, float method2) tfgoalitem_RemoveFromPlayer;
void() tfgoalitem_remove;
void(entity Item, float PAlive, entity P) tfgoalitem_drop;
void(entity Item) tfgoalitem_checkgoalreturn;
void() ReturnItem;
void(entity Goal, entity Player, entity Item) DisplayItemStatus;
void()CTF_FlagCheck;
void()TF_PlaceItem;
void()TF_StartItem;
void()TF_PlaceGoal;
void()TF_StartGoal;
void()info_tfdetect;
void()info_player_teamspawn;
entity (float gno) Findgoal;
entity (float gno) Findteamspawn;
void(entity Goal) InactivateGoal;
void(entity Goal) RestoreGoal;
void(entity Goal) RemoveGoal;
float(entity Goal,entity Player,entity AP) IsAffectedBy;
void(entity Goal,entity Player,entity AP,float addb) Apply_Results;
void(entity Goal) SetupRespawn;
void() DoRespawn;
void(entity Item,entity AP) DoItemGroupWork;
void(entity Goal,entity AP) DoTriggerWork;
void(entity Goal,entity Player) RemoveResults;
void()info_tfgoal_use;
void()tfgoal_timer_tick;
void()item_tfgoal_touch;
void()tfgoalitem_remove;
void(entity Item) tfgoalitem_checkgoalreturn;
void() ReturnItem;
void(entity P) ForceRespawn;
void(vector org, entity shooter) MirvGrenadeLaunch;
void(entity t_plyr) CSQC_SendGrenTimer;
void() NailGrenadeExplode;
void(float tno) decrement_team_pipebombs;
void(entity inflictor, entity attacker, float damage, entity ignore) T_RadiusDamage;
void(entity targ, entity inflictor, entity attacker, float damage, float T_flags, float T_AttackType) TF_T_Damage;
void()EMPGrenadeTouch;
void()NapalmGrenadeTouch;
void()NapalmGrenadeExplode;
void()Napalm_touch;
void()MirvGrenadeTouch;
void()MirvGrenadeExplode;
void()T_IncendiaryTouch;
void(entity t_other) MTF_DoEndBonus;
void(entity Goal,entity AP,float addb) DoResults;
void() GotoNextMap;
void() Wizard_Bounce_Off_Walls;
void() Bounce_Off_Walls;
void() GasGrenadeTouch;
void() GasGrenadeExplode;
void() NailGrenadeNailEm;
void (string vname, float addness) MTF_Coop_RanksMapVote;
void (float rank_pos, string nname, float exp) MTF_Coop_WriteNewMapRank;
#ifdef PL_FEM
string (entity whom) GetPlayerModel =
{
	if (whom.gender == GENDER_FEMALE)
		if (whom.team_no == 1)
			return FEMALE_MODEL_BLUE;
		else

		if (whom.team_no == 2)
			return FEMALE_MODEL_RED;
	return "progs/player.mdl";
};
float (entity whom) GetPlayerModelindex =
{
	if (whom.gender == GENDER_FEMALE)
		if (whom.team_no == 1)
			return modelindex_player_f_blue;
		else
		if (whom.team_no == 2)
			return modelindex_player_f_red;
			
	return modelindex_player;
};
void (entity whom) SetPlayerModelindex =
{
	if (whom.gender == GENDER_FEMALE)
{
		if (whom.team_no == 1)
			modelindex_player_f_blue = whom.modelindex;
		else

		if (whom.team_no == 2)
			modelindex_player_f_red = whom.modelindex;
	}
	else
		modelindex_player = whom.modelindex;
};
#endif
void(entity te) dremove;
void(float normal) SUB_AttackFinished;
void() ResetMenu;
void(entity pl,string s1) CenterPrint;
void(entity pl,string s1,string s2) CenterPrint2;
void(float tno) TeamFortress_TeamSetColor;
void(float tno,float scoretoadd) TeamFortress_TeamIncreaseScore;
float(float tno) TeamFortress_TeamGetNoPlayers;
float() TeamFortress_TeamPutPlayerInTeam;
float(float tno) TeamFortress_TeamIsCivilian;
float(entity obj,entity builder) CheckArea;
float(float v) anglemod;
float(float tno) TeamFortress_TeamSet;
float(float tno) TeamFortress_TeamGetColor;
float(float aNum) roughRoot;
float(float tno) TeamFortress_TeamGetLives;
float(float tno) TeamFortress_TeamGetMaxPlayers;
float(entity Retriever, float AmmoType) TeamFortress_GetMaxAmmo;
float(entity Retriever, float WeaponType) TeamFortress_CanGetWeapon;
float(entity Retriever, entity Items) TeamFortress_AddBackpackItems;
string (float tno) TeamFortress_TeamGetColorString;
string(entity pl) GetStatusSize;
float(float tno) TeamFortress_TeamGetScore;
float() TeamFortress_TeamGetWinner;
float() TeamFortress_TeamGetSecond;
string(float num) NumberToString10;
string(float num) NumberToString100;
string(float num) NumberToString1000;
string(entity pl) GetStatusSize;
string(entity _p_3752) GrensToString;
string(float num) BlueScoreToString100;
string(float num) BlueScoreToString1000;
string(float num) RedScoreToString100;
string(float num) RedScoreToString1000;
string(float num) YellowScoreToString100;
string(float num) YellowScoreToString1000;
string(float num) GreenScoreToString100;
string(float num) GreenScoreToString1000;
string(entity _p_5356) DetpackTimeToString;
string(entity pl) ClipSizeToString100;
string(entity pl) DisguiseToString;
string(entity pl) SentryDetailsToString;
string(entity pl) SentryHealthToString;
void(entity targ, entity inflictor, entity attacker, float damage) T_Damage;
float(entity e,float healamount,float ignore) T_Heal;
float(entity targ,entity inflictor) CanDamage;
void(entity te) dremove = 
{
	if (te == world)
	{
		dprint("***BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG***\n");
		dprint("WORLD has nearly been removed. Don't worry\n");
		dprint("***BUG BUG BUG BUG BUG BUG BUG BUG BUG BUG***\n");
		return;
	}
	if (te.is_removed == 1)
	{
		return;
	}
	te.is_removed = 1;
	remove(te);
};
void(entity Item, entity AP, float method2) mtf_tfgoalitem_RemoveFromPlayer;
void() TeamFortress_GrenadePrimed;
void() RemoveFlare;
void() GrenadeExplode;
void() spike_touch;
void(entity Goal, entity Player, entity Item) DisplayItemStatus;
void(entity Item, entity AP, float method3) tfgoalitem_RemoveFromPlayer;
void() TeamFortress_MOTD;
void() beartrap_dropBearTrap;
void() beartrapTouch;
void() beartrapFollow;
void() beartrapDie;
void (string gibname, float dm) beartrap_throwGib;
float() turret_dropTurret; // +pk112
void() turret_searchForEnemy;
void() turret_findTarget;
void() turret_attackEnemy;
void() turret_deathAnim;
void() turret_deathAnimBase;
void(vector org, vector vec) turret_launchNail;
void() turret_nailTouch;
void() turret_checkIfCanBeSolid;
void() turret_gibTouch;
void() TeamFortress_Inventory;
void() TeamFortress_ShowTF;
void() TeamFortress_PrimeGrenade;
void() TeamFortress_ThrowGrenade;
void() TeamFortress_DisplayDetectionItems;
void() TeamFortress_SetHealth;
void() TeamFortress_SetEquipment;
void() TeamFortress_RemoveTimers;
void() TeamFortress_CheckClassStats;
void(entity Player, float Armorclass) TeamFortress_DescribeArmor;
void() TeamFortress_ExplodePerson;
void() NormalGrenadeTouch;
void() NormalGrenadeExplode;
void() PlayerObserverMode;
void(string halias, float himpulse1, float himpulse2) TeamFortress_Alias;
void() TeamFortress_Regenerate;
void() TeamFortress_RegenerateCells;
//void() Menu_Res;						//These were mentioned, but never defined -arg
//void(float inp) Menu_Res_Input;		//These were mentioned, but never defined -arg
void() Menu_VoteChoice;
void(float inp) Menu_VoteChoice_Input;
void() Menu_Merchant;
void(float inp) Menu_Merchant_Input;
void() Menu_Blackjack;
void(float inp) Menu_Blackjack_Input;
#ifdef CSQC
float(float tmno) TeamFortress_TeamGetIllegalClasses;
#endif
void (float tno,entity ignore,string st) teamsprint;
void() ResetMenu = 
{
	if (self.StatusBarSize == TF_FLARE_LIT)
	{
		CenterPrint(self, "\n");
	}
	else

	{
		self.StatusRefreshTime = time + 0.1;
	}
	self.menu_count = 25;
	self.current_menu = TF_FLARE_OFF;
};
float(float v) mathlib_anglemod =
{
	return v - floor(v/360) * 360;
};
float() customize_frame =
{
	local float		tmpang, totang;
	tmpang = mathlib_anglemod(other.angles_y);
	totang = mathlib_anglemod(self.angles_y - tmpang);
	if (totang < 157.5 && totang >= 112.5)
		self.walkframe = 1;
	else

	if (totang < 112.5 && totang >= 67.5)
		self.walkframe = 2;
	else

	if (totang < 67.5 && totang >= 22.5)
		self.walkframe = 3;
	else

	if (totang < 22.5 || totang >= 337.5)
		self.walkframe = 4;
	else
	if (totang < 337.5 && totang >= 292.5)
		self.walkframe = 5;
	else
	if (totang < 292.5 && totang >= 247.5)
		self.walkframe = 6;
	else
	if (totang < 247.5 && totang >= 202.5)
		self.walkframe = 7;
	else
		self.walkframe = 0;
	if (self.oframe != -1)
		self.frame = self.oframe + self.walkframe;
	else
		self.frame = self.frame;
	return TRUE;
};
float(entity targ) ai_distance =
{
local float		r;
	r = vlen (self.origin - targ.origin);
	r = r / 64;
	return r;
};
void () bounce_a =
{
	self.velocity = bounce_off_wall( self );
	self.nextthink = time + 15;
	if (self.velocity == '0 0 0')
		dremove(self);
};
void() DeathBubblesSpawn = 
{
	if (self.owner.waterlevel != 3)
	{
		return;
	}
	newmis = spawn();
	setmodel(newmis, "progs/s_bubble.spr");
	setorigin(newmis, self.owner.origin + '0 0 24');
	newmis.movetype = 8;
	newmis.solid = TF_FLARE_LIT;
	newmis.velocity = '0 0 15';
	newmis.nextthink = time + 0.5;
	newmis.think = bubble_bob;
	newmis.classname = "bubble";
	newmis.frame = TF_FLARE_LIT;
	newmis.cnt = TF_FLARE_LIT;
	setsize(newmis, '-8 -8 -8', '8 8 8');
	self.nextthink = time + 0.1;
	self.think = DeathBubblesSpawn;
	self.air_finished = self.air_finished + 1;
	if (self.air_finished >= self.bubble_count)
	{
		dremove(self);
	}
};
void(float num_bubbles) DeathBubbles = 
{
	local entity bubble_spawner;
	bubble_spawner = spawn();
	setorigin(bubble_spawner, self.origin);
	bubble_spawner.movetype = TF_FLARE_LIT;
	bubble_spawner.solid = TF_FLARE_LIT;
	bubble_spawner.nextthink = time + 0.1;
	bubble_spawner.think = DeathBubblesSpawn;
	bubble_spawner.air_finished = TF_FLARE_LIT;
	bubble_spawner.owner = self;
	bubble_spawner.bubble_count = num_bubbles;
	return;
};
void() DeathSound = 
{
//	local float rs;
	if (self.waterlevel == 3)
	{
		if (self.is_feigning)
		{
			DeathBubbles(2);
		}
		else
		{
			DeathBubbles(10);
		}
		sound(self, 2, "player/h2odeath.wav", 1, TF_FLARE_LIT);
		return;
	}
//	rs = rint(random() * 6 + 1);
//	if (rs == 1)
//	{
		self.noise = "player/death1.wav";
//	}
//	if (rs == 2)
//	{
//		self.noise = "player/death2.wav";
//	}
//	if (rs == 3)
//	{
//		self.noise = "player/death3.wav";
//	}
//	if (rs == 4)
//	{
//		self.noise = "player/death4.wav";
//	}
//	if (rs == 5)
//	{
//		self.noise = "player/mdeath5.wav";
//	}
//	if ((rs == 6))
//	{
//#ifdef newsounds2
//		if (random() > .6)
//			self.noise = "player/mdeath7.wav";
//		else
//#endif
//		self.noise = "player/mdeath4.wav";
//	}
//	if (rs == 7)				// STRONGBAD DEATH
//	{
//#ifdef newsounds2
//		if (random() > .6)
//			self.noise = "player/mdeath7.wav";
//		else
//#endif
//		self.noise = "player/mdeath6.wav";
//	}
	sound(self, 2, self.noise, 1, 1);
	return;
};
void() air_bubbles = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	precache_sound2 ("ambience/bubbles.wav");
	ambientsound(self.origin, "ambience/bubbles.wav", TF_FLARE_OFF, 2);
	precache_model("progs/s_bubble.spr");
	self.nextthink = time + TF_FLARE_OFF;
	self.think = make_bubbles;
};
void() make_bubbles = 
{
	newmis = spawn();
	setmodel(newmis, "progs/s_bubble.spr");
	setorigin(newmis, self.origin);
	newmis.movetype = 8;
	newmis.solid = TF_FLARE_LIT;
	newmis.velocity = '0 0 15';
	newmis.nextthink = time + 0.5;
	newmis.think = bubble_bob;
	newmis.touch = bubble_remove;
	newmis.classname = "bubble";
	newmis.frame = TF_FLARE_LIT;
	newmis.cnt = TF_FLARE_LIT;
	setsize(newmis, '-8 -8 -8', '8 8 8');
	self.nextthink = time + random() + 0.5;
	self.think = make_bubbles;
};
void() bubble_split = 
{
	newmis = spawn();
	setmodel(newmis, "progs/s_bubble.spr");
	setorigin(newmis, self.origin);
	newmis.movetype = 8;
	newmis.solid = TF_FLARE_LIT;
	newmis.velocity = self.velocity;
	newmis.nextthink = time + 0.5;
	newmis.think = bubble_bob;
	newmis.touch = bubble_remove;
	newmis.classname = "bubble";
	newmis.frame = TF_FLARE_OFF;
	newmis.cnt = 10;
	setsize(newmis, '-8 -8 -8', '8 8 8');
	self.frame = TF_FLARE_OFF;
	self.cnt = 10;
	if (self.waterlevel != 3)
	{
		remove(self);
	}
};
void() bubble_remove = 
{
	if (other.classname == self.classname)
	{
		return;
	}
	dremove(self);
};
void() bubble_bob = 
{
	local float rnd1;
	local float rnd2;
	local float rnd3;
	self.cnt = self.cnt + TF_FLARE_OFF;
	if (self.cnt == 4)
	{
		bubble_split();
	}
	if (self.cnt == 20)
	{
		dremove(self);
	}
	rnd1 = self.velocity_x + (-10 + random() * 20);
	rnd2 = self.velocity_y + (-10 + random() * 20);
	rnd3 = self.velocity_z + 10 + random() * 10;
	if (rnd1 > 10)
	{
		rnd1 = 5;
	}
	if (rnd1 < -10)
	{
		rnd1 = -5;
	}
	if (rnd2 > 10)
	{
		rnd2 = 5;
	}
	if (rnd2 < -10)
	{
		rnd2 = -5;
	}
	if (rnd3 < 10)
	{
		rnd3 = 15;
	}
	if (rnd3 > 30)
	{
		rnd3 = 25;
	}
	self.velocity_x = rnd1;
	self.velocity_y = rnd2;
	self.velocity_z = rnd3;
	self.nextthink = time + 0.5;
	self.think = bubble_bob;
};
void() func_wall_use = 
{
	if (world.wad == "q2q1tex.wad" || #DOOM_MAP)
	{
		if (self.has_tesla == SOLID_NOT)
		{
			setorigin(self, (self.origin+'3000 0 0'));
			self.has_tesla = SOLID_BSP;
		}
		else
		{
			self.has_tesla = SOLID_NOT;
			setorigin(self, (self.origin-'3000 0 0'));
		}
		if (!(self.spawnflags & 2))
			self.use = SUB_Null;
			
		return;
	}
	self.frame = TF_FLARE_OFF - self.frame;
};
void(float psize, entity p) KickPlayer = 
{
	msg_entity = p;
	if (psize > -3)
	{
		WriteByte(1, 34);
	}
	else
	{
		WriteByte(1, 35);
	}
};
void() muzzleflash = 
{
	WriteByte(4, 39);
	WriteEntity(4, self);
	multicast(self.origin, 2);
};
void() display_location = 
{
	local string st;
	st = vtos(self.origin);
	sprint(self, 2, st);
	sprint(self, 2, "\n");
};
void(entity pl, string s1) CenterPrint = 
{
	centerprint(pl, s1);
	pl.StatusRefreshTime = time + 1.5;
};
void (entity _p_3723, string _p_3724, string _p_3725) CenterPrint2 =
{
	centerprint (_p_3723, _p_3724, "\n", _p_3725);
	_p_3723.StatusRefreshTime = (time + 1.500000);
};
void (entity _p_3729, float _p_3730, string _p_3731) StatusPrint =
{
	centerprint (_p_3729, _p_3731);
	_p_3729.StatusRefreshTime = (time + _p_3730);
};
void (entity pl) RefreshStatusBar =
{
	local entity _l_3736;
	local string s1;
	local string s2;
	local string s3;
	local string s4;
	local string s5;
	local string s6;
	local string s7;
	local float win;
	local float sec;
	if ((pl.StatusBarSize == 0.000000))
	{
		pl.StatusRefreshTime = (time + 60.000000);
		return;
	}
	pl.StatusRefreshTime = (time + 1.500000);
	if ((pl.playerclass == 0.000000))
	{
		return;
	}
	s1 = GetStatusSize (pl);
	win = TeamFortress_TeamGetWinner ();
	sec = TeamFortress_TeamGetSecond ();
	if (((TeamFortress_TeamGetScore (win) > 100.000000) || (TeamFortress_TeamGetScore (sec) > 100.000000)))
	{
		if ((win == 1.000000))
		{
			s3 = BlueScoreToString1000 (team1score);
		}
		else
		{
			if ((win == 2.000000))
			{
				s3 = RedScoreToString1000 (team2score);
			}
			else
			{
				if ((win == 3.000000))
				{
					s3 = YellowScoreToString1000 (team3score);
				}
				else
				{
					s3 = GreenScoreToString1000 (team4score);
				}
			}
		}
		if ((sec == 1.000000))
		{
			s4 = BlueScoreToString1000 (team1score);
		}
		else
		{
			if ((sec == 2.000000))
			{
				s4 = RedScoreToString1000 (team2score);
			}
			else
			{
				if ((sec == 3.000000))
				{
					s4 = YellowScoreToString1000 (team3score);
				}
				else
				{
					s4 = GreenScoreToString1000 (team4score);
				}
			}
		}
	}
	else
	{
		if ((win == 1.000000))
		{
			s3 = BlueScoreToString100 (team1score);
		}
		else
		{
			if ((win == 2.000000))
			{
				s3 = RedScoreToString100 (team2score);
			}
			else
			{
				if ((win == 3.000000))
				{
					s3 = YellowScoreToString100 (team3score);
				}
				else
				{
					s3 = GreenScoreToString100 (team4score);
				}
			}
		}
		if ((sec == 1.000000))
		{
			s4 = BlueScoreToString100 (team1score);
		}
		else
		{
			if ((sec == 2.000000))
			{
				s4 = RedScoreToString100 (team2score);
			}
			else
			{
				if ((sec == 3.000000))
				{
					s4 = YellowScoreToString100 (team3score);
				}
				else
				{
					s4 = GreenScoreToString100 (team4score);
				}
			}
		}
	}
	s5 = ClipSizeToString100 (pl);
	s7 = GrensToString (pl);
	s2 = "\n";
	if ((pl.playerclass == 4.000000))
	{
		if (self.is_detpacking)
		{
			s2 = "                  setting ???????      \n";
		}
		else
		{
			_l_3736 = find (world, classname, "countdown_timer");
			while (_l_3736)
			{
				if ((_l_3736.owner == pl))
				{
					s2 = DetpackTimeToString (_l_3736);
					s6 = "                          ";
					centerprint (pl, s1, s6, s2, s3, s4, s5, s7);
					return;
				}
				_l_3736 = find (_l_3736, classname, "countdown_timer");
			}
		}
	}
	else
	{
		if ((pl.playerclass == 8.000000))
		{
			s2 = DisguiseToString (pl);
			centerprint (pl, s1, s2, s3, s4, s5, s6, s7);
		}
		else
		{
			if ((pl.playerclass == 9.000000))
			{
				if (self.has_sentry)
				{
					s2 = SentryHealthToString (pl);
					s6 = SentryDetailsToString (pl);
					centerprint (pl, s1, s6, s2, s3, s4, s5, s7);
					return;
				}
				else
				{
					if (self.is_building)
					{
						s2 = "                building               \n";
					}
				}
			}
		}
	}
	if (canusenew == 1)
	{
	if (self.infstaytime > time) 
	{
		s2 = strcat(ftos(self.inflicted), " damage\n");
	}
	else
	{
		s2 = "\n";
	}
	}
	centerprint (pl, s1, s2, s3, s4, s5, s6, s7);
};
float (float tno) TeamFortress_GetRealScore =
{
	local entity te;
	local float total;
	te = find (world, classname, "player");
	while (te)
	{
		if (te.team_no == tno)
		{
			total = total + te.real_frags;
		}
		te = find (te, classname, "player");
	}
	return total;
};
float() TeamFortress_TeamPutPlayerInTeam = 
{
	local float i;
	local float j;
	local float score1;
	local float score2;
	local float lowest;
	local float likely_team;
	i = 1;
	likely_team = random() * number_of_teams;
	likely_team = ceil(likely_team);
	if (likely_team == 0)
	{
		likely_team = number_of_teams;
	}
	lowest = 33;
	while (i < number_of_teams + 1)
	{
		j = TeamFortress_TeamGetNoPlayers(i);
		
		if (j < lowest)
		{
			if (TeamFortress_TeamGetMaxPlayers(i) > j)
			{
				lowest = j;
				likely_team = i;
			}
		}
		else
		if (j == lowest)
		{
			
			if (TeamFortress_TeamGetMaxPlayers(i) > j)
			{
				score1 = TeamFortress_GetRealScore(i);
				score2 = TeamFortress_GetRealScore(likely_team);

				if ( score1 < score2 )
				{
					likely_team = i;
				}
				else
				if (score1 == score2)
				{
					if (random() > 0.5)
					{
						likely_team = i;
					}
				}
			}
		}
		i = i + 1;
	}
	return TeamFortress_TeamSet(likely_team);
};
float(float tno) TeamFortress_TeamGetColor = 
{
	if (tno == TF_FLARE_OFF)
	{
		return 14;
	}
	if (tno == 2)
	{
		return 5;
	}
	if (tno == 3)
	{
		return 13;
	}
	if (tno == 4)
	{
		return 12;
	}
	return 0;
};
void(float tno) TeamFortress_TeamSetColor = 
{
	if (tno == TF_FLARE_OFF)
	{
		team1col = 14;
		return;
	}
	if (tno == 2)
	{
		team2col = 5;
		return;
	}
	if (tno == 3)
	{
		team3col = 13;
		return;
	}
	if (tno == 4)
	{
		team4col = 12;
		return;
	}
};
string(float tno) GetTeamName = 
{
	local string st;
	if (tno == TF_FLARE_OFF)
	{
		st = infokey(world, "team1");
		if (st == string_null)
		{
			st = infokey(world, "t1");
		}
		if (st == string_null || st == "")
		{
#ifdef id4
			return "usa";
#else
#ifdef halloween
			return "ghouls";
#else
			return "blue";
#endif
#endif
		}
	}
	else
	{
		if (tno == 2)
		{
			st = infokey(world, "team2");
			if (st == string_null)
			{
				st = infokey(world, "t2");
			}
			if (st == string_null || st == "")
			{
#ifdef id4
				return "uk";
#else
#ifdef halloween
				return "goblins";
#else
				return "red";
#endif
#endif
			}
		}
		else
		{
			if (tno == 3)
			{
				st = infokey(world, "team3");
				if (st == string_null)
				{
					st = infokey(world, "t3");
				}
				if (st == string_null || st == "")
				{
					return "yell";
				}
			}
			else
			{
				if (tno == 4)
				{
					st = infokey(world, "team4");
					if (st == string_null)
					{
						st = infokey(world, "t4");
					}
					if (st == string_null || st == "")
					{
						return "gren";
					}
				}
				else
				{
					st = "\"\"";
				}
			}
		}
	}
	return st;
};
void(entity p) SetTeamName = 
{
	local string st;
	stuffcmd(p, "team ");
	st = GetTeamName(p.team_no);
	stuffcmd(p, st);
	stuffcmd(p, "\n");
};
string /*WARNING: could not determine return type*/ (float tno) GetTrueTeamName =
{
	if ((tno == 1))
	{
		return (/*65868*/"Âìõå");
	}
	else
	{
		if ((tno == 2))
		{
			return (/*65873*/"Òåä");
		}
		else
		{
			if ((tno == 3))
			{
				return (/*65877*/"Ùåììï÷");
			}
			else
			{
				if ((tno == 4))
				{
					return (/*65884*/"Çòååî");
				}
				else
				{
					return (/*65890*/"ERROR");
				}
			}
		}
	}
};
float(float tno) TeamFortress_TeamSet = 
{
	local string st;
	local float tc;
//	if (teamplay < TF_FLARE_OFF)
//	{
//		sprint(self, 2, "Teamplay is not On, so FortressTeams are inactive.\n");
//		return 0;
//	}  // Complete bs there is always 1 team, blue and we want any team on any map. -arg
//Whether there are maps that can deal with 1,2, or 4 teams, they should make it better.
// or users should know that a 2 team only map might have a problem with 4. -arg
	local entity te;
	te = find ( world, classname, "info_lmsdetect" );
	while (te)
	{
		if (te.#lms_usegloballives > 0)
		{
			if (te.#lms_game_begun == #TRUE)
				self.#lms_lives = -1;
			else
				self.#lms_lives = te.#lms_usegloballives;
		}
		else
		if (te.#lms_useroundlives > 0)
		{
			if (te.#lms_game_begun == #TRUE)
		{
				self.#lms_lives = -1;
				self.monster_items = 1;//#lms_replenish_lives = 1;
			}
			else
				self.#lms_lives = te.#lms_useroundlives;
		}
		te = find (te, classname, "info_lmsdetect");
	}
//Nice check, but there are maps that can have 1,2,3,4 teams and not codified by the map creator.
//This is what changes team fortress maps into mega/uber regardless of creator.
//Let the players decide if the bugs and quirks are there. Just play the map. -arg
// Also an .ent file goes a long way to add spawns for other teams 3 4 if someone wants to mod a coop map or mega tf map to 4 teams -arg
//	if (tno > number_of_teams && number_of_teams != 0)
//	{
//		sprint(self, 2, "There can only be ");  //fixed wording -arg
//		st = ftos(number_of_teams);
//		sprint(self, 2, st);
//		sprint(self, 2, " teams on this map.\nTry again\n");
//		return 0;
//	}
	if (self.team_no > 0)
	{
		sprint(self, 2, "You're already in Team No ");
		st = ftos(self.team_no);
		sprint(self, 2, st);
		sprint(self, 2, ".\n");
//		return 0;  //Don't follow what the map.bsp file says , we can play 4 teams. -arg
	}
	tc = TeamFortress_TeamGetNoPlayers(tno);
	if (tc >= TeamFortress_TeamGetMaxPlayers(tno) && tc != 0)
	{
		sprint(self, 2, "That team is full. Go ahead, but consider picking another.\n");
//		return 0;  // So, maybe everyone wants to be on the same team, they will balance it themselves, if it's a match. -arg
	}
	if (TeamFortress_TeamGetColor(tno) == 0)
	{
		TeamFortress_TeamSetColor(tno);
//		if (TeamFortress_TeamGetColor(tno) == 0)
//		{
//			sprint(self, 2, "You can't start a new team with your color, since another ");
//			sprint(self, 2, "change your pants color, someone is already using that color or it is zero. Change your team with [cmd changeteam].\n");
//			return 0; //Who cares, we have autoid anyway as enemy or friendly.  perfidy allowed, customskins are allowed anyway. -arg
//		}
		bprint(2, self.netname);
		bprint(2, " has started Team No ");
		st = ftos(tno);
		bprint(2, st);
		bprint(2, ".\n");
		self.immune_to_check = time + 10;
		stuffcmd(self, "color ");
		tc = TeamFortress_TeamGetColor(tno) - TF_FLARE_OFF;
		st = ftos(tc);
		stuffcmd(self, st);
		stuffcmd(self, "\n");
		self.team_no = tno;
		self.lives = TeamFortress_TeamGetLives(tno);
		SetTeamName(self);
		if (self.playerclass == 0)
		{
			if (TeamFortress_TeamIsCivilian(self.team_no))
			{
				self.impulse = TF_FLARE_OFF;
				TeamFortress_ChangeClass();
			}
		}
		return TF_FLARE_OFF;
	}
	bprint(2, self.netname);
	bprint(2, " has joined Team No ");
	st = ftos(tno);
	bprint(2, st);
	bprint(2, ".\n");
	stuffcmd(self, "color ");
	tc = TeamFortress_TeamGetColor(tno) - TF_FLARE_OFF;
	st = ftos(tc);
	stuffcmd(self, st);
	stuffcmd(self, "\n");
	self.team_no = tno;
	if (self.team_no == 1)
	{
		teamcount1 = teamcount1 + 1;
	}
	if (self.team_no == 2)
	{
		teamcount2 = teamcount2 + 1;
	}
	if (self.team_no == 3)
	{
		teamcount3 = teamcount3 + 1;
	}
	if (self.team_no == 4)
	{
		teamcount4 = teamcount4 + 1;
	}
	self.immune_to_check = time + 10;
	self.lives = TeamFortress_TeamGetLives(tno);
	TeamFortress_TeamShowMemberClasses(self);
	SetTeamName(self);
	if (self.playerclass == 0)
	{
		if (TeamFortress_TeamIsCivilian(self.team_no))
		{
			self.impulse = TF_FLARE_OFF;
			TeamFortress_ChangeClass();
		}
	}
	return TF_FLARE_OFF;
};
void() TeamFortress_CheckTeamCheats = 
{
	local string st;
	local string sk;
	local float tc;
	local string csk;
	if (MTF_Coop_IsValidPlayer(self))
	{
		csk = MTF_Coop_GetSkin(self.connect_name, self.coop_exp);
	}
	if (self.immune_to_check > time)
	{
		return;
	}
	if (self.deadflag)
	{
		return;
	}
	if (self.team_no > 0 && teamplay > 0)
	{
		st = infokey(self, "bottomcolor");
		tc = stof(st);
// This whole kick for color change on spy is irrelevant now. -arg
//players can have custom colored skins, or pants, or shirt since they have  a color fob.
//		if (self.playerclass == 8 && self.undercover_team != 0)
//		{
//			if (TeamFortress_TeamGetColor(self.undercover_team) - TF_FLARE_OFF != tc)
//			{
//				stuffcmd(self, "color ");
//				tc = TeamFortress_TeamGetColor(self.undercover_team) - TF_FLARE_OFF;
//				st = ftos(tc);
//				stuffcmd(self, st);
//				stuffcmd(self, "\n");
//				bprint2(TF_FLARE_OFF, self.netname, " has been kicked for changing color.\n");
//				return;
//			}
//		}
//		else
//	{
//			if (tc != TeamFortress_TeamGetColor(self.team_no) - TF_FLARE_OFF)
//			{
//				stuffcmd(self, "color ");
//				tc = TeamFortress_TeamGetColor(self.team_no) - TF_FLARE_OFF;
//				st = ftos(tc);
//				stuffcmd(self, st);
//				stuffcmd(self, "\n");
//				bprint2(TF_FLARE_OFF, self.netname, " has been warned for changing pants color.\n");
//				sprint(self, 2, "You have been warned for changing your pants color. Don't do it.\n");
//				return;
//			}
	}
		if (self.playerclass != 0)
		{
			st = infokey(self, "skin");
			tc = 0;
			if (self.playerclass == 8 && self.undercover_skin != 0)
			{
				tc = 8;
				self.playerclass = self.undercover_skin;
			}
			if (self.playerclass == TF_FLARE_OFF)
			{
				sk = "airscout";
			}
			else
			{
				if (self.playerclass == 2)
				{
					sk = "tf_snipe";
				}
				else
				{
					if (self.playerclass == 3)
					{
						sk = "tf_sold";
					}
					else
					{
						if (self.playerclass == 4)
						{
							sk = "tf_demo";
						}
						else
						{
							if (self.playerclass == 5)
							{
								sk = "tf_medic";
							}
							else
							{
								if (self.playerclass == 6)
								{
									sk = "tf_hwguy";
								}
								else
								{
									if (self.playerclass == 7)
									{
										sk = "tf_pyro";
									}
									else
									{
										if (self.playerclass == 8)
										{
											sk = "tf_spy";
										}
										else
										{
											if (self.playerclass == 9)
											{
												sk = "tf_eng";
											}
											else
											{
												if (tc == 8)
												{
													self.playerclass = 8;
												}
												return;
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if (csk != "")
				sk = csk;
			if (st != sk)
			{
// We are always in mtf_coop mode defined on uber -arg
#ifndef mtf_coop_halloween
				TeamFortress_SetSkin(self);
//				bprint2(TF_FLARE_OFF, self.netname, " has been warned for changing skin.\n");
//				sprint(self, 2, "You have been warned for changing your skin. Use CMD CUSTOMSKIN instead.\n");
				return;
#endif
			}
			if (tc == 8)
			{
				self.playerclass = 8;
			}
		}
		st = GetTeamName(self.team_no);
		if (st != infokey(self, "team"))
		{
			SetTeamName(self);
//			sprint(self, 2, "You have been warned for changing your team. Use [cmd changeteam (color)] instead in console.\n");  //No longer applicable, however this stills comes up if you connect in survival with no team number selected. -arg
			return;
		}
};
void(float tno, float scoretoadd) TeamFortress_TeamIncreaseScore = 
{
	local entity e;
	if (tno == 0 || scoretoadd == 0)
	{
		return;
	}
	if (scoretoadd > 100)
	{
		scoretoadd = scoretoadd - 100;
		scoretoadd = scoretoadd * -1;
	}
	if (tno == TF_FLARE_OFF)
	{
		team1score = team1score + scoretoadd;
	}
	if (tno == 2)
	{
		team2score = team2score + scoretoadd;
	}
	if (tno == 3)
	{
		team3score = team3score + scoretoadd;
	}
	if (tno == 4)
	{
		team4score = team4score + scoretoadd;
	}
	if (toggleflags & 128)
	{
		e = find(world, classname, "player");
		while (e)
		{
			if (e.team_no == tno)
			{
				e.frags = TeamFortress_TeamGetScore(tno);
			}
			e = find(e, classname, "player");
		}
	}
};
float(float tno) TeamFortress_TeamGetScore = 
{
	if (tno == TF_FLARE_OFF)
	{
		return team1score;
	}
	if (tno == 2)
	{
		return team2score;
	}
	if (tno == 3)
	{
		return team3score;
	}
	if (tno == 4)
	{
		return team4score;
	}
	return 0;
};
float(float tno) TeamFortress_TeamGetLives = 
{
	if (tno == TF_FLARE_OFF)
	{
		return team1lives;
	}
	if (tno == 2)
	{
		return team2lives;
	}
	if (tno == 3)
	{
		return team3lives;
	}
	if (tno == 4)
	{
		return team4lives;
	}
	return 0;
};
float(float tno) TeamFortress_TeamGetNoPlayers = 
{
	local float size_team;
	local entity search;
	search = find(world, classname, "player");
	while (search != world)
	{
		if (search.team_no == tno)
		{
			size_team = size_team + TF_FLARE_OFF;
		}
		search = find(search, classname, "player");
	}
	return size_team;
};
float(float tno) TeamFortress_TeamGetMaxPlayers = 
{
	if (tno == TF_FLARE_OFF)
	{
		return team1maxplayers;
	}
	if (tno == 2)
	{
		return team2maxplayers;
	}
	if (tno == 3)
	{
		return team3maxplayers;
	}
	if (tno == 4)
	{
		return team4maxplayers;
	}
	return 0;
};
float() TeamFortress_TeamGetWinner = 
{
	local float i;
	local float j;
	local float highest;
	local float highestteam;
	i = TF_FLARE_OFF;
	highest = -100;
	highestteam = 0;
	while (i < number_of_teams + TF_FLARE_OFF)
	{
		j = TeamFortress_TeamGetScore(i);
		if (j > highest)
		{
			highest = j;
			highestteam = i;
		}
		i = i + TF_FLARE_OFF;
	}
	return highestteam;
};
float() TeamFortress_TeamGetSecond = 
{
	local float i;
	local float j;
	local float highest;
	local float highestteam;
	local float secondteam;
	local float second;
	i = TF_FLARE_OFF;
	highestteam = TeamFortress_TeamGetWinner();
	highest = TeamFortress_TeamGetScore(highestteam);
	secondteam = 0;
	second = -100;
	while (i < number_of_teams + TF_FLARE_OFF)
	{
		if (i != highestteam)
		{
			j = TeamFortress_TeamGetScore(i);
			if (j <= highest && j > second)
			{
				second = j;
				secondteam = i;
			}
		}
		i = i + TF_FLARE_OFF;
	}
	return secondteam;
};
void (float _p_6876) TeamFortress_TeamShowScores =
{
	local string _l_6877;
	local float _l_6878;
	local float _l_6879;

	_l_6878 = 1.000000;
	if ((_p_6876 == 2.000000))
	{
		while ((_l_6878 <= number_of_teams))
		{
			if ((TeamFortress_TeamGetColor (_l_6878) > 0.000000))
			{
				_l_6879 = TeamFortress_TeamGetScore (_l_6878);
				_l_6877 = TeamFortress_TeamGetColorString (_l_6878);
				bprint (2.000000, _l_6877);
				bprint (2.000000, ": ");
				_l_6877 = ftos (_l_6879);
				bprint (2.000000, _l_6877);
				bprint (2.000000, " ");
			}
			_l_6878 = _l_6878 + 1.000000;
		}
		bprint (2.000000, "\n");
		return;
	}
	while ((_l_6878 <= number_of_teams))
	{
		if ((TeamFortress_TeamGetColor (_l_6878) > 0.000000))
		{
			if (_p_6876)
			{
				bprint (2.000000, "Team ");
			}
			else
			{
				sprint (self, 2.000000, "Team ");
			}
			_l_6877 = ftos (_l_6878);
			if (_p_6876)
			{
				bprint (2.000000, _l_6877);
			}
			else
			{
				sprint (self, 2.000000, _l_6877);
			}
			if (_p_6876)
			{
				bprint (2.000000, " (");
			}
			else
			{
				sprint (self, 2.000000, " (");
			}
			_l_6877 = TeamFortress_TeamGetColorString (_l_6878);
			if (_p_6876)
			{
				bprint (2.000000, _l_6877);
			}
			else
			{
				sprint (self, 2.000000, _l_6877);
			}
			if (_p_6876)
			{
				bprint (2.000000, ") : ");
			}
			else
			{
				sprint (self, 2.000000, ") : ");
			}
			_l_6879 = TeamFortress_TeamGetScore (_l_6878);
			_l_6877 = ftos (_l_6879);
			if (_p_6876)
			{
				bprint (2.000000, _l_6877);
			}
			else
			{
				sprint (self, 2.000000, _l_6877);
			}
			if (_p_6876)
			{
				bprint (2.000000, "\n");
			}
			else
			{
				sprint (self, 2.000000, "\n");
			}
		}
		_l_6878 = _l_6878 + 1.000000;
	}
};
void (float all) TeamFortress_TeamShowScores2 =
{
	local string st;
	local float i;
	local float j;
	local float _l_7158;
	local float _l_7159;
	i = 1;
	_l_7158 = 0;
	_l_7159 = 0;
	if ((all == 2))
	{
		while ((i <= number_of_teams))
		{
			if ((TeamFortress_TeamGetColor (i) > 0))
			{
				j = TeamFortress_TeamGetScore (i);
				st = TeamFortress_TeamGetColorString (i);
				bprint (2, st);
				bprint (2, ": ");
				st = ftos (j);
				bprint (2, st);
				bprint (2, " ");
				if ((j >= TeamFortress_TeamGetScore (_l_7158)))
				{
					_l_7159 = _l_7158;
					_l_7158 = i;
				}
				else
				{
					if ((j >= TeamFortress_TeamGetScore (_l_7159)))
					{
						_l_7159 = i;
					}
				}
			}
			i = i + 1;
		}
		bprint (2, "\n");
		sound (world, 4, "misc/update.wav", 1, 0);
		if ((quadscore > 0))
		{
			if ((team1score > team2score))
			{
				bprint (2, "");
				bprint (2, TeamFortress_TeamGetColorString (1));
				bprint (2, " has won the match!¡\n");
				execute_changelevel ();
				return;
			}
		}
		if ((TeamFortress_TeamGetScore (_l_7158) != TeamFortress_TeamGetScore (_l_7159)))
		{
			local float fix1;
			local float fix2;
			local float totalf;
			local string totals;
			fix1 = ((TeamFortress_TeamGetScore (_l_7158)));
			fix2 = ((TeamFortress_TeamGetScore (_l_7159)));
			totalf = (fix1 - fix2);
			totals = ftos (totalf);
			if (totalf != 0)
			{
				bprint (2, "");
				bprint (2, TeamFortress_TeamGetColorString (_l_7158));
				bprint (2, " éó ìåáäéîç âù ");
				bprint (2, totals);
				bprint (2, "\n"); }
				else
				{
					bprint (2, "Tied.\n");
				}	
			}
		else
		{
			bprint (2, "Ôèå çáíå éó tied\n");
		}
		return;
	}
	while ((i <= number_of_teams))
	{
		if ((TeamFortress_TeamGetColor (i) > 0))
		{
			if (all)
			{
				bprint (2, "Team ");
			}
			else
			{
				sprint (self, 2, "Team ");
			}
			st = ftos (i);
			if (all)
			{
				bprint (2, st);
			}
			else
			{
				sprint (self, 2, st);
			}
			if (all)
			{
				bprint (2, " (");
			}
			else
			{
				sprint (self, 2, " (");
			}
			st = TeamFortress_TeamGetColorString (i);
			if (all)
			{
				bprint (2, st);
			}
			else
			{
				sprint (self, 2, st);
			}
			if (all)
			{
				bprint (2, ") : ");
			}
			else
			{
				sprint (self, 2, ") : ");
			}
			j = TeamFortress_TeamGetScore (i);
			st = ftos (j);
			if (all)
			{
				bprint (2, st);
			}
			else
			{
				sprint (self, 2, st);
			}
			if (all)
			{
				bprint (2, "\n");
			}
			else
			{
				sprint (self, 2, "\n");
			}
		}
		i = i + 1;
	}
};
string(float tno) TeamFortress_TeamGetColorString = 
{
	local float col;
	col = TeamFortress_TeamGetColor(tno);
	if (col == TF_FLARE_OFF)
	{
		return "White";
	}
	if (col == 2)
	{
		return "Brown";
	}
	if (col == 3)
	{
#ifdef id4
		return "USA";
#else
#ifdef halloween
		return "Ghouls";
#else
		return "Blue";
#endif
#endif
	}
	if (col == 4)
	{
		return "Green";
	}
	if (col == 5)
	{
#ifdef id4
		return "UK";
#else
#ifdef halloween
		return "Goblins";
#else
		return "Red";
#endif
#endif
	}
	if (col == 6)
	{
		return "Tan";
	}
	if (col == 7)
	{
		return "Pink";
	}
	if (col == 8)
	{
		return "Orange";
	}
	if (col == 9)
	{
		return "Purple";
	}
	if (col == 10)
	{
		return "DarkPurple";
	}
	if (col == 11)
	{
		return "Grey";
	}
	if (col == 12)
	{
		return "DarkGreen";
	}
	if (col == 13)
	{
		return "Yellow";
	}
#ifdef id4
	return "USA";
#else
#ifdef halloween
	return "Ghouls";
#else
	return "DarkBlue";
#endif
#endif
};
void(entity Player) TeamFortress_TeamShowMemberClasses = 
{
	local entity e;
	local float found;
	found = 0;
	e = find(world, classname, "player");
	while (e)
	{
		if (e.team_no == Player.team_no || e.team_no == 0 && e != Player)
		{
			if (e.model != string_null)
			{
				if (!found)
				{
					found = TF_FLARE_OFF;
					sprint(self, 2, "The other members of your team are:\n");
				}
				sprint(Player, 2, e.netname);
				sprint(Player, 2, " : ");
				TeamFortress_PrintClassName(Player, e.playerclass, e.tfstate & 8, 0);
			}
		}
		e = find(e, classname, "player");
	}
	if (!found)
	{
		sprint(Player, 2, "There are no other players on your team.\n");
	}
};
void() CalculateTeamEqualiser = 
{
	local float t1;
	local float t2;
	local float t3;
	local float t4;
	local float t_ave;
	local float calc;
	team1advantage = TF_FLARE_OFF;
	team2advantage = TF_FLARE_OFF;
	team3advantage = TF_FLARE_OFF;
	team4advantage = TF_FLARE_OFF;
	if (number_of_teams < 2)
	{
		self.nextthink = time + 60;
		return;
	}
	if (teamplay & 32)
	{
		t1 = TeamFortress_TeamGetNoPlayers(TF_FLARE_OFF);
		t2 = TeamFortress_TeamGetNoPlayers(2);
		t3 = TeamFortress_TeamGetNoPlayers(3);
		t4 = TeamFortress_TeamGetNoPlayers(4);
		if (t1 + t2 + t3 + t4 < TF_FLARE_OFF)
		{
			self.nextthink = time + 30;
			return;
		}
		t_ave = (t1 + t2 + t3 + t4) / number_of_teams;
		if (t1 > 0)
		{
			calc = t_ave / t1 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team1advantage = calc;
		}
		if (t2 > 0 && number_of_teams >= 2)
		{
			calc = t_ave / t2 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team2advantage = calc;
		}
		if (t3 > 0 && number_of_teams >= 3)
		{
			calc = t_ave / t3 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team3advantage = calc;
		}
		if (t4 > 0 && number_of_teams >= 4)
		{
			calc = t_ave / t4 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team4advantage = calc;
		}
	}
	if (teamplay & 64)
	{
		t1 = team1score + 60;
		if (number_of_teams >= 2)
		{
			t2 = team2score + 60;
		}
		else
		{
			t2 = 0;
		}
		if (number_of_teams >= 3)
		{
			t3 = team3score + 60;
		}
		else
		{
			t3 = 0;
		}
		if (number_of_teams >= 4)
		{
			t4 = team4score + 60;
		}
		else
		{
			t4 = 0;
		}
		t_ave = (t2 + t3 + t4) / (number_of_teams - TF_FLARE_OFF);
		calc = t_ave / t1 - TF_FLARE_OFF;
		if (calc != 0)
		{
			calc = calc / 3 + TF_FLARE_OFF;
		}
		else
		{
			calc = calc + TF_FLARE_OFF;
		}
		team1advantage = calc * team1advantage;
		if (number_of_teams >= 2)
		{
			t_ave = (t1 + t3 + t4) / (number_of_teams - TF_FLARE_OFF);
			calc = t_ave / t2 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team2advantage = calc * team2advantage;
		}
		if (number_of_teams >= 3)
		{
			t_ave = (t2 + t1 + t4) / (number_of_teams - TF_FLARE_OFF);
			calc = t_ave / t3 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team3advantage = calc * team3advantage;
		}
		if (number_of_teams >= 4)
		{
			t_ave = (t2 + t3 + t1) / (number_of_teams - TF_FLARE_OFF);
			calc = t_ave / t4 - TF_FLARE_OFF;
			if (calc != 0)
			{
				calc = calc / 3 + TF_FLARE_OFF;
			}
			else
			{
				calc = calc + TF_FLARE_OFF;
			}
			team4advantage = calc * team4advantage;
		}
	}
	self.nextthink = time + 10;
};
void() SetupTeamEqualiser = 
{
	local entity TE;
	team1advantage = TF_FLARE_OFF;
	team2advantage = TF_FLARE_OFF;
	team3advantage = TF_FLARE_OFF;
	team4advantage = TF_FLARE_OFF;
	if (!(teamplay & (32 | 64)))
	{
		return;
	}
	TE = spawn();
	TE.classname = "Team Equaliser";
	TE.think = CalculateTeamEqualiser;
	TE.nextthink = time + 30;
};
float(entity targ, entity attacker, float damage) TeamEqualiseDamage = 
{
	local float adv;
	local float newdam;
	if (targ.classname != "player" || attacker.classname != "player")
	{
		return damage;
	}
	if (targ.team_no == 0 || attacker.team_no == 0 || attacker.team_no == targ.team_no)
	{
		return damage;
	}
	if (attacker.team_no == TF_FLARE_OFF)
	{
		adv = team1advantage;
	}
	else
	{
		if (attacker.team_no == 2)
		{
			adv = team2advantage;
		}
		else
		{
			if (attacker.team_no == 3)
			{
				adv = team3advantage;
			}
			else
			{
				if (attacker.team_no == 4)
				{
					adv = team4advantage;
				}
			}
		}
	}
	if (adv == 0)
	{
		dprint("There is a team with an advantage of 0.\n");
		adv = 0.1;
	}
	newdam = damage * adv;
	if (targ.team_no == TF_FLARE_OFF)
	{
		adv = team1advantage;
	}
	else
	{
		if (targ.team_no == 2)
		{
			adv = team2advantage;
		}
		else
		{
			if (targ.team_no == 3)
			{
				adv = team3advantage;
			}
			else
			{
				if (targ.team_no == 4)
				{
					adv = team4advantage;
				}
			}
		}
	}
	if (adv == 0)
	{
		dprint("There is a team with an advantage of 0\n");
		adv = 0.1;
	}
	newdam = newdam * (TF_FLARE_OFF / adv);
	return damage; //This can get screwy with one player gaming this against a large team like monsters. So just send back damage -arg
};
void() TeamFortress_StatusQuery = 
{
	local float ft;
	local string st;
	sprint(self, 2, "players per team: ");
	ft = TeamFortress_TeamGetNoPlayers(TF_FLARE_OFF);
	st = ftos(ft);
	sprint(self, 2, st);
	sprint(self, 2, "  ");
	ft = TeamFortress_TeamGetNoPlayers(2);
	st = ftos(ft);
	sprint(self, 2, st);
	sprint(self, 2, "  ");
	ft = TeamFortress_TeamGetNoPlayers(3);
	st = ftos(ft);
	sprint(self, 2, st);
	sprint(self, 2, "  ");
	ft = TeamFortress_TeamGetNoPlayers(4);
	st = ftos(ft);
	sprint(self, 2, st);
	sprint(self, 2, "\n");
	sprint(self, 2, "    equalisation: ");
	st = ftos(team1advantage);
	sprint(self, 2, st);
	sprint(self, 2, "  ");
	st = ftos(team2advantage);
	sprint(self, 2, st);
	sprint(self, 2, "  ");
	st = ftos(team3advantage);
	sprint(self, 2, st);
	sprint(self, 2, "  ");
	st = ftos(team4advantage);
	sprint(self, 2, st);
	sprint(self, 2, "\n");
	st = ftos(teamplay);
	sprint(self, 2, "Teamplay is ");
	sprint(self, 2, st);
	sprint(self, 2, "\n");
};
float(float tno) TeamFortress_TeamGetIllegalClasses = 
{
	if (tno == TF_FLARE_OFF)
	{
		return illegalclasses1;
	}
	if (tno == 2)
	{
		return illegalclasses2;
	}
	if (tno == 3)
	{
		return illegalclasses3;
	}
	if (tno == 4)
	{
		return illegalclasses4;
	}
	return 0;
};
float(float tno) TeamFortress_TeamIsCivilian = 
{
	if (tno == TF_FLARE_OFF)
	{
		if (civilianteams & TF_FLARE_OFF)
		{
			return TF_FLARE_OFF;
		}
	}
	else
	{
		if (tno == 2)
		{
			if (civilianteams & 2)
			{
				return TF_FLARE_OFF;
			}
		}
		else
		{
			if (tno == 3)
			{
				if (civilianteams & 4)
				{
					return TF_FLARE_OFF;
				}
			}
			else
			{
				if (civilianteams & 8)
				{
					return TF_FLARE_OFF;
				}
			}
		}
	}
	return 0;
};
void(float tno, entity ignore, string st) teamsprint = 
{
	local entity te;
	if (tno == 0)
	{
		return;
	}
	te = find(world, classname, "player");
	while (te)
	{
		if (te.team_no == tno && te != ignore)
		{
			sprint(te, 2, st);
		}
		te = find(te, classname, "player");
	}
};
float() CheckExistence =
{
	UpdateAbbreviations (self);
	if ((self.ex_skill_min && (skill <= self.ex_skill_min)))
	{
		return (0.000000);
	}
	else
	{
		if ((self.ex_skill_max && (skill >= self.ex_skill_max)))
		{
			return (0.000000);
		}
	}
	return (1.000000);
};
float(entity obj, entity builder) CheckArea = 
{
	local vector src;
	local vector end;
	local float pos;
	pos = pointcontents(obj.origin);
	if (pos == -2 || pos == -6)
	{
		return TF_FLARE_LIT;
	}
	src_x = obj.origin_x + obj.maxs_x + 16;
	src_y = obj.origin_y + obj.maxs_y + 16;
	src_z = obj.origin_z + obj.maxs_z + 16;
	pos = pointcontents(src);
	if (pos == -2 || pos == -6)
	{
		return TF_FLARE_LIT;
	}
	end_x = obj.origin_x + obj.mins_x - 16;
	end_y = obj.origin_y + obj.mins_y - 16;
	end_z = obj.origin_z + obj.mins_z - 16;
	traceline(src, end, TF_FLARE_OFF, obj);
	if (trace_fraction != TF_FLARE_OFF)
	{
		return TF_FLARE_LIT;
	}
	pos = pointcontents(end);
	if (pos == -2 || pos == -6)
	{
		return TF_FLARE_LIT;
	}
	src_x = obj.origin_x + obj.mins_x - 16;
	src_y = obj.origin_y + obj.maxs_y + 16;
	src_z = obj.origin_z + obj.maxs_z + 16;
	pos = pointcontents(src);
	if (pos == -2 || pos == -6)
	{
		return TF_FLARE_LIT;
	}
	end_x = obj.origin_x + obj.maxs_x + 16;
	end_y = obj.origin_y + obj.mins_y - 16;
	end_z = obj.origin_z + obj.mins_z - 16;
	traceline(src, end, TF_FLARE_OFF, obj);
	if (trace_fraction != TF_FLARE_OFF)
	{
		return TF_FLARE_LIT;
	}
	pos = pointcontents(end);
	if (pos == -2 || pos == -6)
	{
		return TF_FLARE_LIT;
	}
	traceline(builder.origin, obj.origin, TF_FLARE_OFF, builder);
	if (trace_fraction != TF_FLARE_OFF)
	{
		return TF_FLARE_LIT;
	}
	return TF_FLARE_OFF;
};
float (float aNum) roughRoot =
{
	if ((aNum >= TF_FLARE_OFF))
	{
		return (TF_FLARE_OFF);
	}
	else
	{
		if ((aNum >= 0.95))
		{
			return (0.98);
		}
		else
		{
			if ((aNum >= 0.83))
			{
				return (0.91);
			}
			else
			{
				if ((aNum >= 0.63))
				{
					return (0.79);
				}
				else
				{
					if ((aNum >= 0.35))
					{
						return (0.5);
					}
					else
					{
						if ((aNum >= TF_FLARE_LIT))
						{
							return (TF_FLARE_LIT);
						}
					}
				}
			}
		}
	}
	return 0;
};
void() TeamFortress_ChangeClass = 
{
	local entity spot;
	local entity te;
	local float tc;
	local string st;
	local float oldbeartraps;	//pk items the player currently has come to merchant with for changeover. -arg
	local float oldautosentries;
	local float oldcans;
	local float oldgravwells;
	local float oldgrentype1; 	//players type 1 and 2 grenades he came to merchant with. -arg
	local float oldgrentype2;
	local float oldhealth, oldarmor, oldcells, oldrockets, oldshells, oldnails;
	local vector oldpos;
	local float oldinvincible_finished;
	local entity merchanty;
	if (self.#lms_lives < 0)
	{
		sprint( self, 2, "No more lives! Wait till the next round or map change.\n");
		return;
	}
	if (survival_mode)
		if (self.team_no == 0)		// survival mode hack allows players to join any team :\
			return;
	if (self.monster_type > 0)
	{}
	else
	if (self.playerclass != 0)
	{
		if (TeamFortress_TeamIsCivilian(self.team_no))
		{
			sprint(self, 2, "You cannot change class.\n");
			return;
		}
		if (!IsLegalClass(self.impulse - 100))
		{
			sprint(self, 2, "Your team cannot play that class.\n");
			TeamFortress_DisplayLegalClasses();
			return;
		}
		tc = IsRestrictedClass(self.impulse - 100); 
		if (tc != 0)
		{
			if (tc > 0)
			{
				sprint(self, 2, "That class is restricted to ");
				st = ftos(tc);
				sprint(self, 2, st);
				sprint(self, 2, " per team.\n");
			}
			else
			{
				sprint(self, 2, "That class is disabled.\n");
			}
			return;
		}
		if (spy_off == 1 && self.impulse - 100 == 8)
		{
			sprint(self, 2, "The spy class has been disabled on the server by the administrator.\n");
			return;
		}
		self.nextpc = self.impulse - 100;
		if (self.health > 0 && self.classname == "player")
		{
			merchanty = findradius (self.origin, 140);
			while (merchanty)
			{
				if (merchanty.classname == "merchant")
				{
					sprint(self,2, "Merchant: There ya go, buddy! This is the way!\n");
					oldpos = self.origin;
					oldinvincible_finished = self.invincible_finished;
					oldhealth = self.health;
					oldarmor = self.armorvalue;
					oldshells = self.ammo_shells;
					oldcells = self.ammo_cells;
					oldrockets = self.ammo_rockets;
					oldnails = self.ammo_nails;
					oldcans = self.pk_canpabammo;
					oldbeartraps = self.pk_beartrapammo;
					oldautosentries = self.pk_turretammo;
					oldgravwells = self.pk_gravitywellammo;
					oldgrentype1 = self.no_grenades_1;
					oldgrentype2 = self.no_grenades_2;
					self.immune_to_check = time + 10;
					PutClientInServer();
					self.invincible_finished = oldinvincible_finished;
					self.health = oldhealth;
					self.armorvalue = oldarmor;
					self.origin = oldpos;
					self.ammo_shells = oldshells;
					self.ammo_nails = oldnails;
					self.ammo_rockets = oldrockets;
					self.ammo_cells = oldcells;
					self.pk_canpabammo = oldcans;
					self.pk_turretammo = oldautosentries;
					self.pk_beartrapammo = oldbeartraps;
					self.pk_gravitywellammo = oldgravwells;
					self.no_grenades_1 = oldgrentype1;
					self.no_grenades_2 = oldgrentype2;
					if (self.health > self.max_health)
						self.health = self.max_health;
					if (self.armorvalue > self.maxarmor)
						self.armorvalue = self.maxarmor;
					return;
				}
				merchanty = merchanty.chain;
			}
		}
		sprint(self, 2, "After dying, you will return as a ");
		TeamFortress_PrintClassName(self, self.nextpc, self.tfstate & 8, 0);
		sprint(self, 2, ".\n");
		self.immune_to_check = time + 10;
		return;
	}
	stuffcmd (self, "_snd_mixahead .1\n");
	TeamFortress_Alias("jetjump", 155, 0);
	TeamFortress_Alias("ir", 50, 0);
	TeamFortress_Alias("holo", 200, 0);
	TeamFortress_Alias("airstrike", 55, 0);
	TeamFortress_Alias("drop1", 190, 0);
	TeamFortress_Alias("drop2", 201, 0);
	TeamFortress_Alias("drop3", 55, 0);
	TeamFortress_Alias("drop4", 59, 0);
	TeamFortress_Alias("lay", 158, 0);
	TeamFortress_Alias("mega", 57, 0);
	TeamFortress_Alias("taunt", 53, 0);
	TeamFortress_Alias("airscout", 154, 0);
	TeamFortress_Alias("dot", 61, 0);
	TeamFortress_Alias("yell", 56, 0);
	TeamFortress_Alias("votemenu", 251, 0);
	TeamFortress_Alias("voteyes", 245, 0);
	stuffcmd (self, "alias voteyes cmd voteyes\n");
	TeamFortress_Alias("uptime", 133, 0);
	TeamFortress_Alias("heal", 189, 0);
	TeamFortress_Alias("dropflag", 203, 0);
	TeamFortress_Alias("dropitems", 204, 0);
	TeamFortress_Alias("detdispenser", 188, 0);
	TeamFortress_Alias("detsentry", 205, 0);
	TeamFortress_Alias("timeleft", 120, 0);
	if (teamplay && self.team_no == 0)
	{
		if (toggleflags & 64)
		{
			if (TeamFortress_TeamPutPlayerInTeam() == 0)
			{
				return;
			}
		}
		else
		{
			sprint(self, 2, "You must join a team first. \n");
			sprint(self, 2, "use imin1, imin2, imin3, or imin4\n");
			return;
		}
	}
	if (self.lives == 0)
	{
		sprint(self, 2, "You have no lives left.\n");
		return;
	}
	if (!IsLegalClass(self.impulse - 100) && self.impulse != 1)
	{
		sprint(self, 2, "You cannot play that player class on this map. \n");
		TeamFortress_DisplayLegalClasses();
		return;
	}
	tc = IsRestrictedClass(self.impulse - 100); 
	if (tc != 0)
	{
		if (tc > 0)
		{
			sprint(self, 2, "That class is restricted to ");
			st = ftos(tc);
			sprint(self, 2, st);
			sprint(self, 2, " per team.\n");
		}
		else
		{
			sprint(self, 2, "That class is disabled.\n");
		}
		return;
	}
	if (spy_off == 1 && self.impulse - 100 == 8)
	{
		sprint(self, 2, "The spy class has been disabled on the server by the administrator.\n");
		return;
	}
	if (self.impulse != 1)
	{
		self.playerclass = self.impulse - 100;
	}
	else
	{
		self.playerclass = 11;
	}
	self.nextpc = 0;
	self.takedamage = 2;
	self.movetype = 3;
	self.flags = 8 | 512;
	self.waterlevel = 0;
	self.air_finished = time + 12;
	self.solid = 3;
	self.pausetime = 0;
	spot = SelectSpawnPoint();
	self.origin = spot.origin + '0 0 1';
	self.angles = spot.angles;
	self.fixangle = 1;
	setmodel(self, string_null);
	modelindex_null = self.modelindex;
	setmodel(self, "progs/eyes.mdl");
	modelindex_eyes = self.modelindex;
	if (self.monster_type > 0)
	{
		self.monster_type = self.playerclass;
		Monsterteam_setmodel(self, self.monster_type);
		if (spot.is_monster == 1)
		{
			Killed(spot, world);
		}
	}
	else
#ifdef APRIL_FOOLS
	setmodel(self, "progs/a1player.mdl");
#else
#ifdef PL_FEM
	setmodel (self, GetPlayerModel(self));
#else
	setmodel(self, "progs/player.mdl");
#endif
	
#endif
	if (self.monster_type == 0)
#ifdef PL_FEM
	SetPlayerModelindex(self);
#else
	modelindex_player = self.modelindex;
#endif
	setsize(self, '-16 -16 -24', '16 16 32');
	self.view_ofs = '0 0 22';
	player_stand1();
	if (deathmatch || coop)
	{
		makevectors(self.angles);
		spawn_tfog(self.origin + v_forward * 20);
	}
	if (self.playerclass == 10)
	{
		sprint(self, 2, "Random Playerclass.\n");
		self.tfstate = self.tfstate | 8;
		tc = 1 + floor(random() * (10 - 1));
		while (IsRestrictedClass(tc) != 0)
		{
			tc = 1 + floor(random() * (10 - 1));
		}
		self.playerclass = tc;
	}
	if (spot.classname == "info_player_teamspawn")
	{
		if (spot.items != 0)
		{
			te = Finditem(spot.items);
			if (te)
			{
				tfgoalitem_GiveToPlayer(te, self, self);
			}
			if (!(spot.goal_activation & 1))
			{
				spot.items = 0;
			}
		}
		if (spot.message)
		{
			CenterPrint(self, spot.message);
			if (!(spot.goal_activation & 2))
			{
				spot.message = string_null;
			}
		}
		if (spot.goal_effects == 1)
		{
			spot.classname = "deadpoint";
			spot.team_str_home = string_null;
			spot.nextthink = time + 1;
			spot.think = SUB_Remove;
		}
	}
	spot = find(world, classname, "player");
	while (spot)
	{
		if (spot.team_no == self.team_no && spot != self)
		{
			sprint(spot, 2, self.netname);
			sprint(spot, 2, " is playing as a ");
			TeamFortress_PrintClassName(spot, self.playerclass, self.tfstate & 8, 0);
			sprint(self, 2, ".\n");
		}
		spot = find(spot, classname, "player");
	}
	TeamFortress_PrintClassName(self, self.playerclass, self.tfstate & 8, 0);
	TeamFortress_SetEquipment();
	TeamFortress_SetHealth();
	TeamFortress_SetSpeed(self);
	TeamFortress_SetSkin(self);
	stuffcmd (self, "cl_sidespeed 500\ncl_backspeed 500\ncl_forwardspeed 500\n");
};
void() execute_changelevel = 
{
	local entity pos;
	dprint("execute_changelevel()\n");
	intermission_running = TF_FLARE_OFF;
	intermission_exittime = time + 5;
	pos = FindIntermission();
	WriteByte(2, 30);
	WriteCoord(2, pos.origin_x);
	WriteCoord(2, pos.origin_y);
	WriteCoord(2, pos.origin_z);
	WriteAngle(2, pos.mangle_x);
	WriteAngle(2, pos.mangle_y);
	WriteAngle(2, pos.mangle_z);
	if ((quadscore == -666.000000))
	{
		localcmd ("serverinfo quadscore ");
		localcmd (ftos (team1score));
		localcmd ("\n");
	}
	other = find(world, classname, "player");
	while (other != world)
	{
		if (other.stats_on)
		{
// We are always in mtf_coop mode defined on uber -arg
//#ifndef mtf_coop
//			stuffcmd (other, "set stats_execed -1; exec progs/stats.cfg\n");
//#endif
		}
		other.takedamage = 0;
		other.solid = 0;
		other.movetype = 0;
		other.modelindex = 0;
		other = find(other, classname, "player");
	}
};
void(entity Viewer, float pc, float rpc, float xavior_Var) TeamFortress_PrintClassName = 
{
	local string st;
	st = TeamFortress_GetClassName(pc);
	sprint(Viewer, 2, st);
	if (rpc != 0)
	{
		sprint(Viewer, 2, " (Random)");
	}
	if (xavior_Var == 2)
	{
		sprint(Viewer, 2, " \n");
	}
	else
	{
		sprint(Viewer, 2, " \n");
	}
};
void(entity Goal) UpdateAbbreviations = 
{
	if (Goal.has_disconnected == TF_FLARE_LIT)
	{
		if (Goal.g_a != TF_FLARE_LIT && Goal.goal_activation == TF_FLARE_LIT)
		{
			Goal.goal_activation = Goal.g_a;
		}
		if (Goal.g_e != TF_FLARE_LIT && Goal.goal_effects == TF_FLARE_LIT)
		{
			Goal.goal_effects = Goal.g_e;
		}
		if (Goal.h_i_g != TF_FLARE_LIT && Goal.has_item_from_group == TF_FLARE_LIT)
		{
			Goal.has_item_from_group = Goal.h_i_g;
		}
	if ((Goal.hn_i_g != 0) && (Goal.hasnt_item_from_group == 0))
	{
	    Goal.hasnt_item_from_group = Goal.hn_i_g;
	}
		if (Goal.r_i_g != TF_FLARE_LIT && Goal.remove_item_group == TF_FLARE_LIT)
		{
			Goal.remove_item_group = Goal.r_i_g;
		}
		if (Goal.a_s != TF_FLARE_LIT && Goal.ammo_shells == TF_FLARE_LIT)
		{
			Goal.ammo_shells = Goal.a_s;
		}
		if (Goal.a_n != TF_FLARE_LIT && Goal.ammo_nails == TF_FLARE_LIT)
		{
			Goal.ammo_nails = Goal.a_n;
		}
		if (Goal.a_r != TF_FLARE_LIT && Goal.ammo_rockets == TF_FLARE_LIT)
		{
			Goal.ammo_rockets = Goal.a_r;
		}
		if (Goal.a_c != TF_FLARE_LIT && Goal.ammo_cells == TF_FLARE_LIT)
		{
			Goal.ammo_cells = Goal.a_c;
		}
		if (Goal.rv_s_h != TF_FLARE_LIT && Goal.remove_spawngroup == TF_FLARE_LIT)
		{
			Goal.remove_spawngroup = Goal.rv_s_h;
		}
		if (Goal.rs_s_h != TF_FLARE_LIT && Goal.restore_spawngroup == TF_FLARE_LIT)
		{
			Goal.restore_spawngroup = Goal.rs_s_h;
		}
		if (Goal.rv_gr != TF_FLARE_LIT && Goal.remove_group_no == TF_FLARE_LIT)
		{
			Goal.remove_group_no = Goal.rv_gr;
		}
		if (Goal.rs_gr != TF_FLARE_LIT && Goal.restore_group_no == TF_FLARE_LIT)
		{
			Goal.restore_group_no = Goal.rs_gr;
		}
		if (Goal.rs_g != TF_FLARE_LIT && Goal.restore_goal_no == TF_FLARE_LIT)
		{
			Goal.restore_goal_no = Goal.rs_g;
		}
		if (Goal.rv_g != TF_FLARE_LIT && Goal.remove_goal_no == TF_FLARE_LIT)
		{
			Goal.remove_goal_no = Goal.rv_g;
		}
		if (Goal.t_s_h != string_null)
		{
			Goal.team_str_home = Goal.t_s_h;
		}
		if (Goal.t_s_m != string_null)
		{
			Goal.team_str_moved = Goal.t_s_m;
		}
		if (Goal.t_s_c != string_null)
		{
			Goal.team_str_carried = Goal.t_s_c;
		}
		if (Goal.n_s_h != string_null)
		{
			Goal.non_team_str_home = Goal.n_s_h;
		}
		if (Goal.n_s_m != string_null)
		{
			Goal.non_team_str_moved = Goal.n_s_m;
		}
		if (Goal.n_s_c != string_null)
		{
			Goal.non_team_str_carried = Goal.n_s_c;
		}
		if (Goal.b_b != string_null)
		{
			Goal.broadcast = Goal.b_b;
		}
		if (Goal.b_t != string_null)
		{
			Goal.team_broadcast = Goal.b_t;
		}
		if (Goal.b_n != string_null)
		{
			Goal.non_team_broadcast = Goal.b_n;
		}
		if (Goal.b_o != string_null)
		{
			Goal.owners_team_broadcast = Goal.b_o;
		}
		if (Goal.n_b != string_null)
		{
			Goal.netname_broadcast = Goal.n_b;
		}
		if (Goal.n_t != string_null)
		{
			Goal.netname_team_broadcast = Goal.n_t;
		}
		if (Goal.n_n != string_null)
		{
			Goal.netname_non_team_broadcast = Goal.n_n;
		}
		if (Goal.n_o != string_null)
		{
			Goal.netname_owners_team_broadcast = Goal.n_o;
		}
		if (Goal.d_t != string_null)
		{
			Goal.team_drop = Goal.d_t;
		}
		if (Goal.d_n != string_null)
		{
			Goal.non_team_drop = Goal.d_n;
		}
		if (Goal.d_n_t != string_null)
		{
			Goal.netname_team_drop = Goal.d_n_t;
		}
		if (Goal.d_n_n != string_null)
		{
			Goal.netname_non_team_drop = Goal.d_n_n;
		}
		Goal.has_disconnected = TF_FLARE_OFF;
	}
};
float(float pc) IsLegalClass = 
{
	local float bit;
	if (spy_off == 1 && pc == 8)
	{
		return 0;
	}
	if (pc == 1)
	{
		bit = 1;
	}
	else
	{
		if (pc == 2)
		{
			bit = 2;
		}
		else
		{
			if (pc == 3)
			{
				bit = 4;
			}
			else
			{
				if (pc == 4)
				{
					bit = 8;
				}
				else
				{
					if (pc == 5)
					{
						bit = 16;
					}
					else
					{
						if (pc == 6)
						{
							bit = 32;
						}
						else
						{
							if (pc == 7)
							{
								bit = 64;
							}
							else
							{
								if (pc == 8)
								{
									bit = 256;
								}
								else
								{
									if (pc == 9)
									{
										bit = 512;
									}
									else
									{
										if (pc == 10)
										{
											bit = 128;
										}
#ifdef NEW_CLASS1
										else
										{
											if (pc == #CLASS_SPECOP)
											{
												bit = 256;
											}
										}
#endif
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (illegalclasses & bit || (TeamFortress_TeamGetIllegalClasses(self.team_no) & bit))
	{
		return 0;
	}
	return 1;
};
entity() FindIntermission = 
{
	local entity spot;
	local float cyc;
	spot = find(world, classname, "info_intermission");
	if (spot)
	{
		cyc = random() * TF_FLARE_OFF;
		return spot;
	}
	spot = find(world, classname, "info_player_start");
	if (spot)
	{
		return spot;
	}
	spot = find(world, classname, "info_player_deathmatch");
	if (spot)
	{
		cyc = random() * 6;
		while (cyc > TF_FLARE_OFF)
		{
			spot = find(spot, classname, "info_player_deathmatch");
			if (!spot)
			{
				spot = find(spot, classname, "info_player_deathmatch");
			}
			cyc = cyc - TF_FLARE_OFF;
		}
		return spot;
	}
	objerror("FindIntermission: no spot");
	return self;	// dirty fix to get rid of compiler bitching
};
string(float pc) TeamFortress_GetClassName = 
{
	if (pc == 1)
	{
		return "Scout";
	}
	else
	{
		if (pc == 2)
		{
			return "Sniper";
		}
		else
		{
			if (pc == 3)
			{
				return "Soldier";
			}
			else
			{
				if (pc == 4)
				{
					return "Demolitions Man";
				}
				else
				{
					if (pc == 5)
					{
						return "Combat Medic";
					}
					else
					{
						if (pc == 6)
						{
							return "Heavy Weapons Guy";
						}
						else
						{
							if (pc == 7)
							{
								return "Pyro";
							}
							else
							{
								if (pc == 8)
								{
									return "Spy";
								}
								else
								{
									if (pc == 9)
									{
										return "Engineer";
									}
									else
									{
										if (pc == 11)
										{
											return "Civilian";
										}
										else
										{
											if (pc == 0)
											{
												return "Observer";
											}
											else
											{
												if (pc == 10)
												{
													return "Random Playerclass";
												}
#ifdef NEW_CLASS1
												else
												{
													if (pc == #CLASS_SPECOP)
													{
														return "Special Op";
													}
												}
#endif
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return ("Invalid Class");
};
void() TeamFortress_DisplayLegalClasses = 
{
	local float gotone;
	local float ill;
	sprint(self, 2, "Legal classes for your team are:\n");
	gotone = 0;
	ill = TeamFortress_TeamGetIllegalClasses(self.team_no);
	if (!(illegalclasses & 1) && !(ill & 1))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Scout");
	}
	if (!(illegalclasses & 2) && !(ill & 2))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Sniper");
	}
	if (!(illegalclasses & 4) && !(ill & 4))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Soldier");
	}
	if (!(illegalclasses & 8) && !(ill & 8))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Demolitions Man");
	}
	if (!(illegalclasses & 16) && !(ill & 16))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Combat Medic");
	}
	if (!(illegalclasses & 32) && !(ill & 32))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Heavy Weapons Guy");
	}
	if (!(illegalclasses & 64) && !(ill & 64))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Pyro");
	}
	if (!(illegalclasses & 256) && !(ill & 256))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Spy");
	}
	if (!(illegalclasses & 512) && !(ill & 512))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "Engineer");
	}
	if (!(illegalclasses & 128) && !(ill & 128))
	{
		if (gotone)
		{
			sprint(self, 2, ", ");
		}
		gotone = 1;
		sprint(self, 2, "RandomPC");
	}
	sprint(self, 2, ".\n");
};
float(float pc) IsRestrictedClass = 
{
	local float NumOnTeam;
	local float NumAllowed;
	local entity te;
	if ( (pc < 1) || (pc > 9) || (self.playerclass == pc) )
	{
		return 0;
	}
	NumAllowed = 0;
	ReCheckRestrictions ();
	if (pc < 6)
	{
		if (pc < 3)
		{
			if (pc == 1)
				NumAllowed = cr_scout;
			else
				NumAllowed = cr_sniper;
		}
		else
		{
			if (pc == 3)
				NumAllowed = cr_soldier;
			else
			{
				if (pc == 4)
					NumAllowed = cr_demoman;
				else
					NumAllowed = cr_medic;
			}
		}
	}
	else
	{
		if (pc < 8)
		{
			if (pc == 6)
				NumAllowed = cr_hwguy;
			else
				NumAllowed = cr_pyro;
		}
		else
		{
			if (pc == 8)
				NumAllowed = cr_spy;
			else
				NumAllowed = cr_engineer;
		}
	}
	if (NumAllowed == 0)
		return 0;
	if (NumAllowed < 0)
		return -1;
	NumOnTeam = 0;
	te = find (world, classname, "player");
	while (te)
	{
		if (te.playerclass == pc)
		{
			if (te.team_no == self.team_no)
			{
				NumOnTeam = NumOnTeam + 1;
			}
		}
		te = find (te, classname, "player");
	}

	if (NumOnTeam < NumAllowed)
		return 0;
	else
		return NumAllowed;
};
entity() SelectSpawnPoint = 
{
	local entity spot;
	local entity at_spot;
	local float spot_found;
	local float attempts;
	if (self.team_no != 0)
	{
		spot = FindTeamSpawnPoint(self.team_no);
		if (spot != world)
		{
			return spot;
		}
	}
	if (coop)
	{
		lastspawn = find(lastspawn, classname, "info_player_coop");
		if (lastspawn == world)
		{
			lastspawn = find(world, classname, "info_player_coop");
		}
		if (lastspawn != world)
		{
			return lastspawn;
		}
	}
	else
	{
		if (deathmatch)
		{
			spot = find(lastspawn, classname, "info_player_deathmatch");
			if (spot == world)
			{
				spot = find(world, classname, "info_player_deathmatch");
			}
			attempts = 0;
			while (spot != world && attempts < 100)
			{
				attempts = attempts + TF_FLARE_OFF;
				at_spot = findradius(spot.origin, 4440);
				spot_found = TF_FLARE_OFF;
				while (at_spot)
				{
					if (at_spot.classname == "player" && at_spot.deadflag == 0)
					{
						spot_found = 0;
					}
					at_spot = at_spot.chain;
				}
				if (spot_found || attempts >= 10)
				{
					lastspawn = spot;
					return spot;
				}
				spot = find(spot, classname, "info_player_deathmatch");
				if (spot == world)
				{
					spot = find(world, classname, "info_player_deathmatch");
				}
			}
		}
	}
	if (serverflags)
	{
		spot = find(world, classname, "info_player_start2");
		if (spot)
		{
			return spot;
		}
	}
	spot = find(world, classname, "info_player_start");
	if (!spot)
	{
		error("PutClientInServer: no info_player_start on level\n");
	}
	return spot;
};
entity(entity start_point) FindNextIntermission = 
{
	local entity spot;
	if (deathmatch)
	{
		if (start_point.classname == "info_intermission" || start_point == world)
		{
			spot = find(start_point, classname, "info_intermission");
			if (spot)
			{
				return spot;
			}
			else
			{
				start_point = world;
			}
		}
		if (start_point.classname == "info_player_deathmatch" || start_point == world)
		{
			spot = find(start_point, classname, "info_player_deathmatch");
			if (spot)
			{
				return spot;
			}
		}
		spot = find(world, classname, "info_intermission");
		if (spot)
		{
			return spot;
		}
		spot = find(world, classname, "info_player_deathmatch");
		if (spot)
		{
			return spot;
		}
	}
	else
	{
		spot = find(world, classname, "info_player_start");
		if (spot)
		{
			return spot;
		}
	}
	return FindIntermission();
};
void () ReCheckRestrictions =
{
	if (infokey(world, "quickswitch") == "off" || infokey(world, "quickswitch") == "0")
	{
		return;
	}
	local string st;
	st = infokey (world, "cr_scout");
	cr_scout = stof (st);
	st = infokey (world, "cr_sniper");
	cr_sniper = stof (st);
	st = infokey (world, "cr_soldier");
	cr_soldier = stof (st);
	st = infokey (world, "cr_demoman");
	cr_demoman = stof (st);
	st = infokey (world, "cr_medic");
	cr_medic = stof (st);
	st = infokey (world, "cr_hwguy");
	cr_hwguy = stof (st);
	st = infokey (world, "cr_pyro");
	cr_pyro = stof (st);
	st = infokey (world, "cr_spy");
	cr_spy = stof (st);
	st = infokey (world, "cr_engineer");
	cr_engineer = stof (st);
	if ((((((((((cr_scout != 0.000000) && (cr_sniper != 0.000000)) && (cr_soldier != 0.000000)) && (cr_demoman != 0.000000)) && (cr_medic != 0.000000)) && (cr_hwguy != 0.000000)) && (cr_pyro != 0.000000)) && (cr_spy != 0.000000)) && (cr_engineer != 0.000000)))
	{
		cr_engineer = 0.000000;
	}
};
void (entity pl, float fr) TF_AddFrags =
{
	local entity e;
	if ((intermission_running != 0) || (intermission_exittime > time))
	return;
	pl.real_frags = pl.real_frags + fr;
	if (!pl.team_no)
	return;
	if (toggleflags & 2048)
	{
		if (pl.team_no == 1)
			team1score = team1score + fr;
		else
		if (pl.team_no == 2)
			team2score = team2score + fr;
		else
		if (pl.team_no == 3)
			team3score = team3score + fr;
		else
		if (pl.team_no == 4)
			team4score = team4score + fr;
	}
	if (pl.team_no == 1)
	team1frags = team1frags + fr;
	else
	if (pl.team_no == 2)
	team2frags = team2frags + fr;
	else
	if (pl.team_no == 3)
	team3frags = team3frags + fr;
	else
	if (pl.team_no == 4)
	team4frags = team4frags + fr;
	if (toggleflags & 2048)
	{
	e = find (world, classname, "player");
	while (e)
	{
		if (e.team_no == pl.team_no)
		e.frags = TeamFortress_TeamGetScore (e.team_no);
		e = find (e, classname, "player");
	}
	} else
	if (!(toggleflags & 128))
	pl.frags = pl.real_frags;
};

float(entity Retriever, float AmmoType) TeamFortress_GetMaxAmmo = 
{
	if (AmmoType == 256)
	{
		return Retriever.maxammo_shells;
	}
	else
	{
		if (AmmoType == 512)
		{
			return Retriever.maxammo_nails;
		}
		else
		{
			if (AmmoType == 2048)
			{
				return Retriever.maxammo_cells;
			}
			else
			{
				if (AmmoType == 1024)
				{
					return Retriever.maxammo_rockets;
				}
				else
				{
					if (AmmoType == 4)
					{
						return Retriever.maxammo_medikit;
					}
					else
					{
						if (AmmoType == 131072)
						{
							return Retriever.maxammo_detpack;
						}
					}
				}
			}
		}
	}
	dprint("Error in TeamFortress_GetMaxAmmo()\n");
	dprint("Invalid ammo type passed.\n");
	return 0;
};
float(entity Retriever, float WeaponType) TeamFortress_CanGetWeapon = 
{
	if (Retriever.items_allowed & WeaponType)
	{
		return 1;
	}
	return 0;
};
void (entity _p_1249, entity _p_1250) Killed =
{
	local entity _l_1251;
	_l_1251 = self;
	self = _p_1249;
	if (!self.th_die)
	{
		bprint(2, "ERROR IN DEATH FUNCTION!\n");
		bprint(2, "netname: ");
		bprint(2, self.netname);
		bprint(2, ", classname: ");
		bprint(2, self.classname);
		bprint(2, "\n");
		if (self.#is_minion == #FALSE)
		{
			killed_monsters = killed_monsters + 1.000000;
			WriteByte (2.000000, 27.000000);
			self.monster_string = "off";
		}
		return;
	}
	local float dmg_mult;
	dmg_mult = cvar("monster_takedamage");
	if (dmg_mult == 0)
		dmg_mult = 1;
	self.health = self.health / dmg_mult;
	if (self.health > 0)	// should not be happening but whatever..
		self.health = -1;
	if ((self.health < -99.000000))
	{
		self.health = -99.000000;
	}
	if (self.is_monster == 1)
	{
#ifdef debug
		total_killed = total_killed + 1;
		bprint(2,"TOTAL KILLED: ");
		bprint(2, ftos(total_killed));
		bprint(2, "\n");
#endif
		if (self.lives <= 0)
		{
		}
	}
	if (((self.movetype == 7.000000) || (self.movetype == 0.000000)))
	{
		if (self.is_monster != 1)
		{
		self.th_die ();
		self = _l_1251;
		return;
		}
	}
	self.enemy = _p_1250;
	if ((self.flags & 32.000000))
	{
		if (self.is_monster == 1)
		{
		}
		else
{
bprint(2,"IF YOU SEE THIS MESSAGE TELL DEVELOPER THAT SOMETHING IS REALLY BAD HERE KTHXBAI\n");
bprint(2, "entity 1: ");
bprint(2, _p_1249.classname);
bprint(2," ");
bprint(2, _p_1249.netname);
bprint(2, "\n");
bprint(2, "entity 2: ");
bprint(2, _p_1250.classname);
bprint(2," ");
bprint(2, _p_1250.netname);
bprint(2, "\n");
		killed_monsters = killed_monsters + 1.000000;
		WriteByte (2.000000, 27.000000);
		}
	}
	ClientObituary (self, _p_1250);
	self.takedamage = 0.000000;
	self.touch = SUB_Null;
	monster_death_use ();
	self.th_die ();
	if (self.classname == "player" && self.monster_type == 0)
		if (survival_mode)
			if (Survival_Fail() == #TRUE)
				{}
	if (self.is_monster == 1 || self.monster_string == "on")
	{
		self.effects = 0;	// move up?
		if (_p_1250.classname != "player")
			if (_p_1250.owner != world)
				MTF_Monster_DropItem (self, _p_1250.owner);
			else
				MTF_Monster_DropItem (self, _p_1250);
		else
			MTF_Monster_DropItem (self, _p_1250);
		if (survival_mode)
			if (random() < .59)
				TeamFortress_DropAmmo( ceil(random() * 6) );
		MTF_Monster_DropInventory ( self, _p_1250 );
		if (self.netname == "morpher")
		{
			killed_monsters = killed_monsters + 1.000000;
			WriteByte (2.000000, 27.000000);
		}
		else
		COOP_SetupRespawn (self.#npc_spawndelay, self.#npc_spawnfunc);
	}
	self = _l_1251;
};
void (float _p_10461) TeamFortress_DropAmmo =
{
	local float _l_10462;
	if (self.monster_string == "on")
		if (survival_mode)
		{
			self.ammo_shells = 100;
			self.ammo_cells = 100;
			self.ammo_nails = 100;
			self.ammo_rockets = 100;
			self.no_grenades_1 = 6;  //was 2 ffs -arg
			self.no_grenades_2 = 6;
		}
	if ((_p_10461 == 1.000000))
	{
		_l_10462 = 20.000000;
		if (self.monster_string == "on")
			_l_10462 = 100;
		if ((self.ammo_shells < _l_10462))
		{
			if ((self.playerclass == 9.000000))
			{
				if (((self.ammo_cells / 3.000000) > (_l_10462 - self.ammo_shells)))
				{
	if ((!(self.monster_string == "on")))
					sprint (self, 2.000000, "you make some shells.\n");
					self.ammo_cells = (self.ammo_cells - ((_l_10462 - self.ammo_shells) * 3.000000));
					self.ammo_shells = _l_10462;
				}
			}
			if ((self.ammo_shells < _l_10462))
			{
				return;
			}
		}
		self.ammo_shells = (self.ammo_shells - _l_10462);
	}
	else
	{
		if ((_p_10461 == 2.000000))
		{
			_l_10462 = 20.000000;
		if (self.monster_string == "on")
			_l_10462 = 100;
			if ((self.ammo_nails < _l_10462))
			{
				if ((self.playerclass == 9.000000))
				{
					if (((self.ammo_cells / 2.000000) > (_l_10462 - self.ammo_nails)))
					{
	if ((!(self.monster_string == "on")))
						sprint (self, 2.000000, "you make some nails.\n");
						self.ammo_cells = (self.ammo_cells - ((_l_10462 - self.ammo_nails) * 2.000000));
						self.ammo_nails = _l_10462;
					}
				}
				if ((self.ammo_nails < _l_10462))
				{
					return;
				}
			}
			self.ammo_nails = (self.ammo_nails - _l_10462);
		}
		else
		{
			if ((_p_10461 == 3.000000))
			{
				_l_10462 = 10.000000;
		if (self.monster_string == "on")
			_l_10462 = 100;
				if ((self.ammo_rockets < _l_10462))
				{
					if ((self.playerclass == 9.000000))
					{
						if (((self.ammo_cells / 5.000000) > (_l_10462 - self.ammo_rockets)))
						{
	if ((!(self.monster_string == "on")))
							sprint (self, 2.000000, "you make some rockets.\n");
							self.ammo_cells = (self.ammo_cells - ((_l_10462 - self.ammo_rockets) * 5.000000));
							self.ammo_rockets = _l_10462;
						}
					}
					if ((self.ammo_rockets < _l_10462))
					{
						return;
					}
				}
				self.ammo_rockets = (self.ammo_rockets - _l_10462);
			}
			else
			{
				if ((_p_10461 == 4.000000))
				{
					_l_10462 = 10.000000;
		if (self.monster_string == "on")
			_l_10462 = 100;
					if ((self.ammo_cells < _l_10462))
					{
						if ((self.playerclass == 9.000000))
						{
							if (((self.ammo_cells / 5.000000) > (_l_10462 - self.ammo_cells)))
							{
	if ((!(self.monster_string == "on")))
								sprint (self, 2.000000, "you make some cells.\n");
								self.ammo_cells = (self.ammo_cells - ((_l_10462 - self.ammo_cells) * 5.000000));
								self.ammo_cells = _l_10462;
							}
						}
						if ((self.ammo_cells < _l_10462))
						{
							return;
						}
					}
					self.ammo_cells = (self.ammo_cells - _l_10462);
				}
			}
		}
	}
	if ((_p_10461 == 5.000000))
	{
		if ((self.no_grenades_1 < 1.000000))
		{
			return;
		}
		self.no_grenades_1 = (self.no_grenades_1 - 1.000000);
	}
	if ((_p_10461 == 6.000000))
	{
		if ((self.no_grenades_2 < 1.000000))
		{
			return;
		}
		self.no_grenades_2 = (self.no_grenades_2 - 1.000000);
	}
	if ((!(self.monster_string == "on"))) 
	W_SetCurrentAmmo ();
	if ((self.team_no != 0.000000))
	{
		increment_team_ammoboxes (self.team_no);
		if ((num_team_ammoboxes (self.team_no) > (20.000000 / number_of_teams)))
		{
			RemoveOldAmmobox (self.team_no);
		}
	}
	else
	{
		num_world_ammoboxes = num_world_ammoboxes + 1.000000;
		if ((num_world_ammoboxes > 20.000000))
		{
			RemoveOldAmmobox (0.000000);
		}
	}
	newmis = spawn ();
	newmis.aflag = _l_10462;
	newmis.weapon = _p_10461;
	if ((newmis.weapon == 1.000000))
	{
		newmis.ammo_shells = _l_10462;
	}
	else
	{
		if ((newmis.weapon == 2.000000))
		{
			newmis.ammo_nails = _l_10462;
		}
		else
		{
			if ((newmis.weapon == 3.000000))
			{
				newmis.ammo_rockets = _l_10462;
			}
			else
			{
				if ((newmis.weapon == 4.000000))
				{
					newmis.ammo_cells = _l_10462;
				}
			}
		}
	}
	if ((newmis.weapon == 5.000000))
	{
		newmis.no_grenades_1 = 6.000000;
	}
	if ((newmis.weapon == 6.000000))
	{
		newmis.no_grenades_2 = 2.000000;  //was 1 -arg
	}
	newmis.enemy = self;
	newmis.health = time;
	newmis.movetype = 6.000000;
	newmis.solid = 1.000000;
	newmis.classname = "ammobox";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.monster_string == "on")
		makevectors (self.angles);
	if (self.v_angle_x)
	{
		newmis.velocity = ((v_forward * 400.000000) + (v_up * 200.000000));
	}
	else
	{
		newmis.velocity = aim (self, 10000.000000);
		newmis.velocity = (newmis.velocity * 400.000000);
		newmis.velocity_z = 200.000000;
	}
	newmis.avelocity = '0.000000 300.000000 0.000000';
	setsize (newmis, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
	setorigin (newmis, self.origin);
	if (self.monster_string == "on")
		newmis.nextthink = time + 8;
	else
	newmis.nextthink = (time + 30.000000);
	newmis.think = SUB_Remove;
	newmis.touch = TeamFortress_AmmoboxTouch;
	newmis.skin = (_p_10461 - 1.000000);

	sound (newmis, 3.000000, "knight/sword2.wav", 1.000000, 1.000000);
	if ((sr_dropgrens == 1.000000))
	{
		setmodel (newmis, "progs/ammobox2.mdl");
	}
	else
	{
		setmodel (newmis, "progs/ammobox.mdl");
	}
	if (newmis.weapon == 5 || newmis.weapon == 6)
		setmodel (newmis, #MODEL_HGREN2);
};
void() make_explosion = 
{
	newmis = spawn();
	setmodel(newmis, "progs/s_expl.spr");
	setorigin(newmis, self.origin);
	newmis.movetype = 8;
	newmis.solid = TF_FLARE_LIT;
	sound(newmis, TF_FLARE_LIT, "weapons/flmfire2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	newmis.effects = 8;
	newmis.velocity_z = random() * 250;
	newmis.nextthink = time + 0.05;
	newmis.think = s2_explode1;
	newmis.nextthink = time + 0.05;
};
void(float tno) RemoveOldAmmobox = 
{
	local float index;
	local entity old;
	if (tno != 0)
	{
		index = num_team_ammoboxes(tno);
		index = index - 20 / number_of_teams;
	}
	else
	{
		index = num_world_ammoboxes - 20;
	}
	old = find(world, classname, "ammobox");
	while (index > 0)
	{
		if (old == world)
		{
			dprint("***\n");
			return;
		}
		if (old.team_no == tno || tno == 0)
		{
			old.think = SUB_Remove;
			old.nextthink = time + 0.1;
			index = index - 1;
			num_world_ammoboxes = num_world_ammoboxes - 1;
			decrement_team_ammoboxes(old.team_no);
		}
		old = find(old, classname, "ammobox");
	}
};
void() TeamFortress_AmmoboxTouch = 
{
	local float took;
	local string quantity;
	local entity _l_10486;
	took = 0;
	if (other == self.enemy && time < self.health + 2)
	{
		return;
	}
	if (other.classname != "player")
	{
		return;
	}
	if (other.health <= 0)
	{
		return;
	}
	num_world_ammoboxes = num_world_ammoboxes - 1;
	decrement_team_ammoboxes(self.team_no);
	if (self.weapon == 0)
	{
		sprint(other, 0, "You got ");
		if (self.ammo_shells > 0)
		{
			other.ammo_shells = other.ammo_shells + self.ammo_shells;
			quantity = ftos(self.ammo_shells);
			sprint2(other, 0, quantity, " shells  ");
		}
		if (self.ammo_nails > 0)
		{
			other.ammo_nails = other.ammo_nails + self.ammo_nails;
			quantity = ftos(self.ammo_nails);
			sprint2(other, 0, quantity, " nails  ");
		}
		if (self.ammo_rockets > 0)
		{
			other.ammo_rockets = other.ammo_rockets + self.ammo_rockets;
			quantity = ftos(self.ammo_rockets);
			sprint2(other, 0, quantity, " rockets  ");
		}
		if (self.ammo_cells > 0)
		{
			other.ammo_cells = other.ammo_cells + self.ammo_cells;
			quantity = ftos(self.ammo_cells);
			sprint2(other, 0, quantity, " cells  ");
		}
		sprint(other, 0, ".\n");
	}
	else
	{
		if (self.weapon == 1)
		{
			if (other.ammo_shells >= TeamFortress_GetMaxAmmo(other, 256))
			{
				return;
			}
			other.ammo_shells = other.ammo_shells + self.aflag;
			self.netname = "shells";
		}
		else
		{
			if (self.weapon == 2)
			{
				if (other.ammo_nails >= TeamFortress_GetMaxAmmo(other, 512))
				{
					return;
				}
				other.ammo_nails = other.ammo_nails + self.aflag;
				self.netname = "nails";
			}
			else
			{
				if (self.weapon == 3)
				{
					if (other.ammo_rockets >= TeamFortress_GetMaxAmmo(other, 1024))
					{
						return;
					}
					other.ammo_rockets = other.ammo_rockets + self.aflag;
					self.netname = "rockets";
				}
				else
				{
					if (self.weapon == 4)
					{
						if (other.ammo_cells >= TeamFortress_GetMaxAmmo(other, 2048))
						{
							return;
						}
						other.ammo_cells = other.ammo_cells + self.aflag;
						self.netname = "cells";
					}
				}
			}
		}
		if ((self.weapon == 5.000000))
		{
			if ((other.no_grenades_1 >= 4.000000))
			{
				return;
			}
			other.no_grenades_1 = (other.no_grenades_1 + 1.000000);
			self.netname = "gren1s";
		}
	}
	bound_other_ammo(other);
	if (self.weapon > 0)
	{
		quantity = ftos(self.aflag);
		sprint5(other, 0, "You picked up ", quantity, " ", self.netname, "\n");
	}
	sound(other, 3, "weapons/lock4.wav", 1, 1);
	stuffcmd(other, "bf\n");
	if (other.autodiscard)
	{
		_l_10486 = self;
		self = other;
		TeamFortress_Discard ();
		self = _l_10486;
	}
	sprint(other, 2, "You picked up some ammo, and 1 beartrap.\n ");
	self.pk_beartrapammo = self.pk_beartrapammo +1;
	dremove(self);
	self = other;
	W_SetCurrentAmmo();
};
void(float tno) increment_team_ammoboxes = 
{
	if (tno == 1)
	{
		num_team_ammoboxes_1 = num_team_ammoboxes_1 + 1;
	}
	else
	{
		if (tno == 2)
		{
			num_team_ammoboxes_2 = num_team_ammoboxes_2 + 1;
		}
		else
		{
			if (tno == 3)
			{
				num_team_ammoboxes_3 = num_team_ammoboxes_3 + 1;
			}
			else
			{
				if (tno == 4)
				{
					num_team_ammoboxes_4 = num_team_ammoboxes_4 + 1;
				}
			}
		}
	}
};
void(float tno) decrement_team_ammoboxes = 
{
	if (tno == 1)
	{
		num_team_ammoboxes_1 = num_team_ammoboxes_1 - 1;
	}
	else
	{
		if (tno == 2)
		{
			num_team_ammoboxes_2 = num_team_ammoboxes_2 - 1;
		}
		else
		{
			if (tno == 3)
			{
				num_team_ammoboxes_3 = num_team_ammoboxes_3 - 1;
			}
			else
			{
				if (tno == 4)
				{
					num_team_ammoboxes_4 = num_team_ammoboxes_4 - 1;
				}
			}
		}
	}
};
float(float tno) num_team_ammoboxes = 
{
	if (tno == 1)
	{
		return num_team_ammoboxes_1;
	}
	else
	{
		if (tno == 2)
		{
			return num_team_ammoboxes_2;
		}
		else
		{
			if (tno == 3)
			{
				return num_team_ammoboxes_3;
			}
			else
			{
				if (tno == 4)
				{
					return num_team_ammoboxes_4;
				}
			}
		}
	}
	return 0;
};
void() s_explode1 = [0, s_explode2]
{};
void() s_explode2 = [1, s_explode3]
{};
void() s_explode3 = [2, s_explode4]
{};
void() s_explode4 = [3, s_explode5]
{};
void() s_explode5 = [4, s_explode6]
{};
void() s_explode6 = [5, SUB_Remove]
{};
void() s2_explode1 = [0, s2_explode2]
{};
void() s2_explode2 = [1, s2_explode3]
{};
void() s2_explode3 = [2, s2_explode4]
{};
void() s2_explode4 = [3, s2_explode5]
{};
void() s2_explode5 = [4, s2_explode6]
{};
void() s2_explode6 = [5, s2_explode7]
{};
void() s2_explode7 = [6, s2_explode8]
{};
void() s2_explode8 = [7, SUB_Remove]
{};
void() BecomeExplosion = 
{
	dremove(self);
};
void(entity p) TeamFortress_SetSpeed = 
{
	local string sp;
	local float tf;
	local entity te;
//	stuffcmd(p, "cl_movespeedkey 1\n");  //what is this for? -arg
	if (p.playerclass == 1)
	{
		p.maxspeed = 400;
		p.maxfbspeed = 400;
		p.maxstrafespeed = 400;
	}
	else
	{
		if (p.playerclass == 2)
		{
			p.maxspeed = 300;
			p.maxfbspeed = 300;
			p.maxstrafespeed = 300;
		}
		else
		{
			if (p.playerclass == 3)
			{
				p.maxspeed = 250;
				p.maxfbspeed = 250;
				p.maxstrafespeed = 250;
			}
			else
			{
				if (p.playerclass == 4)
				{
					p.maxspeed = 280;
					p.maxfbspeed = 280;
					p.maxstrafespeed = 280;
				}
				else
				{
					if (p.playerclass == 5)
					{
						p.maxspeed = 320;
						p.maxfbspeed = 320;
						p.maxstrafespeed = 320;
					}
					else
					{
						if (p.playerclass == 6)
						{
							p.maxfbspeed = 250;  //Was 230 speed -arg
							p.maxspeed = 250;
							p.maxstrafespeed = 250;
						}
						else
						{
							if (p.playerclass == 7)
							{
								p.maxspeed = 300;
								p.maxfbspeed = 300;
								p.maxstrafespeed = 300;
							}
							else
							{
								if (p.playerclass == 11)
								{
									p.maxspeed = 500;
									p.maxfbspeed = 500;
									p.maxstrafespeed = 500;
								}
								else
								{
									if (p.playerclass == 8)
									{
										p.maxspeed = 300;
										p.maxfbspeed = 300;
										p.maxstrafespeed = 300;
									}
									else
									{
										if (p.playerclass == 9)
										{
											p.maxspeed = 300;
											p.maxfbspeed = 300;
											p.maxstrafespeed = 300;
										}
										else
										{
											if (p.playerclass == 0)
											{
												p.gravity = 0;
												p.maxspeed = 500;
												p.maxfbspeed = 500;
												p.maxstrafespeed = 500;
												return;
											}
#ifdef NEW_CLASS1
											else
											{
												if (p.playerclass == #CLASS_SPECOP)
												{
													p.maxspeed = 400;
													p.maxfbspeed = 400;
													p.maxstrafespeed = 400;
												}
											}
#endif
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (p.tfstate & 65536 || p.playerclass == 0)
	{
		p.maxspeed = 0;
		p.maxfbspeed = 0;
		p.maxstrafespeed = 0;
			stuffcmd(p, "m_forward 0\n");
			stuffcmd(p, "m_side 0\n");
		p.velocity = '0 0 0';
		stuffcmd(p, "cl_backspeed 0\n");
		stuffcmd(p, "cl_forwardspeed 0\n");
		stuffcmd(p, "cl_sidespeed 0\n");
		return;
	}
	else
	{
			stuffcmd(p, "m_forward 1\n");
			stuffcmd(p, "m_side 0.8\n");
	}
	tf = 0;
	te = find(world, classname, "item_tfgoal");
	while (te != world && tf == 0)
	{
		if (te.owner == p)
		{
			if (te.goal_activation & 2)
			{
				tf = 1;
				p.maxfbspeed = p.maxfbspeed / 2;
				p.maxstrafespeed = p.maxstrafespeed / 2;
				p.maxspeed = p.maxfbspeed;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (p.tfstate & 32768)
	{
		p.maxfbspeed = p.maxfbspeed / 5 * 2;
		p.maxstrafespeed = p.maxstrafespeed / 5 * 2;
		p.maxspeed = p.maxfbspeed;
	}
	if (p.leg_damage)
	{
		if (p.leg_damage > 4)
		{
			p.leg_damage = 4;
		}
		p.maxfbspeed = p.maxfbspeed * ((10 - p.leg_damage) / 20);
		p.maxstrafespeed = p.maxstrafespeed * (10 - p.leg_damage) / 20;
		p.maxspeed = p.maxfbspeed;
	}
	if (p.tfstate & 2048)
	{
		if (p.maxfbspeed > 60)
		{
			p.maxfbspeed = 60;
			p.maxspeed = p.maxfbspeed;
		}
		if (p.maxstrafespeed > 60)
		{
			p.maxstrafespeed = 60;
		}
	}
	if (p.tfstate & 131072)
	{
		if (p.maxspeed > 80)
		{
			p.maxspeed = 80;
		}
	}
	sp = ftos(p.maxfbspeed);
	stuffcmd(p, "cl_backspeed ");
	stuffcmd(p, sp);
	stuffcmd(p, "\n");
	stuffcmd(p, "cl_forwardspeed ");
	stuffcmd(p, sp);
	stuffcmd(p, "\n");
	sp = ftos(p.maxstrafespeed);
	stuffcmd(p, "cl_sidespeed ");
	stuffcmd(p, sp);
	stuffcmd(p, "\n");
};
void() monster_death_use = 
{
		if (self.flags & TF_FLARE_OFF)
		{
			self.flags = self.flags - TF_FLARE_OFF;
		}
			if (self.flags & 2)
			{
			self.flags = self.flags - 2;
			}
		if (!(self.target))
		{
			return;
		}
		activator = self.enemy;
		SUB_UseTargets();
};
float(entity targ, entity inflictor) CanDamage = 
{
	if (targ.movetype == 7)
	{
		traceline(inflictor.origin, 0.5 * (targ.absmin + targ.absmax), TF_FLARE_OFF, self);
		if (trace_fraction == TF_FLARE_OFF)
		{
			return TF_FLARE_OFF;
		}
		if (trace_ent == targ)
		{
			return TF_FLARE_OFF;
		}
		return TF_FLARE_LIT;
	}
	traceline(inflictor.origin, targ.origin, TF_FLARE_OFF, self);
		if (trace_fraction == TF_FLARE_OFF)
		{
			return TF_FLARE_OFF;
		}
		traceline(inflictor.origin, targ.origin + '15 15 0', TF_FLARE_OFF, self);
			if (trace_fraction == TF_FLARE_OFF)
			{
				return TF_FLARE_OFF;
			}
		traceline(inflictor.origin, targ.origin + '-15 -15 0', TF_FLARE_OFF, self);
		if (trace_fraction == TF_FLARE_OFF)
		{
			return TF_FLARE_OFF;
		}
		traceline(inflictor.origin, targ.origin + '-15 15 0', TF_FLARE_OFF, self);
		if (trace_fraction == TF_FLARE_OFF)
		{
			return TF_FLARE_OFF;
		}
		traceline(inflictor.origin, targ.origin + '15 -15 0', TF_FLARE_OFF, self);
		if (trace_fraction == TF_FLARE_OFF)
		{
			return TF_FLARE_OFF;
		}
		return TF_FLARE_LIT;
};
void (float respawntime, void() spawn_func) COOP_SetupRespawn =
{
	local entity newmon;
	local float rtime;
	local entity hax;
	local float hax_tm;
	local float special_end;
	local entity exit_ent;
	special_end = Coop_SpecialEnd( mapname );
	self.flags = #FL_FINDABLE_NONSOLID;		// for minion summon
	self.monster_string = "off";
	if (self.classname == "the_mister")
		return;
	if (intermission_running)
		return;
	if (self.monster_items & MITEM_INVISIBLE)
		setmodel(self, self.old_model);
	if (!spawn_func)
	{
//		bprint (PRINT_HIGH, "Invalid spawn func!\n");  //Who cares if you remove a monster and the map has it defined, skip it. -arg
		return;
	}
	if ((mtf_saveentity() == 1 && self.lives <= 0) || self.lives == -1)
	{
		newmis = spawn();
		newmis.think = MTF_RemoveMonster;
		newmis.nextthink = time + 5;
		newmis.enemy = self;
	}
	if (self.#is_minion == #TRUE)
	{
		newmis = spawn();
		newmis.think = MTF_RemoveMonster;
		newmis.nextthink = time + 5;
		newmis.enemy = self;
		return;
	}
	if (self.lives <= 0)
	{
		killed_monsters = killed_monsters + 1.000000;
		hax = find(world, monster_string, "on");
		while (hax)
		{
			if (hax.#is_minion == #FALSE)
			{
				hax_tm = hax_tm + 1;
				hax = find(hax, monster_string, "on");
			}
	}
		WriteByte (2.000000, 27.000000);
		if ( special_end > 0 )
		{
			if ( killed_monsters >= special_end )
			{
				exit_ent = spawn();
				other = checkclient();
				if (!other)
			{
					dremove(exit_ent);
				}
				else
				{
					exit_ent.think = changelevel_touch;
					exit_ent.nextthink = time;
				}
			}
		}		
		if ( (total_monsters - hax_tm) > killed_monsters && ( lms_entity == world ) )		// fixme: LMS farfs up monster count (says more are killed than really are.) :\
		{
		dprint(ftos(hax_tm));
		dprint(" is hax and the rest is ");
		dprint(ftos(total_monsters));
		dprint(" is total mons\n");
			killed_monsters = (total_monsters - hax_tm);
			if (killed_monsters > total_monsters)		// FIXME: this is a problem in LMS...
				killed_monsters = total_monsters;		///
			WriteByte (MSG_ALL, 38);
			WriteByte (MSG_ALL, 14);
			WriteLong (MSG_ALL, killed_monsters);
		}
		if (hax_tm == 0 && lms_entity != world)
		{
			killed_monsters = total_monsters;
			WriteByte (MSG_ALL, 38);
			WriteByte (MSG_ALL, 14);
			WriteLong (MSG_ALL, killed_monsters);
		}
		return;
	}
	newmon = spawn ();
	newmon.lives = self.lives - 1;
	setorigin (newmon, self.npc_originalloc);
	rtime = cvar ("monster_respawndelay");
	if (survival_mode)
	{
		rtime = random() * 15;  //was 30, but takes forever on the end of some maps. -arg
	}
	if ( self.respawn_time > 0 )
	{
		if (self.respawn_time > 10)  
			{
			rtime = rtime / 2;
			}
		rtime = self.respawn_time;
		newmon.respawn_time = rtime;
	}
	if (!rtime || rtime < 1)
		rtime = .5;
	if (rtime > 0)
		newmon.nextthink = time + rtime;
	else
		newmon.nextthink = time + respawntime;
	if (rtime > 0)
		newmon.#npc_spawndelay = rtime;
	else
	newmon.#npc_spawndelay = respawntime;
	newmon.angles = self.#npc_origangle;
	newmon.#npc_origangle = self.#npc_origangle;
	newmon.netname = self.netname;
	newmon.classname = self.classname;
	newmon.old_owner = self;
	newmon.is_monster = 1;
	newmon.monster_string = "on";
	newmon.target = self.target;
	newmon.spawnflags = self.spawnflags;
	newmon.#is_warped = #TRUE;
	newmon.coop_exp = self.coop_exp;
	newmon.brain = self.brain;
	if ( newmon.spawnflags & #SPAWN_USETARGETSONRESPAWN )
		newmon.#npc_useTargetsOnRespawn = #TRUE;
	if (newmon.netname == "armagon")
	{
		dremove(newmon);
		return;
	}
	newmon.think = respawn_think;
	if (!spawn_func)
	{
		bprint(2,"DEV: SPAWN_FUNC ERROR\n");
		dremove(newmis);
	}
	newmon.think1 = spawn_func;
};
void(entity p) bound_other_ammo = 
{
	if (p.ammo_shells > TeamFortress_GetMaxAmmo(p, 256))
	{
		p.ammo_shells = TeamFortress_GetMaxAmmo(p, 256);
	}
	if (p.ammo_nails > TeamFortress_GetMaxAmmo(p, 512))
	{
		p.ammo_nails = TeamFortress_GetMaxAmmo(p, 512);
	}
	if (p.ammo_rockets > TeamFortress_GetMaxAmmo(p, 1024))
	{
		p.ammo_rockets = TeamFortress_GetMaxAmmo(p, 1024);
	}
	if (p.ammo_cells > TeamFortress_GetMaxAmmo(p, 2048))
	{
		p.ammo_cells = TeamFortress_GetMaxAmmo(p, 2048);
	}
	if (p.ammo_medikit > p.maxammo_medikit)
	{
		p.ammo_medikit = p.maxammo_medikit;
	}
	if (p.armorvalue > p.maxarmor)
	{
		p.armorvalue = p.maxarmor;
	}
};
void(entity p) TeamFortress_SetSkin = 
{
#ifdef mtf_coop_halloween
	local string st;

	st = infokey(p, "skin");

	if (st == "picard" || st == "boba" || st == "duke" || st == "skel" || st == "doomguy"
		|| st == "batleth" || st == "chewie" || st == "spidey")
		return;
#endif
	if (MTF_Coop_GetSkin(p.connect_name, p.coop_exp) != "" && MTF_Coop_IsValidPlayer(p))
	{
		stuffcmd(p, "skin ");
		stuffcmd(p, MTF_Coop_GetSkin(p.connect_name, p.coop_exp));
		stuffcmd(p, "\n");
		return;
	}
	self.immune_to_check = time + 20;
	if (p.playerclass == 8 && p.undercover_skin != 0)
	{
		p.skin = p.undercover_skin;
	}
	else
	{
		p.skin = p.playerclass;
	}
	if (p.skin != 0)
	{
		stuffcmd(p, "skin ");
		if (p.team_no == 4)
		{
			if (p.skin == 1)
			{
				stuffcmd(p, "airscout\n");
			}
			else
			{
				if (p.skin == 2)
				{
					stuffcmd(p, "tf_snipe\n");
				}
				else
				{
					if (p.skin == 3)
					{
						stuffcmd(p, "tf_sold\n");
					}
					else
					{
						if (p.skin == 4)
						{
							stuffcmd(p, "tf_demo\n");
						}
						else
						{
							if (p.skin == 5)
							{
								stuffcmd(p, "tf_medic\n");
							}
							else
							{
								if (p.skin == 6)
								{
									stuffcmd(p, "tf_hwguy\n");
								}
								else
								{
									if (p.skin == 7)
									{
										stuffcmd(p, "tf_pyro\n");
									}
									else
									{
										if (p.skin == 8)
										{
											stuffcmd(p, "tf_spy\n");
										}
										else
										{
											if (p.skin == 9)
											{
												stuffcmd(p, "tf_eng\n");
											}
#ifdef NEW_CLASS1
											else
											{
												if (p.skin == #CLASS_SPECOP)
												{
													stuffcmd(p, "specop\n");
												}
											}
#endif
										}
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			if (p.team_no == 3)
			{
				if (p.skin == 1)
				{
					stuffcmd(p, "airscout\n");
				}
				else
				{
					if (p.skin == 2)
					{
						stuffcmd(p, "tf_snipe\n");
					}
					else
					{
						if (p.skin == 3)
						{
							stuffcmd(p, "tf_sold\n");
						}
						else
						{
							if (p.skin == 4)
							{
								stuffcmd(p, "tf_demo\n");
							}
							else
							{
								if (p.skin == 5)
								{
									stuffcmd(p, "tf_medic\n");
								}
								else
								{
									if (p.skin == 6)
									{
										stuffcmd(p, "tf_hwguy\n");
									}
									else
									{
										if (p.skin == 7)
										{
											stuffcmd(p, "tf_pyro\n");
										}
										else
										{
											if (p.skin == 8)
											{
												stuffcmd(p, "tf_spy\n");
											}
											else
											{
												if (p.skin == 9)
												{
													stuffcmd(p, "tf_eng\n");
												}
#ifdef NEW_CLASS1
											else
											{
												if (p.skin == #CLASS_SPECOP)
												{
													stuffcmd(p, "specop\n");
												}
											}
#endif
											}
										}
									}
								}
							}
						}
					}
				}
			}
			else
			{
				if (p.team_no == 2)
				{
					if (p.skin == 1)
					{
						stuffcmd(p, "airscout\n");
					}
					else
					{
						if (p.skin == 2)
						{
							stuffcmd(p, "tf_snipe\n");
						}
						else
						{
							if (p.skin == 3)
							{
								stuffcmd(p, "tf_sold\n");
							}
							else
							{
								if (p.skin == 4)
								{
									stuffcmd(p, "tf_demo\n");
								}
								else
								{
									if (p.skin == 5)
									{
										stuffcmd(p, "tf_medic\n");
									}
									else
									{
										if (p.skin == 6)
										{
											stuffcmd(p, "tf_hwguy\n");
										}
										else
										{
											if (p.skin == 7)
											{
												stuffcmd(p, "tf_pyro\n");
											}
											else
											{
												if (p.skin == 8)
												{
													stuffcmd(p, "tf_spy\n");
												}
												else
												{
													if (p.skin == 9)
													{
														stuffcmd(p, "tf_eng\n");
													}
#ifdef NEW_CLASS1
											else
											{
												if (p.skin == #CLASS_SPECOP)
												{
													stuffcmd(p, "specop\n");
												}
											}
#endif
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					if (p.skin == 1)
					{
						stuffcmd(p, "airscout\n");
					}
					else
					{
						if (p.skin == 2)
						{
							stuffcmd(p, "tf_snipe\n");
						}
						else
						{
							if (p.skin == 3)
							{
								stuffcmd(p, "tf_sold\n");
							}
							else
							{
								if (p.skin == 4)
								{
									stuffcmd(p, "tf_demo\n");
								}
								else
								{
									if (p.skin == 5)
									{
										stuffcmd(p, "tf_medic\n");
									}
									else
									{
										if (p.skin == 6)
										{
											stuffcmd(p, "tf_hwguy\n");
										}
										else
										{
											if (p.skin == 7)
											{
												stuffcmd(p, "tf_pyro\n");
											}
											else
											{
												if (p.skin == 8)
												{
													stuffcmd(p, "tf_spy\n");
												}
												else
												{
													if (p.skin == 9)
													{
														stuffcmd(p, "tf_eng\n");
													}
#ifdef NEW_CLASS1
											else
											{
												if (p.skin == #CLASS_SPECOP)
												{
													stuffcmd(p, "specop\n");
												}
											}
#endif
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if (p.skin == 11)
		{
			stuffcmd(p, "base\n");
		}
	}
	else
	{
		stuffcmd(p, "skin base\n");
	}
};
void () MTF_Priority_Precache =
{
	if (mapname == "qte1m3" || mapname == "qte1m4" || mapname == "qte2m2" 
	   || mapname == "qte2m3" || mapname == "qte2m4")
	{
		precache_model("progs/wizard.mdl");
		precache_model("progs/zombie.mdl");
		precache_model("progs/ogre.mdl");
		precache_model("progs/w_g_key.mdl");
		precache_model("progs/enforcer.mdl");
		precache_model("progs/soldier_neh.mdl");
		precache_model("progs/shalrath.mdl");
		precache_model("progs/tarbaby.mdl");
		precache_model("progs/knight.mdl");
		precache_model("progs/hknight_neh.mdl");
		precache_model("progs/shambler.mdl");
		precache_model("progs/proxgren.mdl");
		precache_model("progs/v_asscan.mdl");
		precache_model("progs/v_mac10.mdl");
		precache_model("progs/v_grap.mdl");
	}
	if (mapname == "qte1m3" || mapname == "qte2m2" || mapname == "qte2m3" || mapname == "qte2m4")
	{
		precache_model("progs/v_knife.mdl");
		precache_model("progs/v_knife2.mdl");
		precache_model("progs/v_span.mdl");
		precache_model("progs/v_rail.mdl");
	}
	if (mapname == "qte1m4" || mapname == "qte2m2" || mapname == "qte2m3" || mapname == "qte2m4")
	{
		if (mapname == "qte2m3")
		{
			precache_model ("progs/demon.mdl");
			precache_model ("progs/dog.mdl");
		}
		precache_model("progs/dispencr.mdl");
		precache_model("progs/end1.mdl");
		precache_model("progs/end2.mdl");
		precache_model("progs/v_rail.mdl");
		precache_model("progs/turrgun.mdl");
	}
	if (mapname == "qte2m3")
	{
		precache_model ("progs/dog.mdl");
		precache_model("progs/end1.mdl");
		precache_model("progs/end2.mdl");
		precache_model("progs/turrgun.mdl");
		precache_model("progs/v_medi.mdl");
		precache_model("progs/v_bio.mdl");
		precache_model("progs/v_srifle.mdl");
		precache_model ("progs/demon.mdl");
	}
	else
	if (mapname == "qte2m2")
	{
		precache_model ("progs/demon.mdl");
		precache_model ("progs/boss.mdl");
	}
	if (mapname == "neh1m9" || mapname == "neh2m3")
	{
		precache_model ("progs/v_mac10.mdl");
		precache_model ("progs/v_asscan.mdl");
		precache_model("progs/soldier_neh.mdl");
		precache_model ("progs/hunter.mdl");
		precache_model ("progs/h_zombie.mdl");
		precache_model ("progs/dog.mdl");
		precache_model ("progs/vomitus.mdl");
		precache_model ("progs/mark4.mdl");
		precache_model ("progs/mark3.mdl");
		precache_model ("progs/shalrath.mdl");
		precache_model ("progs/slime.mdl");
	}
};
string ( entity monster, float return_name ) GetMonsterPowers =
{
	local string rtrn;
	if (monster.#is_minion == #TRUE)
		rtrn = strcat(rtrn, "summoned ");
	if (monster.monster_items & MITEM_QUAD)
	{
		rtrn = strcat(rtrn, "QUAD ");
	}
	if (monster.monster_items & MITEM_INVISIBLE)
	{
		rtrn = strcat(rtrn, "INVISIBLE ");	// INVISIBLE
	}
	if (monster.monster_items & MITEM_SPEED)
	{
		rtrn = strcat(rtrn, "SPEED ");	// SPEED
	}
	if (monster.monster_items & MITEM_MEGAHEALTH)
	{
		rtrn = strcat(rtrn, "MEGAHEALTH ");	// MEGAHEALTH
	}
	if (monster.monster_items & MITEM_FLAME)
	{
		rtrn = strcat(rtrn, "FLAME ");	// FLAME
	}
	if (monster.monster_items & MITEM_ICE)
	{
		rtrn = strcat(rtrn, "ICE ");		// ICE
	}
	if (monster.monster_items & MITEM_LIGHTNING)
	{
		rtrn = strcat(rtrn, "LIGHTNING ");		// LIGHTNING
	}
	if (monster.monster_items & MITEM_AIR)
	{
		rtrn = strcat(rtrn, "AIR ");		// AIR
	}
	if (monster.monster_items & MITEM_POWERSTEALER)
	{
		rtrn = strcat(rtrn, "POWER-STEALER ");		// POWERSTEALER
	}	
	if (monster.weapon & #MWEAPON_ROCKETLAUNCHER)
	{
		rtrn = strcat(rtrn, "rocket ");
	}
	if (monster.weapon & #MWEAPON_MIRV)
	{
		rtrn = strcat(rtrn, "mortar ");
	}
	if (monster.weapon & #MWEAPON_FIREBALL)
	{
		rtrn = strcat(rtrn, "fireball ");
	}
	if (monster.weapon & #MWEAPON_FASTSHOT)
	{
		rtrn = strcat(rtrn, "fastshot ");
	}
	if (monster.weapon & #MWEAPON_SNIPER)
	{
		rtrn = strcat(rtrn, "sniper ");
	}
	if (monster.weapon & #MWEAPON_PLAGUE)
	{
		rtrn = strcat(rtrn, "plague ");
	}
	if (monster.weapon & #MWEAPON_FLAME)
	{
		rtrn = strcat(rtrn, "flamethrower ");
	}
	if (monster.weapon & #MWEAPON_BOUNCEMISSILE)
	{
		rtrn = strcat(rtrn, "ricochet ");
	}
	if (monster.monster_items & MITEM_BOSS)
	{
		rtrn = strcat(rtrn, "BOSS ");		// BOSS
	}
	if ( return_name > 0 )
	{
		if (monster.netname == "zombie")
			rtrn = strcat(rtrn, "zombies");
		else
			rtrn = strcat(rtrn, monster.netname);
	}
	if (monster.#is_minion == #TRUE)
	{
		rtrn = strcat(rtrn, " (");
		rtrn = strcat(rtrn, monster.owner.netname);
		rtrn = strcat(rtrn, ")");
	}
	if ( return_name > 1 )
		rtrn = strcat(rtrn, "\n");
	if ( monster == world )
		rtrn = "wall\n";		// xav: best message I can come up with? I liked spawning through the levy better :(
	return rtrn;
};
void () W_SetCurrentAmmo =
{
	if (((self.health <= 0.000000) || (self.current_weapon == 0.000000)))
	{
		return;
	}
	if (self.weaponmodel == "progs/proxgren.mdl" || self.weaponmodel == "progs/spycamb.mdl")
	{
		self.currentammo = self.currentammo;
		return;
	}
	self.items = (self.items - (self.items & (((256 | 512) | 1024) | 2048)));
	self.weapon = 0.000000;         // pablo. fix to assualt cannon jamming when on backpacks.
	if ((self.tools == (self.tools | 32)))
	{
		return;
	}
	if ((self.current_weapon == 16))
	{
		self.currentammo = 0.000000;
		if ((self.weaponmode == 0.000000))
		{
			if (self.playerclass == 7)
			{
				self.weaponmodel = #MODEL_CHAINSAW;
				self.currentammo = self.ammo_nails;
			}
			else
			self.weaponmodel = "progs/v_knife.mdl";//v_axe.mdl";
		}
		else
		{
			self.weaponmodel = "progs/v_knife2.mdl";//self.weaponmodel = "progs/v_axe.mdl";
		}
if (allow_bat == 1)
	{
	if (self.playerclass == 1)
	self.weaponmodel = "progs/v_bat.mdl";
	}
		self.weaponframe = 0.000000;
	}
	else
	if (self.current_weapon == #WEAP_ZEROGRAVITY)
	{
		self.currentammo = 0;
		self.weaponmodel = #MODEL_V_SHOTGUN;
		self.weaponframe = 7;
	}
	else
	{
		if ((self.current_weapon == 1))
		{
			if ((self.owner.ammo_cells > 0))
			{
				self.ammo_cells = self.owner.ammo_cells;
			}				
			self.currentammo = self.ammo_cells;
			self.weaponmodel = "progs/v_grap.mdl";
			self.weaponframe = 0.000000;
		}
		else
		{
			if ((self.current_weapon == 8))
			{
				self.currentammo = self.ammo_cells;
				self.weaponmodel = "progs/v_span.mdl";
				self.weaponframe = 0.000000;
			}
			else
			{
				if ((self.current_weapon == 128))
				{
					if ( self.mtf_items & #MTFITEM_LIGHTGUN )
					{
						self.mtf_items |= #MTFITEM_LIGHTGUN;
						self.currentammo = self.ammo_cells;
						if (!(self.tfstate & 2))
						{
							self.weaponmodel = #MODEL_V_SHOTGUN;
							self.weaponframe = 7;
						}
						self.items = (self.items | 2048);
					}
					else
					{
					self.currentammo = self.ammo_shells;
					self.items = (self.items | 2048);
					if (!(self.tfstate & 2))
					{
						self.weaponmodel = #MODEL_V_SHOTGUN;
						self.weaponframe = 0.000000;
					}
					self.items = (self.items | 256);
					self.weapon = 1;
					}
				}
				else
				{
					if ((self.current_weapon == 256))
					{
						self.currentammo = self.ammo_shells;
						if (!(self.tfstate & 2))
						{
							self.weaponmodel = "progs/v_shot2.mdl";
							self.weaponframe = 0.000000;
						}
						self.items = (self.items | 256);
						self.weapon = 2;
					}
					else
					{
						if ((self.current_weapon == 512))
						{
							self.currentammo = self.ammo_nails;
							if (!(self.tfstate & 2))
							{
								self.weaponmodel = "progs/v_mac10.mdl";
								self.weaponframe = 0.000000;
							}
							self.items = (self.items | 512);
							self.weapon = 4;
						}
						else
						{
							if ((self.current_weapon == 1024))
							{
								self.currentammo = self.ammo_nails;
								if (!(self.tfstate & 2))
								{
									self.weaponmodel = "progs/v_nail2.mdl";
									self.weaponframe = 0.000000;
								}
								self.items = (self.items | 512);
								self.weapon = 8;
							}
							else
							{
								if ((self.current_weapon == 2048))
								{
									self.currentammo = self.ammo_rockets;
									if (!(self.tfstate & 2))
									{
										self.weaponmodel = "progs/v_rock.mdl";
										self.weaponframe = 0.000000;
									}
									self.weapon = 16;
									self.items = (self.items | 1024);
								}
								else
								{
									if ((self.current_weapon == 8192))
									{
										self.currentammo = self.ammo_rockets;
										if (!(self.tfstate & 2))
										{
											self.weaponmodel = "progs/v_rock2.mdl";
											self.weaponframe = 0.000000;
										}
										self.items = (self.items | 1024);
										self.weapon = 32;
									}
									else
									{
										if ((self.current_weapon == 65536))
										{
											self.currentammo = self.ammo_cells;
											if (!(self.tfstate & 2))
											{
												self.weaponmodel = "progs/v_mac10.mdl";
												self.weaponframe = 0.000000;
											}
											self.items = (self.items | 2048);
											self.weapon = 64;
										}
										else
										{
											if ((self.current_weapon == 32))
											{
												self.currentammo = self.ammo_shells;
												if (!(self.tfstate & 2))
												{
													self.weaponmodel = "progs/v_srifle.mdl";
													self.weaponframe = 0.000000;
												}
												self.items = (self.items | 256);
												self.weapon = 1;
											}
											else
											{
												if ((self.current_weapon == 64))
												{
													self.currentammo = self.ammo_shells;
													if (!(self.tfstate & 2))
													{
														self.weaponmodel = "progs/v_srifle.mdl";
														self.weaponframe = 0.000000;
													}
													self.items = (self.items | 256);
													self.weapon = 2;
												}
												else
												{
													if ((self.current_weapon == 32768))
													{
														self.currentammo = self.ammo_shells;
														if (!(self.tfstate & 2))
														{
															self.weaponmodel = "progs/v_asscan.mdl";
															self.weaponframe = 0.000000;
														}
														self.items = (self.items | 256);
														self.weapon = 32;
													}
													else
													{
														if ((self.current_weapon == 4096))
														{
															self.currentammo = self.ammo_cells;
															if (!(self.tfstate & 2))
															{
																self.weaponmodel = "progs/v_rock.mdl";
																self.weaponframe = 0.000000;
															}
															self.items = (self.items | 2048);
															self.weapon = 16;
														}
														else
														{
															if ((self.current_weapon == 16384))
															{
																self.currentammo = self.ammo_rockets;
																if (!(self.tfstate & 2))
																{
																	self.weaponmodel = "progs/v_rock2.mdl";
																	self.weaponframe = 0.000000;
																}
																self.items = (self.items | 1024);
																self.weapon = 32;
															}
															else
															{
																if ((self.current_weapon == 4))
																{
																	self.currentammo = 0.000000;
																	self.weaponmodel = "progs/v_medi.mdl";
																	self.weaponframe = 0.000000;
																}
																else
																{
																	if ((self.current_weapon == 2))
																	{
																		self.currentammo = 0.000000;
																		self.weaponmodel = "progs/v_bio.mdl";
																		self.weaponframe = 0.000000;
																	}
																	else
																	{
																		if ((self.current_weapon == 262144))
																		{
																			self.currentammo = self.ammo_shells;
																			if (!(self.tfstate & 2))
																			{
																				self.weaponmodel = #MODEL_V_SHOTGUN;
																				self.weaponframe = 0.000000;
																			}
																			self.items = (self.items | 256);
																			self.weapon = 1;
																		}
																		else
																		{
																			if ((self.current_weapon == 524288))
																			{
																				self.currentammo = self.ammo_nails;
																				if (!(self.tfstate & 2))
																				{
																					self.weaponmodel = "progs/v_rail.mdl";
																					self.weaponframe = 0.000000;
																				}
																				self.items = (self.items | 512);
																				self.weapon = 1;
																			}
																			else
																			{
#ifdef NEW_CLASS1
																				if ((self.current_weapon == #WEAPON_THUMPER))
																				{
																					self.currentammo = self.ammo_shells;
																					if (!(self.tfstate & 2))
																					{
																						self.weaponmodel = "progs/v_shot3.mdl";
																						self.weaponframe = 0.000000;
																					}
																					}
																				else
																				{
																				if ((self.current_weapon == #WEAPON_CROSSBOW))
																				{
																					self.currentammo = self.ammo_shells;
																					if (!(self.tfstate & 2))
																					{
																						self.weaponmodel = "progs/v_cbow.mdl";
																						self.weaponframe = 0;
																					}
																					}
																				else
																				{
																				if ((self.current_weapon == #WEAPON_DOUBLE_THUMPER))
																				{
																					self.currentammo = self.ammo_shells;
																					if (!(self.tfstate & 2))
																					{
																						self.weaponmodel = "progs/v_shot3.mdl";
																						self.weaponframe = 0;
																					}
																					//self.items = (self.items | 256);
																					//self.weapon = 1;
																				}
																				else
																				{
#endif
																				self.currentammo = 0.000000;
																				self.weaponmodel = "";
																				self.weaponframe = 0.000000;
#ifdef NEW_CLASS1
																				}
																				}
																				}
#endif
																			}
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if ( self.mtf_items & #MTFITEM_LIGHTGUN && self.current_weapon == 128 )
		self.weaponframe = 7;
	VWEPS_SetModel ();
	if (self.monster_type > 0)
		Monsterweapon_setmodel(self.monster_type, self.current_weapon);
};
void() TeamFortress_Spotlight = 
{
//	if (self.playerclass != 2)  // Let everyone see with the spot light.. -arg
//	{
//		return;
//	}
	if (self.option2 == 0)
	{
		self.option2 = 1;
	}
	else
	{
		self.option2 = 0;
	}
	self.impulse = 0;
};
void() UseSpecialSkill = 
{
	local vector src;
	self.impulse = 0;
	if (self.playerclass == 1)
	{
		self.impulse = 155;
	}
	else
	{
		if (self.playerclass == 2)
		{
			self.impulse = 174;
		}
		else
		{
			if (self.playerclass == 3)
			{
				self.impulse = 173;
			}
			else
			{
				if (self.playerclass == 4)
				{
					self.impulse = 170;
				}
				else
				{
					if (self.playerclass == 5)
					{
						self.impulse = 190;
					}
					else
					{
						if (self.playerclass == 6)
						{
							self.impulse = 3;
						}
						else
						{
							if (self.playerclass == 7)
							{
								self.impulse = 6;
							}
							else
							{
								if (self.playerclass == 8)
								{
									self.impulse = 177;
								}
								else
								{
									if (self.playerclass == 9)
									{
										self.impulse = 179;
									}
									else
									{
										if (self.playerclass == 0)
										{
											if (self.enemy == world)
											{
												src = self.origin + v_forward * 10;
												src_z = self.absmin_z + self.size_z * 0.7;
												traceline(src, src + v_forward * 2048, 0, self);
												if (trace_ent != world && trace_ent.origin != world.origin)
												{
													sprint3(self, 2, "Locked onto ", trace_ent.classname, "\n");
													self.enemy = trace_ent;
													self.camdist = vlen(self.enemy.origin - self.origin);
													self.camangle = self.origin - self.enemy.origin;
													self.camangle_z = 0 - self.camangle_z;
													self.camangle = vectoangles(self.camangle);
												}
											}
											else
											{
												sprint(self, 2, "Removed lock.\n");
												self.enemy = world;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
void (float _p_10136) TeamFortress_ItemStatus =
{
	local entity _l_10137;
	local entity _l_10138;
	local float _l_10139;
	_l_10139 = 0.000000;
	if ((_p_10136 >= 10.000000))
	{
		_l_10139 = 1.000000;
		_p_10136 = _p_10136 - 10.000000;
	}
	if ((_p_10136 == 0.000000))
	{
		_p_10136 = self.team_no;
	}
	else
	{
		if ((self.team_no == 1.000000))
		{
			_p_10136 = 2.000000;
		}
		else
		{
			_p_10136 = 1.000000;
		}
	}
	_l_10137 = find (world, classname, "item_tfgoal");
	while (_l_10137)
	{
		if ((_l_10137.owned_by == _p_10136))
		{
			_l_10138 = _l_10137;
		}
		_l_10137 = find (_l_10137, classname, "item_tfgoal");
	}
	if ((((((_l_10138 != world) && (_l_10138.owner == world)) && (_l_10138.think == tfgoalitem_remove)) && ((_l_10138.nextthink - time) > 0.000000)) && (_l_10138.origin != _l_10138.oldorigin)))
	{
		if (_l_10139)
		{
			stuffcmd (self, "say_team ");
			stuffcmd (self, _l_10138.netname);
			stuffcmd (self, " returns in ");
			stuffcmd (self, ftos (rint ((_l_10138.nextthink - time))));
			stuffcmd (self, " seconds.\n");
		}
		else
		{
			sprint (self, 2.000000, _l_10138.netname);
			sprint (self, 2.000000, " returns in ");
			ftos (rint ((_l_10138.nextthink - time)));
			sprint (self, 2.000000, ftos (rint ((_l_10138.nextthink - time))));
			sprint (self, 2.000000, " seconds.\n");
		}
		return;
	}
	if ((((((_l_10138 != world) && (_l_10138.owner == world)) && (_l_10138.think == tfgoalitem_dropthink)) && ((_l_10138.nextthink - time) > 0.000000)) && (_l_10138.origin != _l_10138.oldorigin)))
	{
		if (_l_10139)
		{
			stuffcmd (self, "say_team ");
			stuffcmd (self, _l_10138.netname);
			stuffcmd (self, " has been dropped.\n");
		}
		else
		{
			sprint (self, 2.000000, _l_10138.netname);
			sprint (self, 2.000000, " has been dropped.\n");
		}
		return;
	}
	if (((_l_10138.origin == _l_10138.oldorigin) && (_l_10138.owner == world)))
	{
		if (_l_10139)
		{
			stuffcmd (self, "say_team ");
			stuffcmd (self, _l_10138.netname);
			stuffcmd (self, " is on its post.\n");
		}
		else
		{
			sprint (self, 2.000000, _l_10138.netname);
			sprint (self, 2.000000, " is on its post.\n");
		}
		return;
	}
	if ((_l_10138.owner != world))
	{
		if (_l_10139)
		{
			stuffcmd (self, "say_team ");
			stuffcmd (self, _l_10138.netname);
			stuffcmd (self, " is being carried.\n");
		}
		else
		{
			sprint (self, 2.000000, _l_10138.netname);
			sprint (self, 2.000000, " is being carried.\n");
		}
		return;
	}
};
void () TeamFortress_Inventory =
{
	local entity _l_10154;
	local float _l_10155;
	local string _l_10199;
	local entity _l_10156;
	local string _l_10157;
	local string _l_10159;
	sprint (self, 2.000000, "You're on the ");
	_l_10157 = ftos (self.team_no);
	if ((_l_10157 == "1"))
	{
		sprint (self, 2.000000, "BLUE");
	}
	if ((_l_10157 == "2"))
	{
		sprint (self, 2.000000, "RED");
	}
	if ((_l_10157 == "3"))
	{
		sprint (self, 2.000000, "YELLOW");
	}
	if ((_l_10157 == "4"))
	{
		sprint (self, 2.000000, "GREEN");
	}
	sprint (self, 2.000000, " team.\n");
	if ((self.lives != -1.000000))
	{
		_l_10157 = ftos (self.lives);
		sprint (self, 2.000000, "You've got ");
		sprint (self, 2.000000, _l_10157);
		if ((self.lives == 1.000000))
		{
			sprint (self, 2.000000, " life.\n");
		}
		else
		{
			sprint (self, 2.000000, " lives.\n");
		}
	}
	if ((self.no_grenades_1 > 0.000000))
	{
		sprint (self, 2.000000, "[");
		_l_10157 = ftos (self.no_grenades_1);
		sprint (self, 2.000000, _l_10157);
		sprint (self, 2.000000, "]");
		if ((self.tp_grenades_1 == 1.000000))
		{
			sprint (self, 2.000000, "normal grenade");
		}
		else
		{
			if ((self.tp_grenades_1 == 2.000000))
			{
				sprint (self, 2.000000, "concussion grenade");
			}
			else
			{
				if ((self.tp_grenades_1 == 3.000000))
				{
					sprint (self, 2.000000, "nail grenade");
				}
				else
				{
					if ((self.tp_grenades_1 == 4.000000))
					{
						sprint (self, 2.000000, "MIRV grenade");
					}
					else
					{
						if ((self.tp_grenades_1 == 5.000000))
						{
							sprint (self, 2.000000, "napalm grenade");
						}
						else
						{
							if ((self.tp_grenades_1 == 6.000000))
							{
								sprint (self, 2.000000, "flare");
							}
							else
							{
								if ((self.tp_grenades_1 == 7.000000))
								{
									sprint (self, 2.000000, "hallucinogenic grenade");
								}
								else
								{
									if ((self.tp_grenades_1 == 8.000000))
									{
										sprint (self, 2.000000, "EMP grenade");
									}
									else
									{
										if ((self.tp_grenades_1 == 9.000000))
										{
											sprint (self, 2.000000, "flash grenade");
										}
										else
										{
											sprint (self, 2.000000, "BUG(");
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((_l_10157 != "1"))
		{
			sprint (self, 2.000000, "s");
		}
		sprint (self, 2.000000, ".\n");
	}
	if ((self.no_grenades_2 > 0.000000))
	{
		sprint (self, 2.000000, "[ ");
		_l_10157 = ftos (self.no_grenades_2);
		sprint (self, 2.000000, _l_10157);
		sprint (self, 2.000000, " ]");
		if ((self.tp_grenades_2 == 1.000000))
		{
			sprint (self, 2.000000, "normal grenade");
		}
		else
		{
			if ((self.tp_grenades_2 == 2.000000))
			{
				sprint (self, 2.000000, "concussion grenade");
			}
			else
			{
				if ((self.tp_grenades_2 == 3.000000))
				{
					sprint (self, 2.000000, "nail grenade");
				}
				else
				{
					if ((self.tp_grenades_2 == 4.000000))
					{
						sprint (self, 2.000000, "MIRV grenade");
					}
					else
					{
						if ((self.tp_grenades_2 == 5.000000))
						{
							sprint (self, 2.000000, "napalm grenade");
						}
						else
						{
							if ((self.tp_grenades_2 == 6.000000))
							{
								sprint (self, 2.000000, "flare");
							}
							else
							{
								if ((self.tp_grenades_2 == 7.000000))
								{
									sprint (self, 2.000000, "hallucinogenic grenade");
								}
								else
								{
									if ((self.tp_grenades_2 == 8.000000))
									{
										sprint (self, 2.000000, "EMP grenade");
									}
									else
									{
										if ((self.tp_grenades_2 == 9.000000))
										{
											sprint (self, 2.000000, "flash grenade");
										}
										else
										{
											sprint (self, 2.000000, "BUG(");
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((_l_10157 != "1"))
		{
			sprint (self, 2.000000, "s");
		}
		sprint (self, 2.000000, ".\n");
	}
	_l_10154 = find (world, classname, "drop1");
	while (_l_10154)
	{
		if ((_l_10154.owner == self))
		{
			_l_10155 = _l_10155 + 1.000000;
		}
		_l_10154 = find (_l_10154, classname, "drop1");
	}
	if ((self.playerclass == 1.000000))
	{
		_l_10155 = 1.000000 - _l_10155;
		if ((_l_10155 <= 0.000000))
		{
			_l_10159 = "";
		}
		else
		{
			_l_10159 = "Flash Mine";
		}
	}
	if ((self.playerclass == 2.000000))
	{
		_l_10159 = "used alarm";
	}
	else
	{
		if (((self.playerclass == 3.000000) || (self.playerclass == 6.000000)))
		{
			_l_10155 = 2.000000 - _l_10155;
			_l_10159 = "Spike Trap";
		}
		else
		{
			if ((self.playerclass == 5.000000))
			{
				_l_10155 = 1.000000 - _l_10155;
				_l_10159 = "Syringe";
			}
			else
			{
				if ((self.playerclass == 7.000000))
				{
					_l_10155 = 1.000000 - _l_10155;
					_l_10159 = "Lava Pool";
				}
				else
				{
					if ((self.playerclass == 8.000000))
					{
						_l_10155 = 1.000000 - _l_10155;
						_l_10159 = "Ammo Trap";
					}
					else
					{
						if ((self.playerclass == 9.000000))
						{
							_l_10155 = 1.000000 - _l_10155;
							_l_10159 = "MagMine";
						}
					}
				}
			}
		}
	}
	if (_l_10155)
	{
		if ((_l_10155 <= 0.000000))
		{
			return;
		}
		if (!((self.playerclass == 7.000000) && (self.has_syringe == 0.000000)))
		{
			_l_10157 = ftos (_l_10155);
			sprint (self, 2.000000, _l_10157);
			sprint (self, 2.000000, " ", _l_10159);
			if ((_l_10155 > 1.000000))
			{
				sprint (self, 2.000000, "s. ");
			}
			else
			{
				sprint (self, 2.000000, ". ");
			}
		}
	}
	if ((self.playerclass == 9.000000))
	{
		if ((self.option3 > 0.000000))
		{
			if ((self.last_used <= time))
			{
				sprint (self, 2.000000, "1 LaserDrone. ");
			}
		}
	}
	if ((self.tf_items & 1.000000))
	{
		sprint (self, 2.000000, "Scanner. ");
	}
	if ((self.weapons_carried & 131072.000000))
	{
		if ((self.ammo_detpack > 0.000000))
		{
			_l_10157 = ftos (self.ammo_detpack);
			sprint (self, 2.000000, _l_10157);
			sprint (self, 2.000000, " Detpack");
			if ((self.ammo_detpack > 1.000000))
			{
				sprint (self, 2.000000, "s");
			}
			sprint (self, 2.000000, ". ");
		}
	}
	_l_10156 = find (world, classname, "item_tfgoal");
	while (_l_10156)
	{
		if ((_l_10156.owner == self))
		{
			sprint (self, 2.000000, _l_10156.netname);
			sprint (self, 2.000000, ". ");
		}
		_l_10156 = find (_l_10156, classname, "item_tfgoal");
	}
	if ((self.armorvalue > 0.000000))
	{
		TeamFortress_DescribeArmor (self, self.armorclass);
	}
	if (!invis_only)
	{
		if (((self.playerclass == 8.000000) && (invis_only == 0.000000)))
		{
			sprint (self, 2.000000, "Skin : ");
			if ((self.undercover_skin != 0.000000))
			{
				TeamFortress_PrintClassName (self, self.undercover_skin, 0.000000, 0);
			}
			else
			{
				sprint (self, 2.000000, "Spy\n");
			}
			sprint (self, 2.000000, "Colors : Team ");
			if ((self.undercover_team != 0.000000))
			{
				_l_10157 = ftos (self.undercover_team);
			}
			else
			{
				_l_10157 = ftos (self.team_no);
			}
			sprint (self, 2.000000, _l_10157);
		}
	}
	sprint (self, 2.000000, "\n");
	if ((self.pk_turretammo >= 0))
	{
	_l_10199 =ftos (self.pk_turretammo);
	sprint (self, 2.000000, _l_10199 );
	sprint (self, 2.000000, " turret autosentries.\n");
	}
	if ((self.pk_beartrapammo >= 0))
	{
	_l_10199 = ftos (self.pk_beartrapammo);
	sprint (self, 2.000000, _l_10199 );
	sprint (self, 2.000000, " bear traps.\n");
	}
	if ((self.pk_gravitywellammo >= 0))
	{
	_l_10199 = ftos (self.pk_gravitywellammo);
	sprint (self, 2.000000,_l_10199 );
	sprint (self, 2.000000, " gravity well bombs.\n");
	}
	if (self.pk_gravitywellammo >= 0)
	{
	_l_10199 =  ftos (self.pk_canpabammo);
	sprint (self, 2.000000, _l_10199);
	sprint (self, 2.000000, " can of Pork and Beans.\n");
	}
};
float (string st, float ft) ShowTF_PrintCR =
{
	local string _l_10200;
	if ((ft == 0.000000))
	{
		return (0.000000);
	}
	else
	{
		if ((ft == -1.000000))
		{
			sprint (self, 2.000000, st, "disabled\n");
		}
		else
		{
			_l_10200 = ftos (ft);
			sprint (self, 2.000000, st, _l_10200, "\n");
		}
	}
	return (1.000000);
};
void () TeamFortress_ShowTF =
{
	local string _l_10203;
	local float _l_10205;
	sprint (self, 2.000000, "ÔåáíÆïòôòåóó Óåôôéîçóº\n\n");
	if ((toggleflags & 1.000000))
	{
		sprint (self, 2.000000, "   Class Persistence On.\n");
	}
	else
	{
		sprint (self, 2.000000, "   Class Persistence Off.\n");
	}
	if ((toggleflags & 64.000000))
	{
		sprint (self, 2.000000, "   AutoTeam On.\n");
	}
	else
	{
		sprint (self, 2.000000, "   AutoTeam Off.\n");
	}
	sprint (self, 2.000000, "   ");
	if ((toggleflags & 4.000000))
	{
		_l_10203 = ftos (respawn_delay_time);
	}
	else
	{
		_l_10203 = "No";
	}
	sprint (self, 2.000000, _l_10203);
	if ((_l_10203 != "No"))
	{
		sprint (self, 2.000000, " second");
	}
	sprint (self, 2.000000, " Respawn Delay.\n");
	if ((toggleflags & 128.000000))
	{
		sprint (self, 2.000000, "   TeamFrags On.\n");
	}
	else
	{
		sprint (self, 2.000000, "   TeamFrags Off.\n");
	}
	if (allow_hook)
	{
		sprint (self, 2.000000, "   Grapple On.\n");
	}
	else
	{
		sprint (self, 2.000000, "   Grapple Off.\n");
	}
	ReCheckRestrictions ();
	sprint (self, 2.000000, "\n\n RESTRICTIONS \n\n");
	_l_10205 = 0.000000;
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Scout   : ", cr_scout);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Sniper  : ", cr_sniper);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Soldier : ", cr_soldier);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Demoman : ", cr_demoman);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Medic   : ", cr_medic);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   HWGuy   : ", cr_hwguy);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Pyro    : ", cr_pyro);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Spy     : ", cr_spy);
	_l_10205 = _l_10205 + ShowTF_PrintCR ("   Engineer: ", cr_engineer);
	if (!_l_10205)
	{
		sprint (self, 2.000000, "   none set.\n");
	}
};
void () TeamFortress_PrimeGrenade =
{
	local float _l_10231;
	local string _l_10232;
	local string _l_10233;
	local entity _l_10234;
	local float adj_gren2;
	adj_gren2 = sr_gren2;
	if (self.playerclass == 8)
		adj_gren2 = 1;
	if ((self.bugger == 8.000000))
	{
		return;
	}
	if (((self.tfstate & 1.000000) || (self.tfstate & 1024.000000)))
	{
		return;
	}
	if ((self.impulse == 150.000000))
	{
		_l_10231 = self.tp_grenades_1;
		if ((self.tp_grenades_1 == 2.000000))
		{
			_l_10232 = "Concussion grenade";
		}
		else
		{
			if ((self.tp_grenades_1 == 3.000000))
			{
				_l_10232 = "Nail grenade";
			}
			else
			{
				if ((self.tp_grenades_1 == 4.000000))
				{
					_l_10232 = "Mirv grenade";
				}
				else
				{
					if ((self.tp_grenades_1 == 5.000000))
					{
						_l_10232 = "Napalm grenade";
					}
					else
					{
						if ((self.tp_grenades_1 == 6.000000))
						{
							_l_10232 = "Flare";
						}
						else
						{
							if ((self.tp_grenades_1 == 7.000000))
							{
								_l_10232 = "Gas grenade";
							}
							else
							{
								if ((self.tp_grenades_1 == 8.000000))
								{
									_l_10232 = "EMP grenade";
								}
								else
								{
									if ((self.tp_grenades_1 == 9.000000))
									{
										_l_10232 = "Flash grenade";
									}
									else
									{
										_l_10232 = "Grenade";
									}
								}
							}
						}
					}
				}
			}
		}
		if ((self.active_grenades_1 < 0.000000))
		{
			self.active_grenades_1 = 0.000000;
		}
		if ((self.no_grenades_1 > 0.000000))
		{
			if ((self.active_grenades_1 < sr_gren1))
			{
				sound (self, 1.000000, "weapons/prime.wav", 1.000000, 1.000000);
				_l_10233 = ftos (3.000000);
				sprint (self, 2.000000, _l_10232);
				sprint (self, 2.000000, " primed, ");
				sprint (self, 2.000000, _l_10233);
				sprint (self, 2.000000, " seconds...\n");
				self.no_grenades_1 = (self.no_grenades_1 - 1.000000);
				self.active_grenades_1 = (self.active_grenades_1 + 1.000000);
				if ((self.tp_grenades_1 == 1.000000))
				{
					Stats_Fired (666.000000);
				}
				self.StatusRefreshTime = (time + 0.100000);
			}
			else
			{
				sound (self, 1.000000, "player/pain2.wav", 1.000000, 1.000000);
				sprint (self, 2.000000, "Your arthritic priming hand is taking a break.\n");
				return;
			}
		}
		else
		{
			sprint (self, 2.000000, "No ");
			sprint (self, 2.000000, _l_10232);
			sprint (self, 2.000000, "s left.\n");
			return;
		}
	}
	if ((self.impulse == 151.000000))
	{
		_l_10231 = self.tp_grenades_2;
		if ((self.tp_grenades_2 == 2.000000))
		{
			_l_10232 = "Concussion grenade";
		}
		else
		{
			if ((self.tp_grenades_2 == 3.000000))
			{
				_l_10232 = "Nail grenade";
			}
			else
			{
				if ((self.tp_grenades_2 == 4.000000))
				{
					_l_10232 = "Mirv grenade";
				}
				else
				{
					if ((self.tp_grenades_2 == 5.000000))
					{
						_l_10232 = "Napalm grenade";
					}
					else
					{
						if ((self.tp_grenades_2 == 6.000000))
						{
							_l_10232 = "Flare";
						}
						else
						{
							if ((self.tp_grenades_2 == 7.000000))
							{
								_l_10232 = "Gas grenade";
							}
							else
							{
								if ((self.tp_grenades_2 == 8.000000))
								{
									_l_10232 = "EMP grenade";
								}
								else
								{
									if ((self.tp_grenades_2 == 9.000000))
									{
										_l_10232 = "Flash grenade";
									}
									else
									{
										_l_10232 = "Grenade";
									}
								}
							}
						}
					}
				}
			}
		}
		if ((self.no_grenades_2 > 0.000000))
		{
			if ((self.active_grenades_2 < 0.000000))
			{
				self.active_grenades_2 = 0.000000;
			}
			if ((rint (self.active_grenades_2) < adj_gren2))
			{
				sound (self, 1.000000, "weapons/prime.wav", 1.000000, 1.000000);
				_l_10233 = ftos (3.000000);
				sprint (self, 2.000000, _l_10232);
				sprint (self, 2.000000, " primed, ");
				sprint (self, 2.000000, _l_10233);
				sprint (self, 2.000000, " seconds...\n");
				self.no_grenades_2 = (self.no_grenades_2 - 1.000000);
				self.active_grenades_2 = (self.active_grenades_2 + 1.000000);
				self.StatusRefreshTime = (time + 0.100000);
			}
			else
			{
				sound (self, 1.000000, "player/pain2.wav", 1.000000, 1.000000);
				sprint (self, 2.000000, "Your arthritic priming hand is taking a break.\n");
				return;
			}
		}
		else
		{
			sprint (self, 2.000000, "No ");
			sprint (self, 2.000000, _l_10232);
			sprint (self, 2.000000, "s left.\n");
			return;
		}
	}
	self.tfstate = (self.tfstate | 1.000000);
	_l_10234 = spawn ();
	_l_10234.real_owner = self;
	_l_10234.owner = self;
	_l_10234.weapon = _l_10231;
	_l_10234.nextthink = (time + 0.800000);
	_l_10234.heat = (time + 3.800000);
	_l_10234.classname = "GrenadeTimer";
	_l_10234.think = TeamFortress_GrenadePrimed;
	CSQC_SendGrenTimer(self);
};
void () TeamFortress_GrenadePrimed =
{
	local entity _l_10249;
	local entity _l_10250;
	local entity _l_10251;
	local float _l_10252;
	if (self.owner != self.real_owner)
	{
		bprint( 2, "TeamFortress_GrenadePrimed: self.owner does not match self.real_owner - SHOW THIS TO DEV\n");
		self.owner = self.real_owner;
	}
	_l_10249 = self.owner;
	if ((!(_l_10249.tfstate & 1024.000000) && !_l_10249.deadflag))
	{
		self.nextthink = (time + 0.100000);
		if (!self.think)
		{
			bprint(2,"TeamFortress_GrenadePrimed: GREN LOGIC FAIL # 1 TELL DEV.\n");
			dremove (self);
		}
		if ((time > self.heat))
		{
			TeamFortress_ExplodePerson ();
		}
		return;
	}
	if (!(_l_10249.tfstate & 1.000000))
	{
		dprint ("GrenadePrimed logic error\n");
	}
	_l_10249.tfstate = (_l_10249.tfstate - (_l_10249.tfstate & 1.000000));
	_l_10249.tfstate = (_l_10249.tfstate - (_l_10249.tfstate & 1024.000000));
	KickPlayer (-1.000000, _l_10249);
	newmis = spawn ();
	newmis.owner = _l_10249;
	newmis.movetype = 10.000000;
	newmis.solid = 2.000000;
	newmis.classname = "grenade";
	makevectors (_l_10249.v_angle);
	if (_l_10249.deadflag)
	{
		newmis.velocity = '0.000000 0.000000 200.000000';
	}
	else
	{
		if (_l_10249.v_angle_x)
		{
			newmis.velocity = ((((v_forward * 600.000000) + (v_up * 200.000000)) + ((crandom () * v_right) * 10.000000)) + ((crandom () * v_up) * 10.000000));
		}
		else
		{
			newmis.velocity = aim (_l_10249, 10000.000000);
			newmis.velocity = (newmis.velocity * 600.000000);
			newmis.velocity_z = 200.000000;
		}
	}
	newmis.angles = vectoangles (newmis.velocity);
	newmis.think = SUB_Null;
	newmis.nextthink = self.heat;
	if ((self.weapon == 1.000000))
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = NormalGrenadeExplode;
		newmis.skin = 0.000000;
		newmis.avelocity = '300.000000 500.000000 300.000000';
		setmodel (newmis, #MODEL_HGREN2);
	}
	else
	{
		if ((self.weapon == 2.000000))
		{
			newmis.touch = ConcussionGrenadeTouch;
			newmis.think = ConcussionGrenadeExplode;
			newmis.skin = 1.000000;
			newmis.avelocity = '300.000000 300.000000 300.000000';
			newmis.skin = 1.000000;
			setmodel (newmis, #MODEL_HGREN2);
		}
		else
		{
			if ((self.weapon == 3.000000))
			{
				newmis.touch = NailGrenadeTouch;
				newmis.think = NailGrenadeExplode;
				newmis.skin = 1.000000;
				newmis.avelocity = '0.000000 300.000000 0.000000';
				setmodel (newmis, "progs/biggren.mdl");
			}
			else
			{
				if ((self.weapon == 4.000000))
				{
					newmis.touch = MirvGrenadeTouch;
					newmis.think = MirvGrenadeExplode;
					newmis.skin = 0.000000;
					newmis.avelocity = '0.000000 300.000000 0.000000';
					setmodel (newmis, "progs/biggren.mdl");
				}
				else
				{
					if ((self.weapon == 5.000000))
					{
						newmis.touch = NapalmGrenadeTouch;
						newmis.think = NapalmGrenadeExplode;
						newmis.skin = 2.000000;
						newmis.playerclass = 0.000000;
						newmis.avelocity = '0.000000 300.000000 0.000000';
						setmodel (newmis, "progs/biggren.mdl");
					}
					else
					{
						if ((self.weapon == 6.000000))
						{
							newmis.classname = "flare";
							_l_10252 = 0.000000;
							_l_10250 = find (world, classname, "flare");
							while (_l_10250)
							{
								_l_10252 = _l_10252 + 1.000000;
								_l_10250 = find (_l_10250, classname, "flare");
							}
							if ((_l_10252 > 9.000000))
							{
								dremove (newmis);
							}
							newmis.movetype = 5.000000;
							newmis.velocity_z = 0.000000;
							newmis.velocity = aim (self, 10000.000000);
							newmis.velocity = (newmis.velocity * 1300.000000);
							newmis.touch = FlareGrenadeTouch;
							newmis.think = FlareGrenadeExplode;
							newmis.skin = 1.000000;
							newmis.avelocity = '0.000000 0.000000 0.000000';
							setmodel (newmis, "progs/flare.mdl");
							newmis.solid = 1.000000;
						}
						else
						{
							if ((self.weapon == 7.000000))
							{
								newmis.touch = GasGrenadeTouch;
								newmis.think = GasGrenadeExplode;
								newmis.skin = 3.000000;
								newmis.avelocity = '300.000000 300.000000 300.000000';
#ifdef mtf_coop_tgiving
								setmodel (newmis, "progs/duck1.mdl");
#else								
								setmodel (newmis, "progs/grenade2.mdl");
#endif
							}
							else
							{
								if ((self.weapon == 8.000000))
								{
									newmis.touch = EMPGrenadeTouch;
									newmis.think = EMPGrenadeExplode;
									newmis.skin = 4.000000;
									newmis.avelocity = '300.000000 300.000000 300.000000';
									setmodel (newmis, "progs/grenade2.mdl");
								}
								else
								{
									if ((self.weapon == 9.000000))
									{
										newmis.touch = FlashGrenadeTouch;
										newmis.think = FlashGrenadeExplode;
										newmis.skin = 2.000000;
										newmis.avelocity = '300.000000 300.000000 300.000000';
										setmodel (newmis, #MODEL_HGREN2);
									}
								}
							}
						}
					}
				}
			}
		}
	}
	setsize (newmis, '0.000000 0.000000 0.000000', '1.000000 1.000000 1.000000');
	setorigin (newmis, _l_10249.origin);
	_l_10251 = self;
	self = self.owner;
	self = _l_10251;
	dremove (self);
};
void() TeamFortress_ThrowGrenade = 
{
	if (!(self.tfstate & 1))
	{
		return;
	}
	sound(self, 3, "weapons/throw.wav", 1, 1);
	self.tfstate = self.tfstate | 1024;
};
void() TeamFortress_SetHealth = 
{
	if (self.playerclass == 1)
	{
		self.max_health = 100;
	}
	else
	{
		if (self.playerclass == 2)
		{
			self.max_health = 120;
		}
		else
		{
			if (self.playerclass == 3)
			{
				self.max_health = 100;
			}
			else
			{
				if (self.playerclass == 4)
				{
					self.max_health = 120;
				}
				else
				{
					if (self.playerclass == 5)
					{
						self.max_health = 120;
					}
					else
					{
						if (self.playerclass == 6)
						{
							self.max_health = 100;
						}
						else
						{
							if (self.playerclass == 7)
							{
								self.max_health = 100;
							}
							else
							{
								if (self.playerclass == 11)
								{
									self.max_health = 50;
								}
								else
								{
									if (self.playerclass == 8)
									{
										self.max_health = 90;
									}
									else
									{
										if (self.playerclass == 9)
										{
											self.max_health = 80;
										}
										else
										{
											if (self.playerclass == 0)
											{
												self.max_health = 1;
												self.takedamage = 0;
											}
#ifdef NEW_CLASS1
											else
											{
												if (self.playerclass == #CLASS_SPECOP)
												{
													self.max_health = 100;
												}
											}
#endif
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	self.max_health = ceil( self.max_health * MTF_Coop_AttribGain(self, #ATTRIB_HEALTH) );
	self.health = self.max_health;
};
void () TeamFortress_SetEquipment =
{
	local entity te;
	local entity _l_10351;
	local string st;
	local float kept_items;
	if ((self.classname != "player"))
	{
		return;
	}
	kept_items = self.tf_items & 393216.000000;
	self.items = 0.000000;
	self.current_weapon = 0.000000;
	self.weapons_carried = 0.000000;
	self.tf_items = 0.000000;
	self.tf_items_flags = 0.000000;
	self.armorclass = 0.000000;
	self.impulse = 0.000000;
	self.undercover_skin = 0.000000;
	stuffcmd (self, "fov 90\n");
	if ((self.undercover_team != 0.000000))
	{
		self.immune_to_check = (time + 5.000000);
		self.undercover_team = 0.000000;
		stuffcmd (self, "color ");
		st = ftos ((TeamFortress_TeamGetColor (self.team_no) - 1.000000));
		stuffcmd (self, st);
		stuffcmd (self, "\n");
	}
	self.is_building = 0.000000;
	self.is_detpacking = 0.000000;
	self.is_undercover = 0.000000;
	self.is_feigning = 0.000000;
	self.is_unabletospy = 0.000000;
	self.ammo_medikit = 0.000000;
	self.maxammo_medikit = 0.000000;
	self.ammo_detpack = 0.000000;
	self.maxammo_detpack = 0.000000;
	self.items_allowed = 0.000000;
	self.armor_allowed = 0.000000;
	self.maxarmor = 0.000000;
	self.weaponmode = 0.000000;
	self.respawn_time = 0.000000;
	self.heat = 0.000000;
	self.tfstate = (self.tfstate - (self.tfstate & 2.000000));
	_l_10351 = find (world,classname,"GrenadeTimer");
	while (_l_10351)
	{
		if ((_l_10351.owner == self))
		{
			dremove (_l_10351);
		}
		_l_10351 = find (_l_10351, classname, "GrenadeTimer");
	}
	if ((self.team_no == 0.000000))
	{
		self.lives = -1.000000;
	}
	self.items = (self.items | kept_items);
	if (self.playerclass == 1)
	{
		self.weapons_carried = (self.weapons_carried | 656.000000);
		self.ammo_rockets = 0.000000;
		self.ammo_nails = 100.000000;
		self.ammo_shells = 25.000000;
		self.ammo_cells = 50.000000;
		self.maxammo_rockets = 25.000000;
		self.maxammo_nails = 200.000000;
		self.maxammo_shells = 50.000000;
		self.maxammo_cells = 100.000000;
		COOP_GetMaxGrensForClass (self.playerclass);
		self.tp_grenades_1 = 9.000000;
		self.tp_grenades_2 = 2.000000;
		self.tf_items = 1.000000;
		self.tf_items_flags = (self.tf_items_flags | 1.000000);
		self.armorclass = (self.armorclass | 0.000000);
		self.armortype = 0.300000;
		self.armorvalue = 25.000000;
		self.armor_allowed = 0.300000;
		self.maxarmor = 50.000000;
		self.current_weapon = 512.000000;
		self.items_allowed = 656.000000;
		self.items = (self.items | 5.000000);
	}
	else
	{
		if (self.playerclass == 2)
		{
			self.weapons_carried = (self.weapons_carried | 624.000000);
			self.ammo_rockets = 0.000000;
			self.ammo_nails = 50.000000;
			self.ammo_shells = 60.000000;
			self.ammo_cells = 25.000000;
			self.maxammo_rockets = 25.000000;
			self.maxammo_nails = 100.000000;
			self.maxammo_shells = 75.000000;
			self.maxammo_cells = 50.000000;
			COOP_GetMaxGrensForClass (self.playerclass);
			self.tp_grenades_1 = 1.000000;
			self.tp_grenades_2 = 6.000000;
			self.tf_items = 0.000000;
			self.armorclass = (self.armorclass | 0.000000);
			self.armortype = 0.300000;
			self.armorvalue = 0.000000;
			self.armor_allowed = 0.300000;
			self.maxarmor = 50.000000;
			self.current_weapon = 32.000000;
			self.items_allowed = 624.000000;
			self.items = (self.items | 7.000000);
		}
		else
		{
			if (self.playerclass == 3)
			{
				self.weapons_carried = (self.weapons_carried | 8592.000000);
				self.ammo_rockets = 25.000000;
				self.ammo_nails = 0.000000;
				self.ammo_shells = 50.000000;
				self.ammo_cells = 0.000000;
				self.maxammo_rockets = 50.000000;
				self.maxammo_nails = 100.000000;
				self.maxammo_shells = 100.000000;
				self.maxammo_cells = 50.000000;
				COOP_GetMaxGrensForClass (self.playerclass);
				self.tp_grenades_1 = 1.000000;
				self.tp_grenades_2 = 3.000000;
				self.tf_items = 0.000000;
				self.armorclass = (self.armorclass | 0.000000);
				self.armortype = 0.800000;
				self.armorvalue = 100.000000;
				self.armor_allowed = 0.800000;
				self.maxarmor = 200.000000;
				self.current_weapon = 8192.000000;
				self.items_allowed = 8592.000000;
				self.items = (self.items | 35.000000);
			}
			else
			{
				if (self.playerclass == 4)
				{
					self.weapons_carried = (self.weapons_carried | 133264.000000);
					self.ammo_rockets = 25.000000;
					self.ammo_nails = 0.000000;
					self.ammo_shells = 30.000000;
					self.ammo_cells = 0.000000;
					self.maxammo_rockets = 50.000000;
					self.maxammo_nails = 50.000000;
					self.maxammo_shells = 75.000000;
					self.maxammo_cells = 50.000000;
					COOP_GetMaxGrensForClass (self.playerclass);
					self.tp_grenades_1 = 1.000000;
					self.tp_grenades_2 = 4.000000;
					self.tf_items = 0.000000;
					self.ammo_detpack = 1.000000;
					self.maxammo_detpack = 1.000000;
					self.armorclass = (self.armorclass | 4.000000);
					self.armortype = 0.600000;
					self.armorvalue = 50.000000;
					self.armor_allowed = 0.600000;
					self.maxarmor = 100.000000;
					self.current_weapon = 2048.000000;
					self.items_allowed = 133264.000000;
					self.items = (self.items | 17.000000);
				}
				else
				{
					if (self.playerclass == 5)
					{
						self.weapons_carried = (self.weapons_carried | 1414.000000);
						self.ammo_rockets = 0.000000;
						self.ammo_nails = 150.000000;
						self.ammo_shells = 50.000000;
						self.ammo_cells = 0.000000;
						self.maxammo_rockets = 25.000000;
						self.maxammo_nails = 300;  //was 150, default was 300 -arg
						self.maxammo_shells = 75.000000;
						self.maxammo_cells = 60.000000;
						COOP_GetMaxGrensForClass (self.playerclass);
						self.tp_grenades_1 = 1.000000;
						self.tp_grenades_2 = 2.000000;
						self.tf_items = 0.000000;
						self.armorclass = (self.armorclass | 0.000000);
						self.armortype = 0.300000;
						self.armorvalue = 50.000000;
						self.armor_allowed = 0.600000;
						self.armortype = 0.800000;
						self.armorvalue = 75.000000;
						self.armor_allowed = 0.800000;
						self.maxarmor = 100.000000;
						self.current_weapon = 1024.000000;
						self.ammo_medikit = 200.000000;
						self.maxammo_medikit = 200.000000;
						te = spawn();
						te.nextthink = time + 2;
						te.think = TeamFortress_Regenerate;
						te.owner = self;
						te.classname = "timer";
						self.items_allowed = 2 | 4 | 128 | 256 | 1024;
						self.items = self.items | 1 | 2 | 8;
					}
					else
					{
						if (self.playerclass == 6)
						{
							self.weapons_carried = (self.weapons_carried | 33680.000000);
							self.ammo_rockets = 0.000000;
							self.ammo_nails = 100.000000;
							self.ammo_shells = 200.000000;
							self.ammo_cells = 24.000000;
							self.maxammo_rockets = 10.000000;
							self.maxammo_nails = 250.000000; //default was 250, was 125 -arg
							self.maxammo_shells = 250.000000;
							self.maxammo_cells = 50.000000;
							COOP_GetMaxGrensForClass (self.playerclass);
							self.tp_grenades_1 = 1.000000;
							self.tp_grenades_2 = 4.000000;
							self.tf_items = 0.000000;
							self.armorclass = (self.armorclass | 0.000000);
							self.armortype = 0.800000;
							self.armorvalue = 150.000000;
							self.armor_allowed = 0.800000;
							self.maxarmor = 300.000000;
							self.current_weapon = 32768.000000;
							self.items_allowed = 33680.000000;
							self.items = (self.items | 39.000000);
						}
						else
						{
							if (self.playerclass == 7)
							{
								self.weapons_carried = (self.weapons_carried | 20624.000000);
								self.ammo_rockets = 20.000000;
								self.ammo_nails = 0.000000;
								self.ammo_shells = 20.000000;
								self.ammo_cells = 150.000000;
								self.maxammo_rockets = 40.000000;
								self.maxammo_nails = 100.000000;
								self.maxammo_shells = 40.000000;
								self.maxammo_cells = 250.000000;
								COOP_GetMaxGrensForClass (self.playerclass);
								self.tp_grenades_1 = 1.000000;
								self.tp_grenades_2 = 5.000000;
								self.tf_items = 0.000000;
								self.armorclass = (self.armorclass | 16.000000);
								self.armortype = 0.500000;
								self.armorvalue = 70.000000;
								self.armor_allowed = 0.800000;
								self.maxarmor = 150.000000;
								self.current_weapon = 4096.000000;
								self.items_allowed = 20624.000000;
								self.items = (self.items | 49.000000);
							}
							else
							{
								if (self.playerclass == 11)
								{
									self.weapons_carried = (self.weapons_carried | 16.000000);
									self.ammo_rockets = 0.000000;
									self.ammo_nails = 0.000000;
									self.ammo_shells = 0.000000;
									self.ammo_cells = 0.000000;
									self.maxammo_rockets = 0.000000;
									self.maxammo_nails = 0.000000;
									self.maxammo_shells = 0.000000;
									self.maxammo_cells = 0.000000;
									COOP_GetMaxGrensForClass (self.playerclass);
									self.tp_grenades_1 = 0.000000;
									self.tp_grenades_2 = 0.000000;
									self.tf_items = 0.000000;
									self.armorclass = (self.armorclass | 0.000000);
									self.armortype = 0.000000;
									self.armorvalue = 0.000000;
									self.armor_allowed = 0.000000;
									self.maxarmor = 0.000000;
									self.current_weapon = 16.000000;
									self.items_allowed = 16.000000;
									self.items = 0.000000;
								}
								else
								{
									if (self.playerclass == 8)
									{
										self.weapons_carried = (self.weapons_carried | 262928.000000);
										self.ammo_rockets = 0.000000;
										self.ammo_nails = 25.000000;
										self.ammo_shells = 40.000000;
										self.ammo_cells = 30.000000;
										self.maxammo_rockets = 15.000000;
										self.maxammo_nails = 50.000000;
										self.maxammo_shells = 40.000000;
										self.maxammo_cells = 30.000000;
										COOP_GetMaxGrensForClass (self.playerclass);
										self.tp_grenades_1 = 1.000000;
										self.tp_grenades_2 = 7.000000;
										self.tf_items = 0.000000;
										if (spy_armor == 1)
										{
											self.armorclass = (self.armorclass | 4);
											self.armortype = 0.6;
											self.armorvalue = 25;
											self.armor_allowed = 0.6;
											self.maxarmor = 50;
										}
										else
										{
										self.armorclass = (self.armorclass | 0.000000);
										self.armortype = 0.300000;
										self.armorvalue = 25.000000;
										self.armor_allowed = 0.300000;
										self.maxarmor = 100.000000;
										}
										self.current_weapon = 262144.000000;
										self.items_allowed = 262928.000000;
										self.items = (self.items | 71.000000);
										if ((invis_only == 1.000000))
										{
											te = spawn();
											te.nextthink = time + 5;
											te.think = TeamFortress_RegenerateCells;
											te.owner = self;
											te.classname = "timer";
										}
									}
									else
									{
										if (self.playerclass == 9)
										{
											self.weapons_carried = (self.weapons_carried | 524552.000000);
											self.ammo_rockets = 0.000000;
											self.ammo_nails = 25.000000;
											self.ammo_shells = 20.000000;
											self.ammo_cells = 100.000000;
											self.maxammo_rockets = 30.000000;
											self.maxammo_nails = 50.000000;
											self.maxammo_shells = 50.000000;
											self.weapons_carried = (self.weapons_carried | #WEAP_ZEROGRAVITY);
											self.maxammo_cells = 450.000000;  //was 200, default 450 -arg
											COOP_GetMaxGrensForClass (self.playerclass);
											self.tp_grenades_1 = 1.000000;
											self.tp_grenades_2 = 8.000000;
											self.tf_items = 0.000000;
											self.armorclass = (self.armorclass | 0.000000);
											self.armortype = 0.300000;
											self.armorvalue = 25.000000;
											self.armor_allowed = 0.600000;
											self.maxarmor = 50.000000;
											self.current_weapon = 524288.000000;
											self.items_allowed = 524552.000000;
											self.items = (self.items | 3.000000);
											self.weaponmode = 1;
										}
										else
										{
											if (self.playerclass == 0)
											{
												self.items = 0;
												self.ammo_rockets = 0;
												self.ammo_nails = 0;
												self.ammo_shells = 0;
												self.ammo_cells = 0;
												COOP_GetMaxGrensForClass (self.playerclass);
												self.tp_grenades_1 = 0;
												self.tp_grenades_2 = 0;
												self.armorclass = 0;
												self.armortype = 0;
												self.armorvalue = 0;
												self.weapon = 0;
												self.current_weapon = 0;
												self.weapons_carried = 0;
												self.flags = 8 | 128;
												self.waterlevel = 3;
												self.takedamage = 0;
												self.solid = 0;
												self.movetype = 8;
												self.model = string_null;
												self.mdl = string_null;
												self.modelindex = 0;
												self.weaponmodel = string_null;
												modelindex_player = 0;
												self.tfstate = self.tfstate | 2;
												setmodel(self, string_null);
											}
#ifdef NEW_CLASS1
		else
		{
			if (self.playerclass == #CLASS_SPECOP)
			{
				self.weapons_carried = (self.weapons_carried | (16 + #WEAPON_THUMPER + #WEAPON_CROSSBOW));
				self.ammo_rockets = 0.000000;
				self.ammo_nails = 50.000000;
				self.ammo_shells = 60.000000;
				self.ammo_cells = 25.000000;
				self.maxammo_rockets = 25.000000;
				self.maxammo_nails = 100.000000;
				self.maxammo_shells = 75.000000;
				self.maxammo_cells = 50.000000;
				COOP_GetMaxGrensForClass (self.playerclass);
				self.tp_grenades_1 = 1.000000;
				self.tp_grenades_2 = 6.000000;
				self.tf_items = 0.000000;
				self.armorclass = (self.armorclass | 0.000000);
				self.armortype = 0.300000;
				self.armorvalue = 0.000000;
				self.armor_allowed = 0.300000;
				self.maxarmor = 50.000000;
				self.current_weapon = #WEAPON_THUMPER;
				self.items_allowed = 624.000000;
				self.items = (self.items | 7.000000);
			}
		}
#endif
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (self.playerclass != 0)
	{
		self.has_syringe = 1;
		self.has_holo = 1;
		self.option = 0;
		self.option4 = 0;
		self.option3 = 1;
		self.gravity = 1;
		if (exec_class)
		{
			if (self.playerclass == 1)
			{
				stuffcmd(self, "exec scout.cfg\n");
			}
			else
			{
				if (self.playerclass == 2)
				{
					stuffcmd(self, "exec sniper.cfg\n");
				}
				else
				{
					if (self.playerclass == 3)
					{
						stuffcmd(self, "exec soldier.cfg\n");
					}
					else
					{
						if (self.playerclass == 4)
						{
							stuffcmd(self, "exec demoman.cfg\n");
						}
						else
						{
							if (self.playerclass == 5)
							{
								stuffcmd(self, "exec medic.cfg\n");
							}
							else
							{
								if (self.playerclass == 6)
								{
									stuffcmd(self, "exec hwguy.cfg\n");
								}
								else
								{
									if (self.playerclass == 7)
									{
										stuffcmd(self, "exec pyro.cfg\n");
									}
									else
									{
										if (self.playerclass == 8)
										{
											stuffcmd(self, "exec spy.cfg\n");
										}
										else
										{
											if (self.playerclass == 9)
											{
												stuffcmd(self, "exec engineer.cfg\n");
											}
											else
											{
												if (self.playerclass == 11)
												{
													stuffcmd(self, "exec civilian.cfg\n");
												}
#ifdef NEW_CLASS1
												else
												{
													if (self.playerclass == #CLASS_SPECOP)
													{
														stuffcmd(self, "exec specop.cfg\n");
													}
												}
#endif
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((self.stats_on == 1))
		{
			stuffcmd (self, "exec progs/stats.cfg\n");
		}
	}
	else
	{
		self.has_syringe = 0;
	}
	self.vision = 0;
	self.gravity = 1;
	if (self.armortype >= 0.8)
	{
		self.items = self.items | 32768;
	}
	else
	{
		if (self.armortype >= 0.6)
		{
			self.items = self.items | 16384;
		}
		else
		{
			if (self.armortype >= 0.3)
			{
				self.items = self.items | 8192;
			}
		}
	}
	if (self.playerclass == 8)
	{
		self.weapons_carried = self.weapons_carried | 1;
		allow_hook = 1;
		st = infokey(world, "sg");
		if (st == string_null)
		{
			st = infokey(world, "spygrapple");
		}
		if (st == "off")
		{
			allow_hook = 0;
		}
	}
	if (self.playerclass != 0)
	{
		self.weapons_carried = self.weapons_carried | 16;
	}
		if (self.playerclass != 6)	// yeah that's right, hwguy
		{
			self.maxammo_shells *= 1.2;
		}
		self.maxammo_nails *= ceil(1.3);

		self.no_grenades_1 = COOP_GetMaxGrensForClass (self.playerclass);
		self.no_grenades_2 = COOP_GetMaxGrensForClass (self.playerclass);
		local float ammo_mult;
		if (self.ammo_attr > 0)
		{
			ammo_mult = MTF_Coop_AttribGain(self, #ATTRIB_AMMO);
			self.maxammo_shells *= ammo_mult;
			self.maxammo_nails *= ammo_mult;
			self.maxammo_cells *= ammo_mult;
			self.maxammo_rockets *= ammo_mult;
			self.no_grenades_1 = COOP_GetMaxGrensForClass (self.playerclass);
			self.no_grenades_2 = COOP_GetMaxGrensForClass (self.playerclass);
		}
		self.ammo_rockets = self.maxammo_rockets;
		self.ammo_nails = self.maxammo_nails;
		self.ammo_shells = self.maxammo_shells;
		self.ammo_cells = self.maxammo_cells;
		self.armorvalue = self.maxarmor;
		self.max_health = ceil( self.max_health * MTF_Coop_AttribGain(self, #ATTRIB_HEALTH) );
		self.health = self.max_health;
		self.maxarmor = ceil( self.maxarmor * MTF_Coop_AttribGain(self, #ATTRIB_ARMOR) );
		self.armorvalue = self.maxarmor;
		local float a1, bit;
		a1 = MTF_Coop_SetArmorAttrib(self, 2);
		if (a1 > self.armor_allowed)
		{
			self.armortype = a1;
			self.armor_allowed = a1;
			if (a1 < 0.8)
				bit = 16384;
			else
				bit = 32768;

			self.items = self.items - (self.items & (8192 | 16384 | 32768)) + bit;
		}
	W_SetCurrentAmmo();
};
void(entity Player, float Armorclass) TeamFortress_DescribeArmor = 
{
	if (Armorclass == 0)
	{
		return;
	}
	if (Armorclass & 16)
	{
		sprint(Player, 2, "Asbestos ");
	}
	if (Armorclass & 2)
	{
		sprint(Player, 2, "Wooden ");
	}
	if (Armorclass & 4)
	{
		sprint(Player, 2, "Blast ");
	}
	if (Armorclass & 8)
	{
		sprint(Player, 2, "Shockproof ");
	}
	if (Armorclass & 1)
	{
		sprint(Player, 2, "Kevlar ");
	}
	sprint(Player, 2, "armor\n");
};
float(entity Retriever, entity Items) TeamFortress_AddBackpackItems = 
{
	return 0;
};
void() TeamFortress_RemoveTimers = 
{
	local entity te;
	self.leg_damage = 0;
	self.is_undercover = 0;
	self.is_building = 0;
	self.building = world;
	if (self.tfstate & 2048)
	{
		self.tfstate = self.tfstate - 2048;
		TeamFortress_SetSpeed(self);
		self.heat = 0;
	}
	te = find(world, classname, "timer");
	while (te != world)
	{
		if (te.owner == self)
		{
			dremove(te);
			te = find(world, classname, "timer");
		}
		else
		{
			te = find(te, classname, "timer");
		}
	}
	te = find(world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == self)
		{
			if (!(te.goal_activation & 256))
			{
				mtf_tfgoalitem_RemoveFromPlayer(te, self, 0);
			}
			if (CTF_Map == 1 && te.goal_no == 1)
			{
				bprint(2, self.netname);
				bprint(2, " ÌÏÓÔ the ÂÌÕÅ flag!\n");
			}
			else
			{
				if (CTF_Map == 1 && te.goal_no == 2)
				{
					bprint(2, self.netname);
					bprint(2, " ÌÏÓÔ the ÒÅÄ flag!\n");
				}
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	te = find(world, classname, "detpack");
	while (te)
	{
		if (te.weaponmode == 1 && te.enemy == self)
		{
			te.weaponmode = 0;
		}
		te = find(te, classname, "detpack");
	}
	te = find(world, classname, "pipebomb");
	while (te != world)
	{
		if(te.owner == self)
		{
			decrement_team_pipebombs(self.team_no);
			deathmsg = te.weapon;
			te.weapon = 10;
			T_RadiusDamage(te, self, 120, world);
			WriteByte(4, 23);
			WriteByte(4, 3);
			WriteCoord(4, te.origin_x);
			WriteCoord(4, te.origin_y);
			WriteCoord(4, te.origin_z);
			multicast(te.origin, TF_FLARE_OFF);
			dremove(te);
		}
	te = find(te, classname, "pipebomb");
	}
	stuffcmd(self, "v_idlescale 0\n");
	stuffcmd(self, "v_cshift 0 0 0 0\n");
	self.item_list = 0;
	self.FlashTime = 0;
	CenterPrint(self, "\n");
	self.menu_count = 25;
	self.current_menu = 1;
	self.impulse = 0;
};
void(float Suicided) TeamFortress_SetupRespawn = 
{
	local float restime;
	local string db;
	if (self.respawn_time > time)
	{
		return;
	}
	if (toggleflags & 4)
	{
		restime = respawn_delay_time;
	}
	else
	{
		restime = respawn_delay_time + 1;
	}
	if (Suicided)
	{
		if (self.lives > 0)
		{
			self.lives = self.lives - 1;
		}
		restime = restime + 5;
	}
	if (self.lives > 0)
	{
		self.lives = self.lives - 1;
	}
	if (self.#lms_lives == -1)
	{
			sprint(self, 2, "NO lives left, returning to Observer mode.\n");
			self.playerclass = 0;
			self.tfstate = self.tfstate - (self.tfstate & 8);
			self.movetype = 8;
			self.solid = 0;
			self.model = "";
			self.mdl = "";
			self.velocity = '0 0 0';
			self.avelocity = '0 0 0';
			self.enemy = world;
			self.monster_items = 1;
			self.lives = -1;
			setmodel(self, "");
			return;
	}
	if (self.lives != -1)
	{
		if (self.lives == 0)
		{
			sprint(self, 2, "NO lives left, returning to Observer mode.\n");
			self.playerclass = 0;
			self.tfstate = self.tfstate - (self.tfstate & 8);
			self.movetype = 8;
			self.solid = 0;
			self.model = "";
			self.mdl = "";
			self.velocity = '0 0 0';
			self.avelocity = '0 0 0';
			self.enemy = world;
			setmodel(self, "");
			return;
		}
		if (self.lives == 1)
		{
			sprint(self, 2, "LAST life.\n");
		}
		else
		{
			db = ftos(self.lives);
			sprint(self, 2, db);
			sprint(self, 2, " lives left.\n");
		}
	}
	self.respawn_time = time + restime;
	if (restime > 3)
	{
		db = ftos(restime);
		sprint(self, 2, db);
		sprint(self, 2, " seconds till respawn.\n");
	}
};
void() TeamFortress_CheckClassStats = 
{
	if (self.armortype > self.armor_allowed)
	{
		self.armortype = self.armor_allowed;
	}
	if (self.armorvalue > self.maxarmor)
	{
		self.armorvalue = self.maxarmor;
	}
	if (self.armortype < 0)
	{
		self.armortype = 0;
	}
	if (self.armorvalue < 0)
	{
		self.armorvalue = 0;
	}
	if (self.ammo_shells > TeamFortress_GetMaxAmmo(self, 256))
	{
		self.ammo_shells = TeamFortress_GetMaxAmmo(self, 256);
	}
	if (self.ammo_shells < 0)
	{
		self.ammo_shells = 0;
	}
	if (self.ammo_nails > TeamFortress_GetMaxAmmo(self, 512))
	{
		self.ammo_nails = TeamFortress_GetMaxAmmo(self, 512);
	}
	if (self.ammo_nails < 0)
	{
		self.ammo_nails = 0;
	}
	if (self.ammo_rockets > TeamFortress_GetMaxAmmo(self, 1024))
	{
		self.ammo_rockets = TeamFortress_GetMaxAmmo(self, 1024);
	}
	if (self.ammo_rockets < 0)
	{
		self.ammo_rockets = 0;
	}
	if (self.ammo_cells > TeamFortress_GetMaxAmmo(self, 2048))
	{
		self.ammo_cells = TeamFortress_GetMaxAmmo(self, 2048);
	}
	if (self.ammo_cells < 0)
	{
		self.ammo_cells = 0;
	}
	if (self.ammo_medikit > TeamFortress_GetMaxAmmo(self, 4))
	{
		self.ammo_medikit = TeamFortress_GetMaxAmmo(self, 4);
	}
	if (self.ammo_medikit < 0)
	{
		self.ammo_medikit = 0;
	}
	if (self.ammo_detpack > TeamFortress_GetMaxAmmo(self, 131072))
	{
		self.ammo_detpack = TeamFortress_GetMaxAmmo(self, 131072);
	}
	if (self.ammo_detpack < 0)
	{
		self.ammo_detpack = 0;
	}
	if (self.no_grenades_1 < 0)
	{
		self.no_grenades_1 = 0;
	}
	if (self.no_grenades_2 < 0)
	{
		self.no_grenades_2 = 0;
	}
	if (self.health > self.max_health && !(self.items & 65536))
	{
	local float putz;
	putz = self.max_health - self.health;
		TF_T_Damage(self, world, world, putz, 0, 256);
	}
	if (self.health < 0)
	{
		T_Heal(self, self.health - self.health, 0);
	}
	self.items = self.items - (self.items & (8192 | 16384 | 32768));
	if (self.armortype >= 0.8)
	{
		self.items = self.items | 32768;
	}
	else
	{
		if (self.armortype >= 0.6)
		{
			self.items = self.items | 16384;
		}
		else
		{
			if (self.armortype >= 0.3)
			{
				self.items = self.items | 8192;
			}
		}
	}
};
void() TeamFortress_ExplodePerson = 
{
	local entity te;
	self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 1);
	KickPlayer(-2, self.owner);
	newmis = spawn();
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "grenade";
	newmis.team_no = self.owner.team_no;
	newmis.owner = self.owner;
	newmis.velocity = '0 0 0';
	newmis.angles = vectoangles(newmis.velocity);
	newmis.think = SUB_Null;
	newmis.nextthink = time + 0.1;
	if (self.weapon == 1)
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = NormalGrenadeExplode;
		newmis.skin = 0;
		newmis.avelocity = '300 300 300';
		setmodel(newmis, #MODEL_HGREN2);
	}
	else
	{
		if (self.weapon == 2)
		{
			newmis.touch = ConcussionGrenadeTouch;
			newmis.think = ConcussionGrenadeExplode;
			newmis.skin = 1;
			newmis.avelocity = '300 300 300';
			setmodel(newmis, #MODEL_HGREN2);
		}
		else
		{
			if (self.weapon == 3)
			{
				newmis.touch = NailGrenadeTouch;
				newmis.think = NailGrenadeExplode;
				newmis.skin = 1;
				newmis.avelocity = '0 300 0';
				setmodel(newmis, "progs/biggren.mdl");
			}
			else
			{
				if (self.weapon == 4)
				{
					newmis.touch = MirvGrenadeTouch;
					newmis.think = MirvGrenadeExplode;
					newmis.skin = 0;
					newmis.avelocity = '0 300 0';
					setmodel(newmis, "progs/biggren.mdl");
				}
				else
				{
					if (self.weapon == 5)
					{
						newmis.touch = NapalmGrenadeTouch;
						newmis.think = NapalmGrenadeExplode;
						newmis.skin = 2;
						newmis.avelocity = '0 300 0';
						setmodel(newmis, "progs/biggren.mdl");
					}
					else
					{
						if (self.weapon == 6)
						{
							sprint(self.owner, 2, "Flare lit.\n");
							te = spawn();
							te.touch = SUB_Null;
							te.think = RemoveFlare;
							te.nextthink = time + 25;
							te.owner = self.owner;
							te.solid = 0;
							self.owner.effects = self.owner.effects | 4;
							dremove(self);
							dremove(newmis);
							return;
						}
						else
						{
							if (self.weapon == 7)
							{
								newmis.touch = GasGrenadeTouch;
								newmis.think = GasGrenadeExplode;
								newmis.skin = 2;
								newmis.avelocity = '300 300 300';
								setmodel(newmis, "progs/grenade2.mdl");
							}
							else
							{
								if (self.weapon == 8)
								{
									newmis.touch = EMPGrenadeTouch;
									newmis.think = EMPGrenadeExplode;
									newmis.skin = 4;
									newmis.avelocity = '300 300 300';
									setmodel(newmis, "progs/grenade2.mdl");
								}
								else
								{
									if (self.weapon == 9)
									{
										newmis.touch = FlashGrenadeTouch;
										newmis.think = FlashGrenadeExplode;
										newmis.skin = 1;
										newmis.avelocity = '300 300 300';
										setmodel(newmis, "progs/grenade2.mdl");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	setsize(newmis, '0 0 0', '0 0 0');
	setorigin(newmis, self.owner.origin);
	bprint(1, "No, ");
	bprint(1, self.owner.netname);
	bprint(1, ", throw the grenade, not the pin!\n");
	dremove(self);
};
void() NormalGrenadeTouch = 
{
	if (other == self.owner)
	{
		return;
	}
	sound(self, 1, "weapons/bounce.wav", 1, 1);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
void() NormalGrenadeExplode = 
{
	deathmsg = 8;
	T_RadiusDamage(self, self.owner, 180, world);
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, 1);
	BecomeExplosion();
	self.owner.active_grenades_1 = (self.owner.active_grenades_1 - 1.000000);
	dremove(self);
};
void () TeamFortress_DisplayDetectionItems =
{
	local entity _l_10555;
	local entity _l_10556;
	_l_10555 = find (world, classname, "info_tfdetect");
	if (!_l_10555)
	{
		return;
	}
	if ((_l_10555.team_str_home == string_null))
	{
		return;
	}
	if ((_l_10555.display_item_status1 != 0.000000))
	{
		_l_10556 = Finditem (_l_10555.display_item_status1);
		if (_l_10556)
		{
			DisplayItemStatus (_l_10555, self, _l_10556);
		}
		else
		{
			sprint (self, 2.000000, "Item is missing.\n");
		}
	}
	else
	{
		return;
	}
	if ((_l_10555.display_item_status2 != 0.000000))
	{
		_l_10556 = Finditem (_l_10555.display_item_status2);
		if (_l_10556)
		{
			DisplayItemStatus (_l_10555, self, _l_10556);
		}
		else
		{
			sprint (self, 2.000000, "Item is missing.\n");
		}
	}
	else
	{
		return;
	}
	if ((_l_10555.display_item_status3 != 0.000000))
	{
		_l_10556 = Finditem (_l_10555.display_item_status3);
		if (_l_10556)
		{
			DisplayItemStatus (_l_10555, self, _l_10556);
		}
		else
		{
			sprint (self, 2.000000, "Item is missing.\n");
		}
	}
	else
	{
		return;
	}
	if ((_l_10555.display_item_status4 != 0.000000))
	{
		_l_10556 = Finditem (_l_10555.display_item_status4);
		if (_l_10556)
		{
			DisplayItemStatus (_l_10555, self, _l_10556);
		}
		else
		{
			sprint (self, 2.000000, "Item is missing.\n");
		}
	}
};
void() BioInfection_Decay = 
{
	if (teamplay & 16 && self.owner.team_no == self.enemy.team_no && self.owner.team_no != 0)
	{
		self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 16);
		dremove(self);
		return;
	}
	if (self.invincible_finished > time)
	{
		self.owner.tfstate = self.owner.tfstate - (self.owner.tfstate & 16);
		dremove(self);
		return;
	}
	self.nextthink = time + 2;
	deathmsg = 13;
	TF_T_Damage(self.owner, self, self.enemy, 5, 1, 0);
	SpawnBlood(self.owner.origin, 30);
	if (!(self.owner.tfstate & 16))
	{
		dremove(self);
	}
};
void() BioInfection_MonsterDecay = 
{
	self.nextthink = time + 2;
	if (self.enemy.classname == "player" || self.enemy.health < 1)
	{
		dremove(self);
		return;
	}
	deathmsg = 13;
	T_Damage(self.enemy, self, self.owner, 42);
	SpawnBlood(self.enemy.origin, 20);
	if (self.owner.health < 1)
	{
		dremove(self);
	}
};
void(string halias, float himpulse1, float himpulse2) TeamFortress_Alias = 
{
	local string imp;
	stuffcmd(self, "alias ");
	stuffcmd(self, halias);
	stuffcmd(self, " \"impulse ");
	imp = ftos(himpulse1);
	stuffcmd(self, imp);
	if (himpulse2 != 0)
	{
		stuffcmd(self, ";wait; impulse ");
		imp = ftos(himpulse2);
		stuffcmd(self, imp);
	}
	stuffcmd(self, "\"\n");
};

void() TeamFortress_Regenerate = 
{
	if (self.owner.playerclass == 5)
	{
		self.nextthink = time + 2;
		if (self.owner.health >= self.owner.max_health - 2)
		{
			return;
		}
		if (self.owner.ammo_medikit == 0)
		{
			return;
		}
		if (self.owner.ammo_medikit < 2)
		{
			self.owner.health = self.owner.health + self.owner.ammo_medikit;
		}
		else
		{
			self.owner.health = self.owner.health + 2;
		}
		if (self.owner.health > self.owner.max_health)
		{
			self.owner.health = self.owner.max_health;
		}
	}
};
void() TeamFortress_RegenerateCells = 
{
	if (self.owner.playerclass == 8)
	{
		self.nextthink = time + 5;
		if (self.owner.is_undercover == 1)
		{
			if (self.owner.ammo_cells == 0)
			{
				self.owner.is_undercover = 0;
#ifdef PL_FEM
				self.owner.modelindex = GetPlayerModelindex( self.owner );
#else
				self.owner.modelindex = modelindex_player;
#endif
				self.owner.items = self.owner.items - (self.owner.items & 524288);
			}
			else
			{
				self.owner.ammo_cells = self.owner.ammo_cells - 3;
				if (self.owner.ammo_cells < 0)
				{
					self.owner.ammo_cells = 0;
				}
			}
		}
	}
		else
		{
			if (self.owner.ammo_cells >= self.owner.maxammo_cells)
			{
				return;
			}
			self.owner.ammo_cells = self.owner.ammo_cells + 1;
			if (self.owner.ammo_cells > self.owner.maxammo_cells)
			{
				self.owner.ammo_cells = self.owner.maxammo_cells;
			}
		}
		return;
};
void() PlayerObserverMode = 
{
	self.current_menu = 1;
	self.impulse = 0;
	self.playerclass = 0;
	self.lives = 0;
	if (self.#lms_lives < 0)
		self.lives = -1;
	self.team_no = -1; // Just in case, forces you to pick a team on join. grav well should not suck observers in. -arg
	self.flags = 8 | 128 | 512;
	self.waterlevel = 3;
	self.takedamage = 0;
	self.solid = 0;
	self.movetype = 0;
	self.immune_to_check = time + 2;
	self.tfstate = self.tfstate | 65536;
	setmodel(self, string_null);
	sprint(self, 2, "Observer mode\n");
	CenterPrint(self, "\n");
	stuffcmd(self, "cl_rollangle 0\n");
};
float(vector veca, vector vecb) crossproduct = 
{
	local float result;
	result = veca_x * vecb_y - vecb_x * veca_y;
	return result;
};
void(entity targ, entity inflictor, entity attacker, float damage) T_Damage = 
{
	local vector dir;
	local entity oldself;
	local entity te;
	local float save;
	local float take;
	if (!(targ.takedamage))
	{
		return;
	}
	if (inflictor.monster_type > 0)
		damage *= 4.5;
	if (((targ.classname == "player_prop") && (targ.team_no == attacker.team_no) && targ != attacker))
	{
		return;
	}
	if (attacker.#is_minion == #TRUE && attacker.classname != "player")
	{
		// TODO: multiply damage here for higher level minion master
	}
	if (targ.#is_minion == #TRUE && targ.team_no == attacker.team_no && attacker.classname != "player")
		return;
		if (targ.classname == "player" && targ.health <= 0 && targ.solid == 0)
			return;
		if (attacker.is_monster == 1)
		{
			damage = MTF_Monster_Damage( attacker, inflictor, targ, damage );
		}
		if (targ.is_monster == 1 && attacker.classname == "player")
		{
			if (targ.movetype != MOVETYPE_FLY)
			{
				if (targ.flags & FL_ONGROUND) 
					if (targ.being_juggled)
					{
						targ.being_juggled = 0;
					}
				if (targ.being_juggled)
				{
					damage *= 2;
					targ.being_juggled = targ.being_juggled + 1;
				}
				if (inflictor.touch == T_MissileTouch /*|| inflictor.touch == GrenadeTouch */|| inflictor.touch == NormalGrenadeTouch || inflictor.touch == Napalm_touch || inflictor.touch == T_IncendiaryTouch)
				{
					
					dir = targ.origin - (inflictor.absmin + inflictor.absmax) * 0.5;
					dir = normalize(dir);
					if (targ.flags & FL_ONGROUND) 
						targ.being_juggled = 1;
						targ.flags = targ.flags - FL_ONGROUND;
						targ.velocity_z += 325;		// was 300
						targ.velocity = targ.velocity + dir * damage * 4;
				}
			}
			damage = MTF_Monster_Take_Damage( attacker, targ, damage );
		}
		if (canusenew == 1)
		{
		if (attacker.netname && attacker != world)
		{
		if (attacker.infstaytime > time)
		{
			attacker.infstaytime = time + 1.25;
			attacker.inflicted = attacker.inflicted + damage;
		}
		else
		{
			attacker.inflicted = damage;
			attacker.infstaytime = time + 2.25; } }
		}
		if (attacker.classname == "player")
		{
			damage = damage * 0.95;  // was .9 -arg
		}
		if (attacker.classname == "player")
		{
		if (targ.is_monster != 1 && targ.classname != "player" && targ.classname != "bot" && targ.classname != "minifiend")
		{
		if (!Activated(targ, attacker))
		{
		if (targ.else_goal != TF_FLARE_LIT)
		{
			te = Findgoal(targ.else_goal);
			if (te)
			{
				DoResults(te, attacker, targ.goal_result & 2);
			}
			}
			return;
			}
			}
			}
		damage_attacker = attacker;
	if ((targ.tools == (targ.tools | 32)))		// BTF Sub
	{
		damage = damage * 0.500000;
	}
	if (attacker.super_damage_finished > time)
	{
		damage = damage * 4;
	}
		if (attacker.crit_attr > 0)
		{
			if ( random() <= .075 )	// 7.5% chance
			{
				stuffcmd (attacker, "bf\n");
				damage = damage * (1 + MTF_Coop_AttribGain( attacker, #ATTRIB_CRIT ));
			}
		}
	if (teamplay & (64 | 32))
	{
		damage = TeamEqualiseDamage(targ, attacker, damage);
	}
	save = ceil(targ.armortype * damage);
	if (save >= targ.armorvalue)
	{
		save = targ.armorvalue;
		targ.armortype = TF_FLARE_LIT;
		targ.armorclass = TF_FLARE_LIT;
		targ.items = targ.items - (targ.items & (8192 | 16384 | 32768));
	}
	targ.armorvalue = targ.armorvalue - save;
	take = ceil(damage - save);
	if (targ.flags & 8)
	{
		targ.dmg_take = targ.dmg_take + take;
		targ.dmg_save = targ.dmg_save + save;
		targ.dmg_inflictor = inflictor;
	}
	if (inflictor != world && targ.movetype == 3)
	{
		targ.immune_to_check = time + damage / 20;
		dir = targ.origin - (inflictor.absmin + inflictor.absmax) * 0.5;
		dir = normalize(dir);
	if (attacker.monster_items & #MITEM_AIR)
	{
		dir*=2.25;
	}
if ((((damage < 60) & ((attacker.classname == "player") & (targ.classname == "player"))) & (attacker.netname != targ.netname)))
		{
			targ.velocity = targ.velocity + dir * damage * 11;
		}
		else
		{
			targ.velocity = targ.velocity + dir * damage * 8;
		}
		if (rj > TF_FLARE_OFF && (attacker.classname == "player" && targ.classname == "player") && attacker.netname == targ.netname)
		{
			targ.velocity = targ.velocity + dir * damage * rj;
		}
		}
	if (targ.flags & 64)
	{
		return;
	}
	if (targ.invincible_finished >= time)
	{
	if (self.invincible_sound < time)
	{
			sound(targ, 3, "items/protect3.wav", TF_FLARE_OFF, TF_FLARE_OFF);
			self.invincible_sound = time + 2;
	}
	return;
	}
	if (attacker.classname == "player" && (targ.classname == "player" || targ.classname == "building_sentrygun"))
	{
	if (targ.team_no < #BOT_TEAM && targ.team_no > TF_FLARE_LIT && targ.team_no == attacker.team_no && targ != attacker)
	{
		if (teamplay & 16)
	{
	return;
	}
	else
	{
	if (teamplay & 8)
	{
		take = take / 2;
	}
			}
		}
	}
	if (take < TF_FLARE_OFF)
	{
		take = TF_FLARE_OFF;
	}
	targ.health = targ.health - take;
	if (targ.armorvalue < TF_FLARE_OFF)
	{
		targ.armorclass = TF_FLARE_LIT;
		targ.armorvalue = TF_FLARE_LIT;
	}
#ifdef mtf_coop_bloodmod
	if (targ.is_monster == 1)
		bloodyme(targ, damage);
#endif
	if (targ.health <= 0)
	{
	Killed(targ, attacker);
	return;
	}
	oldself = self;
 	self = targ;
		if (self.is_monster == 1)
		{
			if (self.enemy == world)
			{
					if (attacker.invisible_finished > time)
					{
						if (random() > .8)
							self.wooha = attacker;
					}
					else
						self.wooha = attacker;
					if (attacker.playerclass == 8)
						attacker.#spy_visible_time = time + 1.35;
				}
		}
	if (self.th_pain)
	{
		self.th_pain();		//Removed extra parameters -arg
			self.#npc_lastruntime = 0;
		if (skill >= 3)
		{
			self.pain_finished = time + 5;
		}
	}
self = oldself;
};
void(entity targ, entity inflictor, entity attacker, float damage, float T_flags, float T_AttackType) TF_T_Damage = 
{
	local vector dir;
	local entity oldself;
	local entity te;
	local float save;
	local float take;
		if (canusenew == 1)
		{
			if (attacker.netname && attacker != world)
			{
				if (attacker.infstaytime > time)
				{
					attacker.infstaytime = time + 1.25;
					attacker.inflicted = attacker.inflicted + damage;
				}
		else
		{
			attacker.inflicted = damage;
			attacker.infstaytime = time + 2.25; } }
		}
	if (!(targ.takedamage))
	{
		return;
	}
	if (targ.#is_minion == #TRUE && targ.team_no == attacker.team_no && attacker.classname != "player")
		return;
	if (attacker.classname == "building_sentrygun" && targ.classname == "building_sentrygun")
		if (attacker.team_no == targ.team_no)
			damage *= .25;
		if (targ.classname == "player" && targ.health <= 0 && targ.solid == 0)
			return;
		if (attacker.is_monster == 1)
		{
			damage = MTF_Monster_Damage( attacker, inflictor, targ, damage );
		}
		if (targ.is_monster == 1 && attacker.classname == "player")
		{
			if (targ.movetype != MOVETYPE_FLY)
			{
				if (targ.flags & FL_ONGROUND) 
					if (targ.being_juggled)
					{
						targ.being_juggled = 0;
					}
				if (targ.being_juggled)
				{
					damage *= 2;
					targ.being_juggled = targ.being_juggled + 1;
				}
				if (inflictor.touch == T_MissileTouch /*|| inflictor.touch == GrenadeTouch*/ || inflictor.touch == NormalGrenadeTouch)
				{
					dir = targ.origin - (inflictor.absmin + inflictor.absmax) * 0.5;
					dir = normalize(dir);
					if (targ.flags & FL_ONGROUND) 
						targ.being_juggled = 1;
					targ.flags = targ.flags - FL_ONGROUND;
					targ.velocity_z += 300;
					targ.velocity = targ.velocity + dir * damage * 4;
				}
			}
			damage = MTF_Monster_Take_Damage( attacker, targ, damage );
		}
	if (((targ.classname == "player_prop") && (targ.team_no == attacker.team_no) && targ != attacker))
	{
		return;
	}
	if (attacker.classname == "player")
	{
		damage = damage * 0.9;
	}
	if (attacker.classname == "player")
	{
	if (((((((((((targ.classname != "player") && targ.is_monster != 1 && (targ.classname != "bot")) && (targ.classname != "building_tesla")) && (targ.classname != "building_sentrygun")) && (targ.classname != "building_dispenser")) && (targ.classname != "player_prop")) && (targ.classname != "building_teleporter")) && (targ.classname != "building_fieldgen")) && (targ.classname != "building_camera")) && (targ.classname != "trip_bomb")))
		{
			if (!Activated(targ, attacker))
			{
			if (targ.else_goal != TF_FLARE_LIT)
				{
					te = Findgoal(targ.else_goal);
					if (te)
				{
						DoResults(te, attacker, targ.goal_result & 2);
				}
			}
				return;
			}
		}
	}
		if (((attacker.stats_on == 1.000000) && (attacker.team_no != targ.team_no)))
		{
			oldself = self;
			self = attacker;
			if ((deathmsg == 1.000000))
			{
				Stats_Hit (128.000000);
			}
			else
			{
				if ((deathmsg == 2.000000))
				{
					Stats_Hit (256.000000);
				}
				else
				{
					if ((deathmsg == 3.000000))
					{
						Stats_Hit (512.000000);
					}
					else
					{
						if ((deathmsg == 4.000000))
						{
							Stats_Hit (1024.000000);
						}
						else
						{
							if ((deathmsg == 5.000000))
							{
								Stats_Hit (2048.000000);
							}
							else
							{
								if ((deathmsg == 6.000000))
								{
									Stats_Hit (8192.000000);
								}
								else
								{
									if ((deathmsg == 8.000000))
									{
										Stats_Hit (666.000000);
									}
									else
									{
										if ((deathmsg == 11.000000))
										{
											Stats_Hit (2054.000000);
										}
										else
										{
											if ((deathmsg == 17.000000))
											{
												Stats_Hit (8.000000);
											}
											else
											{
												if ((deathmsg == 18.000000))
												{
													Stats_Hit (32.000000);
												}
												else
												{
													if ((deathmsg == 19.000000))
													{
														Stats_Hit (64.000000);
													}
													else
													{
														if ((deathmsg == 20.000000))
														{
															Stats_Hit (32768.000000);
														}
														else
														{
															if ((deathmsg == 25.000000))
															{
																Stats_Hit (262144.000000);
															}
															else
															{
																if ((deathmsg == 26.000000))
																{
																	Stats_Hit (524288.000000);
																}
																else
																{
																	if ((deathmsg == 46.000000))
																	{
																		Stats_Hit (32768.000000);
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			self = oldself;
		}
		damage_attacker = attacker;
	if (attacker.super_damage_finished > time)
	{
		damage = damage * 4;
	}
		if (attacker.crit_attr > 0)
		{
			if ( random() <= .075 )	// 7.5% chance	// if ( random() < ((attacker.crit_attr) * .055) )
			{
				stuffcmd (attacker, "bf\n");
				damage = damage * (1 + MTF_Coop_AttribGain( attacker, #ATTRIB_CRIT ));
			}
		}
	if (targ.team_no == attacker.team_no && targ != attacker)
	{
		damage = TF_FLARE_LIT;
	}
	if (teamplay & (64 | 32))
	{
		damage = TeamEqualiseDamage(targ, attacker, damage);
	}
	if (targ.armorclass != TF_FLARE_LIT && T_AttackType != TF_FLARE_LIT)
	{
	if (targ.armorclass & TF_FLARE_OFF && T_AttackType == TF_FLARE_OFF)
		{
			damage = floor(damage * 0.5);
		}
		else
		{
			if (targ.armorclass & 2 && T_AttackType == 2)
			{
			damage = floor(damage * 0.5);
			}
			else
			{
			if (targ.armorclass & 4 && T_AttackType == 4)
				{
					damage = floor(damage * 0.5);
				}
				else
				{
					if (targ.armorclass & 8 && T_AttackType == 8)
					{
					damage = floor(damage * 0.5);
					}
					else
					{
					if (targ.armorclass & 16 && T_AttackType == 16)
					{
							damage = floor(damage * 0.5);
						}
					}
				}
			}
		}
	}
	if (T_flags & TF_FLARE_OFF)
	{
		take = damage;
		save = TF_FLARE_LIT;
	}
	else
	{
		save = ceil(targ.armortype * damage);
		if (save >= targ.armorvalue)
		{
			save = targ.armorvalue;
			targ.armortype = TF_FLARE_LIT;
			targ.armorclass = TF_FLARE_LIT;
			targ.items = targ.items - (targ.items & (8192 | 16384 | 32768));
		}
		targ.armorvalue = targ.armorvalue - save;
		take = ceil(damage - save);
		}
	if (targ.flags & 8)
	{
		targ.dmg_take = targ.dmg_take + take;
		targ.dmg_save = targ.dmg_save + save;
		targ.dmg_inflictor = inflictor;
	}
	if (inflictor != world && targ.movetype == 3)
	{
		if (deathmsg != 9)
		{
			if (targ.playerclass != 6)
			{
				targ.immune_to_check = time + damage / 20;
				dir = targ.origin - (inflictor.absmin + inflictor.absmax) * 0.5;
				dir = normalize(dir);
	if (attacker.monster_items & #MITEM_AIR)
	{
		dir*=5.25;
	}
	if ((((damage < 60) & ((attacker.classname == "player") & (targ.classname == "player"))) & (attacker.netname != targ.netname)))
	{
		if (attacker.playerclass == 5)
		{
						targ.velocity = targ.velocity + dir * damage * 3;
					}
				else
					{
						targ.velocity = targ.velocity + dir * damage * 11;
					}
		}
		else
		{
			targ.velocity = targ.velocity + dir * damage * 8;
		}
				if (rj > TF_FLARE_OFF && (attacker.classname == "player" && targ.classname == "player") && attacker.netname == targ.netname)
				{
					targ.velocity = targ.velocity + dir * damage * rj;
				}
	}
		}
	}
	if (targ.flags & 64)
	{
		return;
	}
	if (targ.invincible_finished >= time)
	{
		if (self.invincible_sound < time)
		{
			sound(targ, 3, "items/protect3.wav", TF_FLARE_OFF, TF_FLARE_OFF);
			self.invincible_sound = time + 2;
		}
		return;
	}
	if ((((((attacker.classname == "player") && (((targ.classname == "player") || (targ.classname == "building_teleporter")) || (targ.classname == "building_sentrygun")) || (targ.classname == "building_camera")) || (targ.classname == "building_fieldgen")) || (targ.classname == "building_tesla"))))
	{
	if (T_flags & 2)
		{
			if (targ.team_no < #BOT_TEAM && targ.team_no > TF_FLARE_LIT && targ.team_no == attacker.team_no && targ != attacker)
			{
				if (teamplay & 4)
				{
				return;
				}
				else
				{
					if (teamplay & 2)
					{
						take = take / 2;
					}
				}
			}
		}
		else
		{
			if (targ.team_no < #BOT_TEAM && targ.team_no > TF_FLARE_LIT && targ.team_no == attacker.team_no && targ != attacker)
			{
				if (teamplay & 16)
				{
					return;
				}
				else
				{
					if (teamplay & 8)
					{
						take = take / 2;
					}
				}
			}
		}
	}
	if (T_flags & 4)
	{
		if (targ == attacker)
		{
			return;
		}
	}
	if (take < TF_FLARE_OFF)
	{
		take = TF_FLARE_OFF;
	}
	targ.health = targ.health - take;
	if (targ.armorvalue < TF_FLARE_OFF)
	{
		targ.armorclass = TF_FLARE_LIT;
		targ.armorvalue = TF_FLARE_LIT;
	}
	if ((((deathmsg == 34.000000) && (targ.classname == "building_sentrygun")) && (targ.health <= 0.000000)))
	{
		if (((targ.goalentity.classname == "bot") || (targ.goalentity.classname == "airmirv")))
		{
			targ.goalentity = targ.goalentity.owner;
		}
		bprint (1.000000, targ.real_owner.netname);
		bprint (1.000000, "'s sentrygun blew itself up thanks to ");
		bprint (1.000000, targ.goalentity.netname);
		bprint (1.000000, "\n");
		if (targ.goalentity.classname == "player")
			targ.goalentity.real_frags = (targ.goalentity.real_frags + 2.000000);
		logfrag (targ.goalentity, targ.real_owner);
		if (!(toggleflags & 128.000000))
		{
			if (targ.goalentity.classname == "player")
				targ.goalentity.frags = targ.goalentity.real_frags;
		}
	}
#ifdef mtf_coop_bloodmod
			if (targ.is_monster == 1)
				bloodyme(targ, damage);
#endif
	if (targ.health <= 0)
	{
		if (inflictor.classname == "detpack" && inflictor.weaponmode == TF_FLARE_OFF && inflictor.enemy == targ)
		{
			deathmsg = 16;
		}
		Killed(targ, attacker);
		return;
	}
	oldself = self;
	self = targ;
		if (self.is_monster == 1)
		{
			if (self.enemy == world)
			{
					if (attacker.invisible_finished > time)
					{
						if (random() > .8)
							self.wooha = attacker;
					}
					else
						self.wooha = attacker;
					if (attacker.playerclass == 8)
						attacker.#spy_visible_time = time + 1.35;
				}
		}
	if (self.th_pain)
	{
		self.th_pain();	//Removed "attacker, take" -arg
			self.#npc_lastruntime = 0;
		if (skill >= 3)
		{
			self.pain_finished = time + 5;
		}
	}
	self = oldself;
};
void(entity inflictor, entity attacker, float damage, entity ignore) T_RadiusDamage = 
{
	local float points;
	local entity head;
	local entity te;
	local vector org;
		local float i;
		if (self.classname == "grenade")		// so players can't be stupid and disconnect with a primed gren to damage teammates
			if (self.owner == world)
				return;
		if (attacker.rune_time > time)
		{
			if (attacker.#rune_type == #RUNE_EXPLOSIVE)
				damage *= 3;
		}
	head = findradius(inflictor.origin, damage + 40);
	while (head)
	{
		if (head != ignore)
		{
			if (head.classname == "info_tfgoal")
			{
				if (inflictor.classname == "detpack")
				{
					if (head.goal_activation & 2 && head.search_time == TF_FLARE_LIT)
				{
						traceline(inflictor.origin, head.origin, TF_FLARE_OFF, inflictor);
						if (trace_fraction == TF_FLARE_OFF)
						{
						if (Activated(head, attacker))
							{
								DoResults(head, attacker, TF_FLARE_OFF);
							}
							else
							{
							if (head.else_goal != TF_FLARE_LIT)
								{
									te = Findgoal(head.else_goal);
									if (te)
									{
										DoResults(te, attacker, head.goal_result & 2);
									}
								}
								return;
							}
						}
					}
				}
			}
			else
			{
				if (head.takedamage)
				{
	i++;
	if (i > 24)
	{
		return;
	}
					org = head.origin + (head.mins + head.maxs) * 0.5;
					points = 0.5 * vlen(inflictor.origin - org);
					if (points < TF_FLARE_LIT)
					{
						points = TF_FLARE_LIT;
					}
					points = damage - points;
					if (head == attacker)
					{
						points = points * 0.75;
					}
					if (points > TF_FLARE_LIT)
					{
						if (CanDamage(head, inflictor))
						{
							if (head.classname == "minifiend")
							{
								T_Damage(head, inflictor, attacker, points * 0.75);
							}
							else
							if (head.classname == "monster_shambler")
							{
								T_Damage(head, inflictor, attacker, points * 0.5);
							}
							else
							{
								TF_T_Damage(head, inflictor, attacker, points, 2, 4);
							}
						}
						else
						{
							if (((((((head.classname == "building_sentrygun") || (head.classname == "building_tesla")) || (head.classname == "building_fieldgen")) || (head.classname == "building_camera")) || (head.classname == "building_teleporter")) && (head.tf_items & 2)))
							{
								points = rint ((points / 2));
								TF_T_Damage (head, inflictor, attacker, points, 2, 4);
							}
						}
					}
				}
			}
		}
		head = head.chain;
	}
};
void(entity attacker, float damage) T_BeamDamage = 
{
	local float points;
	local entity head;
	head = findradius(attacker.origin, damage + 40);
	while (head)
	{
		if (head.takedamage)
		{
			points = 0.5 * vlen(attacker.origin - head.origin);
			if (points < TF_FLARE_LIT)
			{
				points = TF_FLARE_LIT;
			}
		points = damage - points;
			if (head == attacker)
			{
				points = points * 0.5;
			}
			if (points > TF_FLARE_LIT)
			{
				if (CanDamage(head, attacker))
				{
					T_Damage(head, attacker, attacker, points);
				}
			}
		}
		head = head.chain;
	}
};
float () mtf_saveentity =
{
	local float dfactor;
	dfactor = 0;
	if (cvar ("monster_removebody") == 1)
		dfactor = 1;
	if (mapname == "r2m6")
		dfactor = 1;
	if (mapname == "hip2m4")
		dfactor = 1;
	if (mapname == "cmc")
		dfactor = 1;
	if (mapname == "qte1m3" || mapname == "qte1m4")
		dfactor = 1;
	if (mapname == "qte2m2" || mapname == "qte2m3"/* || mapname == "qte2m4"*/)
		dfactor = 1;
	if (mapname == "neh1m9" || mapname == "neh2m3")
		dfactor = 1;
	if (mapname == "insane")
		dfactor = 1;
	return ( dfactor );
};
void () FlameMonster_Flame =
{
	local float fls;
	local vector endp;
	if (self.owner.size_z > 0 && self.armorvalue == 1)
		fls = self.owner.size_z - 15;
	else
		fls = self.size_z;
	endp = self.owner.origin;
	endp_z += fls;
	if (self.armorvalue == 1)
	{
		if (self.owner.invincible_time > time)
			self.effects = EF_RED;
		else
			self.effects = EF_BLUE;
	}
	if (self.owner.health < 1 || self.owner == world)
		dremove(self);
	if (self.owner.monster_items & MITEM_LIGHTNING)
	{
		if (random() > .85)
		{
			WriteByte (MSG_BROADCAST, 23);
			WriteByte (MSG_BROADCAST, 9);
			WriteEntity (MSG_BROADCAST, self.owner);
			WriteCoord (MSG_BROADCAST, self.owner.origin_x);
			WriteCoord (MSG_BROADCAST, self.owner.origin_y);
			WriteCoord (MSG_BROADCAST, self.owner.origin_z + 24);
			WriteCoord (MSG_BROADCAST, self.origin_x);
			WriteCoord (MSG_BROADCAST, self.origin_y);
			WriteCoord (MSG_BROADCAST, self.origin_z);
		}
	}
	if (endp == self.orig_origin)	// save some bandwidth
	{
		self.nextthink = time + .1;
		return;
	}
	self.orig_origin = endp;
	setorigin(self, endp);
	self.nextthink = time + .1;
};
void () MTF_RemoveMonster =
{
	if (self.enemy.#is_minion == #TRUE && self.enemy != world)
		self.enemy.#is_minion = #FALSE;
	if (self.enemy != world)
		dremove(self.enemy);
	dremove(self);
};
void() changelevel_touch = 
{
	if (Coop_SpecialEnd(mapname) > 0)
		other = checkclient();
	if (other.classname != "player")	//This is supposed to prevent rockets, ammo, and monsters from triggering the exit. -arg 
	{
		return;
	}
	if (can_exit == #FALSE)  // Changed since a single player can now lock the exit with cmd lockexit to prevent premature exit on survival maps or regular ones. -arg
	{	// This fixes the problem of a player getting thrown through exit while playing solo, or a monster doing the exit. -arg
		// The other problem is that grenades or rockets from player 1 only can trigger the exit. So by default it is locked at the beginning of the map.
		// If players do cmd voteexit from the start it is totally unlocked.
		bprint(2,"The exit is locked, or was locked with [cmd lockexit]. If you need to activate the exit, then do [cmd voteexit] first.\n");
		self = other;
		return;
	}
	if (can_exit == #FALSE && num_players >= 2)
	{
		Vote_StartVote( #VOTE_EXIT, "", world );
	}
	if (num_players >= 2 || can_exit == #TRUE)	//If not locked or more than 1 player, then exit. -arg
	{
		if (cvar("samelevel") == 2 || (cvar("samelevel") == 3 && mapname != "start"))
		{
		return;
		}
		bprint(2, other.netname);
		bprint(2, " has exited the level.\n");
		MTF_DoEndBonus ( other );
		nextmap = self.map;
		SUB_UseTargets();
		if (self.spawnflags & TF_FLARE_OFF && deathmatch == 0)
		{
			GotoNextMap();
			return;
		}
		self.touch = SUB_Null;
		self.think = execute_changelevel;
		self.nextthink = time + 0.1;
	}
};
void () summon_respawn_think =
{
	local entity head;
	head = findradius (self.origin, 56);
	while (head)
	{
		if (head.classname == "player" && head.health > 0)
		{
			self.nextthink = time + 1;
			return;
		}
		head = head.chain;
	}
	respawn_think ();
};
float() crandom = 
{
	return 2 * (random() - 0.5);
};
void (vector org,float damage) SpawnBlood =
{
	WriteByte (4, 23);
	WriteByte (4, 12);
	WriteByte (4, 1);
	WriteCoord (4, org_x);
	WriteCoord (4, org_y);
	WriteCoord (4, org_z);
	multicast (org, 2);
};
entity(float team_num) FindTeamSpawnPoint = 
{
	local entity spot;
	local entity at_spot;
	local float spot_found;
	local float attempts;
	if (team_num == TF_FLARE_OFF)
	{
		spot = lastspawn_team1;
		attempts = 0;
		while (TF_FLARE_OFF)
		{
			attempts = attempts + TF_FLARE_OFF;
			spot = find(spot, team_str_home, "ts1");
			if (spot == world)
			{
				spot = find(world, team_str_home, "ts1");
			}
			if (spot == world)
			{
				return world;
			}
			at_spot = findradius(spot.origin, 440);  //increased radius for search for spawn points -arg
			spot_found = TF_FLARE_OFF;
			while (at_spot != world)
			{
				if (at_spot.classname == "player" && at_spot.deadflag == 0)
				{
					spot_found = 0;
				}
				at_spot = at_spot.chain;
			}
			if (!Activated(spot, self))
			{
				spot_found = 0;
			}
			if (spot_found || attempts >= 30)
			{
				lastspawn_team1 = spot;
				return spot;
			}
		}
	}
	else
	{
		if (team_num == 2)
		{
			if (self.monster_type > 0)
			{
				spot = lastspawn_team2;
				attempts = 0;
				while (TF_FLARE_OFF)
				{
					attempts = attempts + TF_FLARE_OFF;
					spot = find(world, monster_string, "on");
					while (spot)
					{
						if (spot.health > 1)
						{
							spot_found = 1;
							break;
						}
						spot = find(spot, monster_string, "on");
					}
					if (spot == world)
					{
						spot = find(world, classname, "monster_shambler");
					}
					if (spot == world)
					{
						return world;
					}
					at_spot = findradius(spot.origin, 40);
					spot_found = TF_FLARE_OFF;
					while (at_spot != world)
					{
						if (at_spot.classname == "player" && at_spot.deadflag == 0)
						{
							spot_found = 0;
						}
						at_spot = at_spot.chain;
					}
					if (!Activated(spot, self))
					{
						spot_found = 0;
					}
					if (spot_found || attempts >= 30)
					{
						Killed(spot, world); // -arg might need to be commented out.
						lastspawn_team2 = spot;
						
						return spot;
					}
				}
			
			}
			spot = lastspawn_team2;
			attempts = 0;
			while (TF_FLARE_OFF)
			{
				attempts = attempts + TF_FLARE_OFF;
				spot = find(spot, team_str_home, "ts2");
				if (spot == world)
				{
					spot = find(world, team_str_home, "ts2");
				}
				if (spot == world)
				{
					return world;
				}
				at_spot = findradius(spot.origin, 40);
				spot_found = TF_FLARE_OFF;
				while (at_spot != world)
				{
					if (at_spot.classname == "player" && at_spot.deadflag == 0)
					{
						spot_found = 0;
					}
					at_spot = at_spot.chain;
				}
				if (!Activated(spot, self))
				{
					spot_found = 0;
				}
				if (spot_found || attempts >= 30)
				{
					lastspawn_team2 = spot;
					return spot;
				}
			}
		}
		else
		{
			if (team_num == 3)
			{
				spot = lastspawn_team3;
				attempts = 0;
				while (TF_FLARE_OFF)
				{
					attempts = attempts + TF_FLARE_OFF;
					spot = find(spot, team_str_home, "ts3");
					if (spot == world)
					{
						spot = find(world, team_str_home, "ts3");
					}
					if (spot == world)
					{
						return world;
					}
					at_spot = findradius(spot.origin, 40);
					spot_found = TF_FLARE_OFF;
					while (at_spot != world)
					{
						if (at_spot.classname == "player" && at_spot.deadflag == 0)
						{
							spot_found = 0;
						}
						at_spot = at_spot.chain;
					}
					if (!Activated(spot, self))
					{
						spot_found = 0;
					}
					if (spot_found || attempts >= 30)
					{
						lastspawn_team3 = spot;
						return spot;
					}
				}
			}
			else
			{
				if (team_num == 4)
				{
					spot = lastspawn_team4;
					attempts = 0;
					while (TF_FLARE_OFF)
					{
						attempts = attempts + TF_FLARE_OFF;
						spot = find(spot, team_str_home, "ts4");
						if (spot == world)
						{
							spot = find(world, team_str_home, "ts4");
						}
						if (spot == world)
						{
							return world;
						}
						at_spot = findradius(spot.origin, 40);
						spot_found = TF_FLARE_OFF;
						while (at_spot != world)
						{
							if (at_spot.classname == "player" && at_spot.deadflag == 0)
							{
								spot_found = 0;
							}
							at_spot = at_spot.chain;
						}
						if (!Activated(spot, self))
						{
							spot_found = 0;
						}
						if (spot_found || attempts >= 30)
						{
							lastspawn_team4 = spot;
							return spot;
						}
					}
				}
			}
		}
	}
	return world;
};
void () T_MissileTouch =
{
	local float damg;
	if (other.classname == "monster_boss")
	{
		if (self.real_owner == other)
		{
			self.owner = other;
			return;
		}
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (self.owner.classname == "monster_army")
		damg = (17 + (random () * 15));
	else
	damg = (92 + (random () * 20));
	if (self.owner.classname == "player")		// more rocket damage (test)
		damg += 10;		// was 35 on 6/25/12
	deathmsg = self.weapon;
	if (other.health)
	{
		TF_T_Damage (other, self, self.owner, damg, 0.000000, 4);
	}
	T_RadiusDamage (self, self.owner, 92, other);
	self.origin = (self.origin - (8 * normalize (self.velocity)));
	WriteByte (4, 23);
	WriteByte (4, 3);
	WriteCoord (4, self.origin_x);
	WriteCoord (4, self.origin_y);
	WriteCoord (4, self.origin_z);
	multicast (self.origin, 1);
	Bounce_Off_Walls ();
};
void(float tno) decrement_team_pipebombs = 
{
	if (tno == TF_FLARE_OFF)
	{
		num_team_pipebombs_1 = num_team_pipebombs_1 - TF_FLARE_OFF;
	}
	else
	{
		if (tno == 2)
		{
			num_team_pipebombs_2 = num_team_pipebombs_2 - TF_FLARE_OFF;
		}
		else
		{
			if (tno == 3)
			{
				num_team_pipebombs_3 = num_team_pipebombs_3 - TF_FLARE_OFF;
			}
			else
			{
				if (tno == 4)
				{
					num_team_pipebombs_4 = num_team_pipebombs_4 - TF_FLARE_OFF;
				}
			}
		}
	}
};
float (entity us, entity test) COOP_IsValidTarget =
{
	local float r;
	local entity the_client;
	if (test.classname == "monster_demon1" || test.classname == "monster_army" || test.classname == "monster_shambler" || test.classname == "monster_wizard" )
	{
		if (!Teammate(test.real_owner.team_no, us.team_no))
			return #TRUE;
	}
	else
	if (!Teammate(test.team_no, us.team_no))
	{
		if (IsBuilding(test) && test.classname != "building_sentrygun_base")
			return #TRUE;
		else
		if (test.classname == "player")
		{
			r = vlen(test.origin - us.origin);
			the_client = test;
	if (the_client == self.enemy)
	{
		return TF_FLARE_LIT;
	}
	if (the_client.flags & 128)
	{
		return TF_FLARE_LIT;
	}
	if (the_client.items & 524288)
	{
		return TF_FLARE_LIT;
	}
	if (the_client.team_no == self.team_no)
	{
		return TF_FLARE_LIT;
	}
	if (the_client.undercover_team == self.team_no && the_client.playerclass == 8)
	{
		return TF_FLARE_LIT;
	}
	r = range(the_client);
	if (r == 3)
	{
		return TF_FLARE_LIT;
	}
	if (!visible(the_client))
	{
		return TF_FLARE_LIT;
	}
	if (r == TF_FLARE_OFF)
	{
		if (the_client.show_hostile < time && !infront(the_client))
		{
			return TF_FLARE_LIT;
		}
	}
	else
	{
		if (r == 2)
		{
			if (!infront(the_client))
			{
				return TF_FLARE_LIT;
			}
		}
					return #TRUE;
				}
			}
		}
	return #FALSE;
};
entity (entity scanner) COOP_FindTarget =
{
	local entity head;
	if (scanner.#npc_noticedelay > time)
		return world;
	self.#npc_noticedelay = time + 1.3;
	head = findradius (scanner.origin, 2048);
	while (head)
	{
		if (visible2(head, scanner) && head.takedamage && head.health > 0)
		{
			if (COOP_IsValidTarget(scanner, head))
				return head;
		}
		head = head.chain;
	}
	return world;
};
void () COOP_SmoothFrame =
{
	local float oldyaw;
	local float speedmod;
	if (time >= self.#npc_smoothtime)
	{
		self.nextthink = time;
		self.think = self.npc_oldthink;
		self.#npc_lastruntime = 0;
		return;
	}
	if (!self.#npc_lastruntime)
	{
		self.#npc_lastruntime = self.lastruntime;
		self.nextthink = time + #NPC_LERPTIME;
		return;
	}
		self.#npc_lastruntime = (self.lastruntime - .1);
	speedmod = self.#npc_smoothdist;
	speedmod = speedmod * .45;
	movedist = (speedmod/*self.#npc_smoothdist*/ / #NPC_FRAMETIME) * (self.lastruntime - self.#npc_lastruntime);
	if (movedist)
	{
		oldyaw = self.yaw_speed;
		self.yaw_speed = (oldyaw / #NPC_FRAMETIME) * (self.lastruntime - self.#npc_lastruntime);
		movetogoal (movedist);
		self.yaw_speed = oldyaw;
		self.#npc_lastruntime = self.lastruntime;
		self.#npc_hax = self.lastruntime;
		self.#npc_attemptednextthink = self.nextthink = time + #NPC_LERPTIME;
	} 
	else
	if (self.#npc_smoothdist)
	{
		self.#npc_attemptednextthink = self.nextthink = self.#npc_attemptednextthink + 0.01;
	}
};
void (float dist) COOP_WalkSmooth =
{
	if (!dist)
		return;
	self.npc_oldthink = self.think;
	self.#npc_smoothtime = time + #NPC_FRAMETIME;
	self.#npc_smoothdist = dist;
	self.think = COOP_SmoothFrame;
	COOP_SmoothFrame ();
};
void (entity t_plyr) CSQC_SendGrenTimer =
{
	if (!t_plyr.csqc_client)
		return;
	stuffcmd( t_plyr, "cmd grentimer 4\n" );		// addme: variable grenade times?
};
void() NailGrenadeExplode = 
{
	self.movetype = 5;
	setorigin(self, self.origin + '0 0 32');
	self.avelocity = '0 500 0';
	self.nextthink = time + 0.7;
	self.think = NailGrenadeNailEm;
};
void() Napalm_touch = 
{
	local entity flame;
	local vector vtemp;
	if (other.classname == "fire")
	{
		return;
	}
	if (other != world)
	{
		if (other.takedamage == 2 && other.health > TF_FLARE_LIT && other.waterlevel <= TF_FLARE_LIT)
		{
			deathmsg = 15;
			TF_T_Damage(other, self, self.owner, 14, 2, 16);
			if (other.numflames >= 3)
			{
				return;
			}
			if (other.armorclass & 16 && other.armorvalue > TF_FLARE_LIT)
			{
				return;
			}
			if (other.classname == "player" && other.waterlevel <= TF_FLARE_LIT)
			{
				if (teamplay & 16 && other.team_no > TF_FLARE_LIT && other.team_no == self.owner.team_no)
				{
					return;
				}
				CenterPrint(other, "You are on fire!\n");
				stuffcmd(other, "bf\n");
			}
			if (other.numflames < TF_FLARE_OFF)
			{
				flame = FlameSpawn("1", other);
				sound(flame, 2, "ambience/fire1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
			}
			else
			{
				flame = FlameSpawn("3", other);
				if (flame == world)
				{
					return;
				}
			}
			flame.classname = "fire";
			flame.health = 30;
			other.numflames = other.numflames + TF_FLARE_OFF;
			flame.velocity = other.velocity;
			flame.enemy = other;
			if (other.waterlevel > TF_FLARE_LIT)
			{
				flame.touch = OnPlayerFlame_touch;
			}
			flame.owner = self.owner;
			vtemp = self.origin;
			setorigin(flame, vtemp);
			flame.nextthink = time + 0.1;
			flame.think = FlameFollow;
		}
	}
	else
	{
		flame = FlameSpawn("4", other);
		if (flame != world)
		{
			flame.touch = WorldFlame_touch;
			flame.classname = "fire";
			vtemp = self.origin + '0 0 10';
			setorigin(flame, vtemp);
			flame.nextthink = time + 15;
			flame.think = Remove;
			flame.enemy = self.owner;
		}
		FlameDestroy(self);
	}
};
void () MirvGrenadeTouch =
{
	sound (self,TF_FLARE_OFF,"weapons/bounce.wav",TF_FLARE_OFF,TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
	self.avelocity = '0 0 0';
	}
};
void () MirvGrenadeExplode =
{
	local float i;
	deathmsg = 10;
	T_RadiusDamage (self,self.owner,200,world);
	WriteByte (4,23);
	WriteByte (4,3);
	WriteCoord (4,self.origin_x);
	WriteCoord (4,self.origin_y);
	WriteCoord (4,self.origin_z);
	multicast (self.origin,TF_FLARE_OFF);
	self.solid = TF_FLARE_LIT;
	i = TF_FLARE_LIT;
	while (i < 6) 
	{
		MirvGrenadeLaunch ((self.origin + '0 0 -1'),self.owner);
		i = (i + TF_FLARE_OFF);
	}
	BecomeExplosion ();
};
void() T_IncendiaryTouch = 
{
	local float damg;
	local entity head;
	local entity _l_9052;
	local string incdamagecheck;
	if (other == self.owner)
	{
		return;
	}
	if (pointcontents(self.origin) == -6)
	{
		remove(self);
		return;
	}
	self.effects = self.effects | 4;
	incdamagecheck = infokey (world, "newbalance");
	if (incdamagecheck == "1")
	{
		damg = 25 + random() * 20;
	}
	else
	{
		damg = 30 + random() * 20;
	}
	if (other.health)
	{
		deathmsg = 15;
		TF_T_Damage(other, self, self.owner, damg + damg + damg, 2, 16);
	}
	head = findradius(self.origin, 130);
	while (head)
	{
		if (head.takedamage)
		{
			deathmsg = 15;
			TF_T_Damage(head, self, self.owner, 30, 2, 16);
			other = head;
			Napalm_touch();
			if (other.classname == "player")
			{
				if (((self.owner.stats_on == 1.000000) && (self.owner != head)))
				{
					_l_9052 = self;
					self = self.owner;
					Stats_Hit (16384.000000);
					self = _l_9052;
				}
				stuffcmd(other, "bf\nbf\n");
			}
		}
		head = head.chain;
	}
	self.origin = self.origin - 8 * normalize(self.velocity);
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	dremove(self);
};
void (entity t_other) MTF_DoEndBonus =
{
	local entity te;
	local float exptotal, expcurve;
	if (t_other.classname == "player")
		other = t_other;
	else
		other = world;
	other = world;
	if (no_more_exp == #FALSE)
	{
		if (survival_mode)
		{
			bprint(2,"Players have completed survival mode! Good team work!\n");
			te = find ( world, classname, "player" );
			while (te)
			{
				if (te.coop_exp != -1 && te != other && te.has_disconnected != 1)
				{
					if (te.frags > 0)
			{
					expcurve = 27;
					if (te.mtf_items & MTFITEM_DIVIDE_EXP)
						expcurve = 13;
					if (mapname == "08")
						expcurve = 1;
					else
					if (mapname == "04")
						expcurve = 1;
					MTF_Coop_AddExperience(te, world, expcurve * te.real_frags);
					MTF_Coop_PreWriteExperience( te, te.connect_name, te.coop_exp );
					if (killed_monsters >= (total_monsters-15))
					{		// -12 b/c you can't always kill all monsters in survival maps
						if (GetEP1MapBit(mapname) != -1)
							Achievements_Change( te, world, ACHIEVEMENTS_ADDBIT, ACHIEVEMENT_EPISODE1, GetEP1MapBit(mapname) );
						else
						if (GetEP2MapBit(mapname) != -1)
							Achievements_Change( te, world, ACHIEVEMENTS_ADDBIT, ACHIEVEMENT_EPISODE2, GetEP2MapBit(mapname) );
						else
						if (GetEP3MapBit(mapname) != -1)
							Achievements_Change( te, world, ACHIEVEMENTS_ADDBIT, ACHIEVEMENT_EPISODE3, GetEP3MapBit(mapname) );
						else
						if (GetEP4MapBit(mapname) != -1)
							Achievements_Change( te, world, ACHIEVEMENTS_ADDBIT, ACHIEVEMENT_EPISODE4, GetEP4MapBit(mapname) );
					}
				}
			}
			te = find (te, classname, "player");
		}
	}
	if (total_monsters > 0)
	{
		if (killed_monsters >= total_monsters)
		{
			bprint(2, "All monsters found! EXP bonus for all!\n");
			Achievements_Change( world, world, ACHIEVEMENTS_GLOBALADD, ACHIEVEMENT_COMPLETIONIST, 1 );
//You have to have some exp for completing survival mode that might not have monsters on the map at all. -arg
//So all players get 500 exp at a minimum.
//TODO: Give more exp to the winning team based on frag count 1st,2nd,3rd place when there is/no monsters.
			exptotal = (ceil(total_monsters*3.5)+ 500);

			te = find ( world, classname, "monster_score" );
			if (te.netname == "Monsters")
			{
				if (te.frags == 0)
				{
					bprint(2, "FLAWLESS VICTORY! Mega EXP bonus!\n");
					if (total_monsters > 41)
						Achievements_Change( world, world, ACHIEVEMENTS_GLOBALADD, ACHIEVEMENT_FLAWLESS, 1 );
					if (mapname == "e1m1")
						exptotal = exptotal + (total_monsters * 25);	// e1m1 abuse :\
					else
					if (mapname == "doom2_01")
						exptotal = exptotal + (total_monsters * 5);	// abuse
					else
						exptotal = exptotal + flawless_bonus;
				}
			}
			if (mapname == "insane")
			{
				bprint(2, "Stop playing insane you exp hoarding nubs! ;)\n");
				if (exptotal > 600)
				{
					exptotal = 600;
				}
			}
			if (mapname == "08")
			{
				if (exptotal > 600)
				{
					exptotal = 600;
				}
			}
			else 
			if (mapname == "beach")
			{
				bprint(2, "Flaw-less flawless eh?\n");
				if (exptotal > 200)
				{
					exptotal = 200;
				}
			}
			else
			if (mapname == "undrhall")
			{
				bprint(2, "Flaw-less flawless eh?\n");
				if (exptotal > 200)
				{
					exptotal = 200;
				}
			}
		}
	}
	if (total_secrets > 0)
	{
		if (found_secrets == total_secrets)
		{
			bprint(2, "All secrets found! EXP bonus for all!\n");
			exptotal = exptotal + (total_secrets * 6);
		}
	}
	if (exptotal > 0)
	{
		te = find ( world, classname, "player" );
		while (te)
		{
			if (te.coop_exp != -1 && te != other && te.has_disconnected != 1)
			{
				if (found_secrets == total_secrets)
					if (GetW3DMapBit(mapname) != -1)
						Achievements_Change( te, world, ACHIEVEMENTS_ADDBIT, ACHIEVEMENT_TREASURE, GetW3DMapBit(mapname) );
				MTF_Coop_AddExperience(te, world, exptotal);
				MTF_Coop_PreWriteExperience( te, te.connect_name, te.coop_exp );
				stuffcmd(te, "cmd sayexp\n");
			}
			te = find (te, classname, "player");
		}
		if (other != world)
			if (other.coop_exp != -1)
			{
				other.coop_exp = other.coop_exp + exptotal;
				MTF_Coop_PreWriteExperience( other, other.connect_name, other.coop_exp );
				stuffcmd(other, "cmd sayexp\n");
			}
	}
	MTF_Coop_UpdateMapRanks();
	}
	no_more_exp = #TRUE;	// dont award any more exp.
};
void() GotoNextMap = 
{
	local float nextlevel;
	local string sl;
	local string nextmapvoted;
	if (FTE_Server)
		Rank_UpdateStatsGlobal();
	if (nextmapchosen == 1)
	{
		nextmapvoted = infokey (world, "nextmap");
		nextmapchosen = 0;			// i dunno, i think this is making it do the rankings twice :/
		MTF_Coop_RanksMapVote( nextmapvoted, 1 );
		localcmd("exec qwmcycle/");
		localcmd(nextmapvoted);
		localcmd(".cfg\n");
		changelevel(nextmapvoted);
		return;
	}
	if (nextmap != mapname)
	{
		changelevel(nextmap);
		already_chosen_map = TF_FLARE_OFF;
	}
	if (!already_chosen_map)
	{
		sl = infokey(world, "n");
		nextlevel = stof(sl);
		nextlevel = nextlevel + TF_FLARE_OFF;
		sl = ftos(nextlevel);
		localcmd("serverinfo n ");
		localcmd(sl);
		localcmd("\n");
		localcmd("exec qwmcycle/map");
		localcmd(sl);
		localcmd(".cfg\n");
	already_chosen_map = TF_FLARE_OFF;
	}
	if (infokey(world, "n") == "0")
	{
		already_chosen_map = 0;
	}
};
void() NapalmGrenadeTouch = 
{
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
void(entity Goal, entity AP, float addb) DoResults = 
{
	local entity te;
	local float winners;
	if (Goal.goal_state == TF_FLARE_OFF)
	{
		return;
	}
	if (Goal.delay_time > TF_FLARE_LIT && Goal.goal_state != 4)
	{
		Goal.goal_state = 4;
		te = spawn();
		te.think = DelayedResult;
		te.nextthink = time + Goal.delay_time;
		te.owner = AP;
		te.enemy = Goal;
		te.weapon = addb;
		return;
	}
	UpdateAbbreviations(Goal);
	Goal.goal_state = 2;
	if (Goal.noise)
	{
		if (Goal.volume == TF_FLARE_OFF)
		{
			sound(other, 3, Goal.noise, TF_FLARE_OFF, TF_FLARE_LIT);
		}
		else
		{
			sound(other, 3, Goal.noise, TF_FLARE_OFF, TF_FLARE_OFF);
		}
	}
	winners = TF_FLARE_LIT;
	if (Goal.increase_team1 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(TF_FLARE_OFF, Goal.increase_team1);
		winners = TF_FLARE_OFF;
	}
	if (Goal.increase_team2 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(2, Goal.increase_team2);
		winners = TF_FLARE_OFF;
	}
	if (Goal.increase_team3 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(3, Goal.increase_team3);
		winners = TF_FLARE_OFF;
	}
	if (Goal.increase_team4 != TF_FLARE_LIT)
	{
		TeamFortress_TeamIncreaseScore(4, Goal.increase_team4);
		winners = TF_FLARE_OFF;
	}
	if (winners == TF_FLARE_OFF)
	{
		TeamFortress_TeamShowScores(2);
	}
	te = find(world, classname, "player");
	while (te != world)
	{
		if (Goal.broadcast != string_null && CTF_Map == TF_FLARE_LIT)
		{
			CenterPrint2(te, "\n\n\n ", Goal.broadcast);	//I think this is where the space is needed for "dropped the flag" when goal.broadcast is set to that. -arg
		}
		if (Goal.netname_broadcast != string_null && CTF_Map == TF_FLARE_LIT)
		{
			sprint(te, 2, AP.netname);
			sprint(te, 2, Goal.netname_broadcast);
		}
		if (AP == te)
		{
			if (Goal.message != string_null)
			{
				CenterPrint2(te, Goal.message, AP.netname);
			}
		}
		else
		{
			if (AP.team_no == te.team_no)
			{
				if (Goal.owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					CenterPrint2(te, Goal.owners_team_broadcast, AP.netname);
				}
				else
				{
					if (Goal.team_broadcast != string_null)
					{
						CenterPrint2(te, Goal.team_broadcast, AP.netname);
					}
				}
				if (Goal.netname_owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Goal.netname_owners_team_broadcast);
				}
				else
				{
					if (Goal.netname_team_broadcast != string_null)
					{
						sprint(te, 2, AP.netname);
						sprint(te, 2, Goal.netname_team_broadcast);
					}
				}
			}
			else
			{
				if (Goal.owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					CenterPrint2(te, Goal.owners_team_broadcast, AP.netname);
				}
				else
				{
					if (Goal.non_team_broadcast != string_null)
					{
						CenterPrint2(te, Goal.non_team_broadcast, AP.netname);
					}
				}
				if (Goal.netname_owners_team_broadcast != string_null && te.team_no == Goal.owned_by)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Goal.netname_owners_team_broadcast);
				}
				else
				{
					if (Goal.netname_non_team_broadcast != string_null)
					{
						sprint(te, 2, AP.netname);
						sprint(te, 2, Goal.netname_non_team_broadcast);
					}
				}
			}
		}
		if (IsAffectedBy(Goal, te, AP))
		{
			if (Goal.search_time != TF_FLARE_LIT && (Goal.goal_effects & 64))
			{
				if (APMeetsCriteria(Goal, te))
				{
					Apply_Results(Goal, te, AP, addb);
				}
			}
			else
			{
				Apply_Results(Goal, te, AP, addb);
			}
		}
		te = find(te, classname, "player");
	}
	if (Goal.classname != "item_tfgoal")
	{
		Goal.goal_state = TF_FLARE_OFF;
	}
	if (Goal.goal_result & 4)
	{
		TeamFortress_TeamShowScores(TF_FLARE_OFF);
		winners = TeamFortress_TeamGetWinner();
		te = find(world, classname, "player");
		while (te)
		{
			te.takedamage = TF_FLARE_LIT;
			te.movetype = TF_FLARE_LIT;
			te.velocity = '0 0 0';
			te.avelocity = '0 0 0';
			te = find(te, classname, "player");
		}
		te = spawn();
		te.nextthink = time + 5;
		te.think = execute_changelevel;
		dremove(Goal);
		return;
	}
	DoGroupWork(Goal, AP);
	DoGoalWork(Goal, AP);
	DoTriggerWork(Goal, AP);
	if (Goal.classname == "info_tfgoal")
	{
		SetupRespawn(Goal);
	}
};
void () Wizard_Bounce_Off_Walls =
{
	if (self.attack_finished < 1)
	{
		BecomeExplosion ();
		dremove (self);
	}
	self.attack_finished -= 1;
	self.nextthink = time;
	self.think = bounce_a;
	if (self.velocity == '0 0 0')
		dremove(self);
};
float(entity targ) visible = 
{
	local vector spot1;
	local vector spot2;
	spot1 = self.origin + self.view_ofs;
	spot2 = targ.origin + targ.view_ofs;
	if (self.#is_minion == #TRUE && targ == self.owner)		// follow owner, don't shoot him
		return 0;
	traceline(spot1, spot2, TF_FLARE_OFF, self);
	if (trace_inopen && trace_inwater)
	{
		return TF_FLARE_LIT;
	}
	if (trace_fraction == TF_FLARE_OFF)
	{
		return TF_FLARE_OFF;
	}
	return TF_FLARE_LIT;
};
void() NapalmGrenadeExplode = 
{
	local entity head;
	traceline(self.origin, self.origin, TF_FLARE_OFF, self);
	if (trace_inwater == TF_FLARE_OFF)
	{
		sound(self, TF_FLARE_LIT, "misc/vapeur2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		dremove(self);
		return;
	}
	deathmsg = 15;
	T_RadiusDamage(self, self.owner, 45, world);
	self.playerclass = self.playerclass + TF_FLARE_OFF;
	self.nextthink = time + 0.75;
	self.effects = self.effects | 4;
	head = findradius(self.origin, 130);
	while (head)
	{
		if (head.takedamage)
		{
			deathmsg = 15;
			TF_T_Damage(head, self, self.owner, 30, 2, 16);
			other = head;
			Napalm_touch();
			if (other.classname == "player")
			{
				stuffcmd(other, "bf\nbf\n");
				KickPlayer(-6, other);
			}
		}
		head = head.chain;
	}
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	if (self.playerclass > 8)
	{
		self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
		self.think = SUB_Remove;
	}
};
void() DelayedResult = 
{
	if (self.enemy.goal_state == 4)
	{
		DoResults(self.enemy, self.owner, self.weapon);
	}
	dremove(self);
};
void () Bounce_Off_Walls =
{
	if (self.attack_finished < 1)
	{
		BecomeExplosion ();
		dremove (self);
	}
	self.attack_finished -= 1;
	self.nextthink = time;
	self.think = bounce_a;
	if (self.velocity == '0 0 0')
		dremove(self);
};
void() GasGrenadeTouch = 
{
	sound(self, 1, "weapons/bounce.wav", 1, 1);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
void() GasGrenadeExplode = 
{
	local entity te;
	local float pos;
	pos = pointcontents(self.origin);
	if (pos == -1)
	{
		te = spawn();
		te.think = GasGrenadeMakeGas;
		te.nextthink = time + 0.1;
		te.heat = 0;
		te.origin = self.origin;
		te.owner = self.owner;
		te.team_no = self.owner.team_no;
		te.weapon = 0;
	}
	else
	{
		pos = 0;
		while (pos < 10)
		{
			newmis = spawn();
			setmodel(newmis, "progs/s_bubble.spr");
			setorigin(newmis, self.origin);
			newmis.movetype = 8;
			newmis.solid = 0;
			newmis.velocity = '0 0 15';
			newmis.velocity_z = 10 + random() * 20;
			newmis.nextthink = time + 0.5;
			newmis.think = bubble_bob;
			newmis.classname = "bubble";
			newmis.frame = 0;
			newmis.cnt = 0;
			setsize(newmis, '-8 -8 -8', '8 8 8');
			pos = pos + 1;
		}
		self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	}
	BecomeExplosion();
	dremove(self);
};
void() NailGrenadeNailEm = 
{
	self.velocity = '0 0 0';
	self.nextthink = time + 0.1;
	self.think = NailGrenadeLaunchNail;
	self.playerclass = TF_FLARE_LIT;
};
void (entity plyr, entity targ, float override_exp) MTF_Coop_AddExperience =
{
	local float addexp;
	local entity oself;
	local string filename, a;
	local float file;
	if (override_exp < 0)
	{
		bprint(2, "Uh oh! Add experience override bug - negative exp attempted to be added!\n");
		return;
	}
	oself = self;
	if (override_exp == 0)
	{
		if ( cvar(frik_strcat("exp_", targ.classname)) == 0)
		{
			filename = frik_strcat( "exp/", targ.classname, ".tfi" );
			filename = strzone(filename);
			file = open (filename, 0);
			if ((file == -1))
			{
				addexp = 5;	// default exp add is 5
				localcmd( "set exp_" );
				localcmd( targ.classname );
				localcmd( " 5\n" );
			}
			else
			{
				a = read (file);
				addexp = stof(a);
				localcmd( "set exp_" );
				localcmd( targ.classname );
				localcmd( " " );
				localcmd( ftos(addexp) );
				localcmd( "\n" );
				close (file);
			}
			strunzone(filename);
		}
		else
		{
			addexp = cvar(frik_strcat("exp_", targ.classname));
		}
	}
	if (targ.coop_exp < 0) 
		addexp = 0;
	else
if (targ.coop_exp > 0)
		addexp = targ.coop_exp;
	if (targ.monster_items & MITEM_QUAD)
	{
	addexp += 5;
	}
	if (targ.monster_items & MITEM_INVISIBLE)
	{
		addexp += 5;
	}
	if (targ.monster_items & MITEM_SPEED)
	{
		addexp += 5;
	}
	if (targ.monster_items & MITEM_MEGAHEALTH)
	{
		addexp += 10;
	}
	if (targ.monster_items & MITEM_FLAME)
	{
		addexp += 5;
	}
	if (targ.monster_items & MITEM_ICE)
	{
		addexp += 5;
	}
	if (targ.monster_items & MITEM_LIGHTNING)
	{
		addexp += 5;
	}
	if (targ.monster_items & MITEM_AIR)
	{
		addexp += 5;
	}
	if (targ.monster_items & MITEM_POWERSTEALER)
	{
		addexp += 5;
	}
	if (total_monsters < 30)
		flawless_bonus += addexp * .55;
	else
		flawless_bonus += addexp * 1.15;
	flawless_bonus = ceil(flawless_bonus);
	if (targ.lives == -1)
		addexp = 0;
	if (survival_mode)
		if (targ.is_monster == #TRUE)
			addexp = ceil(addexp * .4);						// less exp.
	if (plyr.mtf_items & MTFITEM_DIVIDE_EXP)
		addexp = floor(addexp * .25);
	if (override_exp != #FALSE)
		addexp = override_exp;
	if (override_exp == #FALSE)
		addexp = ceil( addexp * Coop_ExpCurve() );
	if (targ.is_minion == #FALSE)
		if (targ != world)
			targ.#gold = addexp;
	if (targ.#other_attacker != world && targ.#other_attacker != plyr && targ.#other_attacker.classname == "player" && addexp > 0)
	{
		addexp = ceil( addexp * .5 );
		self = targ.#other_attacker;
		MTF_Coop_CheckNewLevel( targ.#other_attacker.coop_exp, targ.#other_attacker.coop_exp + addexp );	// check if player levels up
		self = oself;
		targ.#other_attacker.coop_exp = targ.#other_attacker.coop_exp + addexp;
		Achievements_Change( targ.#other_attacker, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_HELPER, 1 );
	}
	if ( plyr.#rune_time > time )
	{
		if ( plyr.#rune_type == #RUNE_EXPBONUS )
		{
			if ( !override_exp )
			{
				addexp *= 2;
			}
		}
		if ( plyr.#rune_type == #RUNE_UBEREXP )
		{
			if ( !override_exp )
			{
				addexp *= 4;
			}
		}
	}
	self = plyr;
	MTF_Coop_CheckNewLevel( plyr.coop_exp, plyr.coop_exp + addexp );	// check if player levels up
	self = oself;
	plyr.coop_exp = plyr.coop_exp + addexp;
	CSQC_SendExperience(plyr, plyr.coop_exp);
	if (targ.#other_attacker)
		CSQC_SendExperience(targ.#other_attacker, targ.#other_attacker.coop_exp);
	if (targ.classname == "monster_juggernaut")
		Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_HEAVYMETAL, 1 );
	else
	if (targ.classname == "monster_shambler")
		Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_SHAMBLER, 1 );
	if (deathmsg == 22)
		Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_BLADERUNNER, 1 );
	else
	if (deathmsg == 12)
		Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_ATOMICPUNK, 1 );
	else
	if (deathmsg == 446 || deathmsg == 447)
		Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_BAT, 1 );
	if (lms_entity == world)
		Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_KILLINGMACHINE, 1 );
};
void (entity plyr, string nname, float exp) MTF_Coop_PreWriteExperience =
{
	local entity oself;
	nname = strzone(nname);
	oself = self;
	self = plyr;
	MTF_Coop_WriteExperience( self.connect_name/*nname*/, exp );
	self = oself;
	strunzone(nname);
};
void () MTF_Coop_UpdateMapRanks =
{
	local float old_best_time, new_best_time;
	local float old_best_record, new_best_record;
	local string old_best_player, new_best_player;
	local string a;
	local string filename;
	local float file;
	local entity plyr;
	if (total_monsters == 0)
		return;
	if (survival_mode)
	{
		if (killed_monsters < (total_monsters-12))
			return;
	}
	else
	if (killed_monsters < total_monsters)
			return;
	filename = frik_strcat( "ranks/maps/", mapname, ".tfi" );
	new_best_time = time;
	plyr = find ( world, classname, "player" );
	while (plyr)
	{
		if (plyr.real_frags > new_best_record)
		{
			new_best_record = plyr.real_frags;
			new_best_player = plyr.connect_name;
			new_best_player = strzone(new_best_player);
			Achievements_Change( plyr, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_RECORD, 1 );
		}
		plyr = find (plyr, classname, "player");
	}
	file = open (filename, 0);
	if ((file == -1))
	{
		file = open (filename, 2);
		write (file, "// Best time, best player, best player frags\n");
		write (file, ftos(new_best_time));
		write (file, "\n");
		write (file, new_best_player);
		write (file, "\n");
		write (file, ftos(new_best_record));
		write (file, "\n");
		close (file);
	}
	else
	{
		a = read (file);	// text
		a = read (file);	// best time
		old_best_time = stof(a);
		a = read (file);	// player with highest frag count
		old_best_player = a;
		old_best_player = strzone(old_best_player);
		a = read (file);	// highest ranking player's frag count
		old_best_record = stof(a);
		close (file);
		file = open (filename, 2);
		write (file, "// Best time, best player, best player frags\n");
		if (new_best_time < old_best_time)
		{
			MTF_Coop_AddExpToAll ( (total_monsters * 2), frik_strcat("Congratulations! New best time record set for ", mapname, frik_strcat(": ", ftos(new_best_time), " seconds!\nExp Bonus for all!") ), #FALSE);
			Achievements_Change( world, world, ACHIEVEMENTS_GLOBALADD, ACHIEVEMENT_SPEEDY, 1 );
			write (file, ftos(new_best_time));
		}
		else
			write (file, ftos(old_best_time));
		write (file, "\n");
		if (new_best_record > old_best_record)
		{
			write (file, new_best_player);
			write (file, "\n");
			write (file, ftos(new_best_record));
			write (file, "\n");
		}
		else
		{
			write (file, old_best_player);
			write (file, "\n");
			write (file, ftos(old_best_record));
			write (file, "\n");
		}
		close (file);
		strunzone(old_best_player);
	}
	if (new_best_player != "" && new_best_player != string_null)
		strunzone(new_best_player);
};
void (string vname, float addness) MTF_Coop_RanksMapVote =
{
	local float vcnt;
	local string a;
	local float file, i, foundit;
	addness = 0;			// dummy var.. maybe for later use
	file = open ("topmaps.tfi", 0);
	if (file == -1)
	{
		bprint(2,"topmaps.tfi does not exist! Add it to /fortress or experience unholy amounts of crashes!\n");
		return;
	}
	i = 0;
	while (i < #MAX_MAPRANKS * 2)		// multiplied by 2 here because we have 2 lines for each stat - name on one line, # on next
	{
		i++;
		a = read (file);
		if (a == vname)
		{
			a = read (file);
			foundit = 1;
			vcnt = stof(a);
			break;
		}
		
	}
	close (file);
	vcnt++;
	file = open ("topmaps.tfi", 0);
	i = 0;
	while (i < #MAX_MAPRANKS * 2)
	{
		i++;
		a = read (file);
		a = read (file);
		if (stof(a) <= vcnt)
		{
			close (file);
			MTF_Coop_WriteNewMapRank( i, vname, vcnt );
			return;
			break;
		}
	}
	close (file);
};
void() FlareGrenadeTouch = 
{
if (other.classname == "player")
	bprint(2,"WTF\n");
	self.touch = SUB_Null;
	self.velocity = '0 0 0';
	if (pointcontents(self.origin) == -6)
	{
		newmis = spawn();
		setmodel(newmis, "progs/flare.spr");
		setorigin(newmis, self.origin - '0 0 30');
		newmis.movetype = 8;
		newmis.solid = TF_FLARE_OFF;
		newmis.effects = 4;
		newmis.effects = newmis.effects + TF_FLARE_OFF;
		sound(newmis, 3, "items/flare1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		newmis.velocity_z = -30;
		newmis.velocity_x = random() * 10;
		newmis.velocity_y = random() * 10;
		newmis.nextthink = time + 30;
		newmis.think = SUB_Remove;
		newmis.touch = SUB_Remove;
		newmis.classname = "flare";
		dremove(self);
	}
	else
	{
		local entity te, flame;
		local vector vtemp;
		te = findradius(self.origin, 50);
		while (te)
		{
			if (Coop_IsMonster(te, #MONSTERTYPE_NORMAL))
			{
				deathmsg = 1125;
				TF_T_Damage(te, self, self.owner, 100, 2, 16);
				
					if (te.numflames < TF_FLARE_OFF)
						flame = FlameSpawn("1", te);
					else
						flame = FlameSpawn("3", te);
						
					if (flame != world)
					{			// this caused a crashie before
						flame.classname = "fire";
						flame.health = 30;
						te.numflames = te.numflames + 1;
						flame.velocity = te.velocity;
						flame.enemy = te;
						flame.touch = OnPlayerFlame_touch;
						flame.owner = self;
						vtemp = te.origin;
						setorigin(flame, vtemp);
						flame.nextthink = time + 0.1;
						flame.think = FlameFollow;
					}
				
			}
			te = te.chain;
		}
		sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		self.movetype = 6;
	}
};
void() EMPGrenadeTouch = 
{
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
entity(string type, entity p_owner) FlameSpawn = 
{
	num_world_flames = num_world_flames + TF_FLARE_OFF;
	while (num_world_flames > 45)
	{
		if (!RemoveFlameFromQueue(type))
		{
			return world;
		}
	}
	newmis = spawn();
	if (type == "1")
	{
		newmis.movetype = 9;
		newmis.solid = 2;
		newmis.effects = 8;
		newmis.flame_id = "1";
		setmodel(newmis, "progs/flame2.mdl");
		setsize(newmis, '0 0 0', '0 0 0');
	}
	else
	{
		if (type == "2")
		{
			newmis.movetype = 10;
			newmis.solid = 2;
			newmis.flame_id = "2";
			setmodel(newmis, "progs/flame2.mdl");
			newmis.frame = TF_FLARE_OFF;
			setsize(newmis, '0 0 0', '0 0 0');
		}
		else
		{
			if (type == "3")
			{
				newmis.movetype = 9;
				newmis.solid = 2;
				newmis.flame_id = "3";
				setmodel(newmis, "progs/flame2.mdl");
				setsize(newmis, '0 0 0', '0 0 0');
			}
			else
			{
				if (type == "4")
				{
					newmis.movetype = 9;
					newmis.solid = 2;
					newmis.flame_id = "4";
					setmodel(newmis, "progs/flame2.mdl");
					newmis.frame = TF_FLARE_OFF;
					setsize(newmis, '0 0 0', '0 0 0');
				}
			}
		}
	}
	newmis.owner = p_owner;
	return newmis;
};
void (vector org, entity shooter) MirvGrenadeLaunch =
{
	local float xdir;
	local float ydir;
	local float zdir;
	xdir = ((150 * random ()) - 75);
	ydir = ((150 * random ()) - 75);
	zdir = (40 * random ());
	newmis = spawn ();
	newmis.owner = shooter;
	newmis.movetype = 10;
	newmis.solid = 2;
	newmis.classname = "grenade";
	newmis.weapon = 10;
	newmis.touch = GrenadeTouch;
	newmis.think = GrenadeExplode;
	newmis.nextthink = ((time + 2) + random ());
	newmis.velocity_x = (xdir * 2);
	newmis.velocity_y = (ydir * 2);
	newmis.velocity_z = (zdir * 15);
	newmis.avelocity = '250 300 400';
	setmodel (newmis,"progs/grenade2.mdl");
	setsize (newmis,'0 0 0','0 0 0');
	setorigin (newmis,org);
};
void() MoveFlag = 
{
	if ( (prematch) )// && (self.owner.items & 131072) )
	{
		T_Damage (self.owner, self.owner, self.owner, 500);
	}
	makevectors(self.owner.v_angle);
	setorigin(self, self.owner.origin - v_forward * 25 + '0 0 20');
	self.angles_x = self.owner.angles_z;
	self.angles_y = self.owner.angles_y + 90;
	self.angles_z = TF_FLARE_LIT - self.owner.angles_x;
	self.nextthink = time + 0.010000;
	self.think = MoveFlag;
	if (self.owner.deadflag)
	{
		self.owner.effects = self.owner.effects - (self.owner.effects & 128);
		self.owner.effects = self.owner.effects - (self.owner.effects & 64);
		dremove(self);
	}
	if (!(self.owner.items & 131072) && !(self.owner.items & 262144))
	{
		self.owner.effects = self.owner.effects - (self.owner.effects & 128);
		self.owner.effects = self.owner.effects - (self.owner.effects & 64);
		dremove(self);
	}
};
void () TF_PlaceItem =
{
	self.flags = 256;
	self.velocity = '0 0 0';
	self.movetype = 0;	// moved from above
	self.oldorigin = self.origin;
	if ((self.goal_activation & 512.000000))
	{
		self.effects = (self.effects | 8.000000);
	}
	if ((item_list_bit == 0.000000))
	{
		item_list_bit = 1.000000;
	}
	self.item_list = item_list_bit;
	item_list_bit = item_list_bit * 2.000000;
};
void () TF_StartItem =
{
	UpdateAbbreviations (self);
	self.nextthink = (time + 0.200000);
	self.think = TF_PlaceItem;
	if ((self.goal_state == 3.000000))
	{
		RemoveGoal (self);
	}
};
void () TF_PlaceGoal =
{
	local float oldz;
	if ((self.classname != "info_tfgoal_timer"))
	{
		if ((self.goal_activation & 1.000000))
		{
			self.touch = tfgoal_touch;
		}
	}
	else
	{
		self.think = tfgoal_timer_tick;
		self.nextthink = (time + self.search_time);
		self.classname = "info_tfgoal";
	}
	if (self.goal_activation & 2048)
	{
	self.movetype = MOVETYPE_TOSS;
	self.origin_z = self.origin_z + 6;
	oldz = self.origin_z;
	if (!droptofloor ())
	{
		dprint ("Goal fell out of level at ");
		dprint (vtos (self.origin));
		dprint ("\n");
		dremove (self);
		return;
	}
	}
	self.flags = 256.000000;
	self.movetype = 0.000000;
	self.velocity = '0.000000 0.000000 0.000000';
	self.oldorigin = self.origin;
};
void () TF_StartGoal =
{
	UpdateAbbreviations (self);
	self.nextthink = (time + 0.200000);
	self.think = TF_PlaceGoal;
	self.use = info_tfgoal_use;
	if ((self.goal_state == 3.000000))
	{
		RemoveGoal (self);
	}
};
void () info_tfdetect = 
{
	local entity te;
	local string st;
	UpdateAbbreviations (self);
	te = find (world,classname,"countdown");
	if (te != world) 
	{
	return;
	}
	st = infokey (world,"time");
	if (st == "off")
	{
	return;
	}
	newmis = spawn ();
	newmis.classname = "countdown";
	newmis.no_grenades_1 = 0;
	st = infokey (world,"timelimit");
	newmis.health = stof(st);
	newmis.think = review_timeleft;
	newmis.nextthink = (time + 1);
	if (haltloop1 != 1) 
	{
		local string msg1timer;
		msg1timer = infokey (world, "svmsg1");
		msg1time = stof(msg1timer);

		if (msg1time > 0)
		{
			display_message ();
		}
		haltloop1 = 1;
	}
	if (haltloop2 != 1)
	{
		local string msg2timer;
		msg2timer = infokey (world, "svmsg2");
		msg2time = stof(msg2timer);
		if (msg2time > 0)
		{
			pre_messagetimer2 ();
		}
		haltloop2 = 1;
	}
	if (haltloop3 != 1)
	{
		local string msg3timer;
		msg3timer = infokey (world, "svmsg3");
		msg3time = stof(msg3timer);
		if (msg3time > 0)
		{
			pre_messagetimer3 ();
		}
		haltloop3 = 1;
	}
	if (quotestart != 1)
	{
	quotetimer ();
	quotestart = 1;
	}
};
void() info_player_teamspawn = 
{
	local entity te;
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (number_of_teams < self.team_no)
	{
		number_of_teams = self.team_no;
	}
	if (self.team_no <= TF_FLARE_LIT)
	{
		dprint("no team_no associated with info_player_teamspawn\n");
		dremove(self);
	}
	if (self.items != TF_FLARE_LIT)
	{
		te = Finditem(self.items);
		if (!te)
		{
			dprint("info_player_teamspawn specifies a GoalItem that does not exist\n");
			dremove(self);
		}
	}
	if (self.team_no == TF_FLARE_OFF)
	{
		self.team_str_home = "ts1";
	}
	else
	{
		if (self.team_no == 2)
		{
			self.team_str_home = "ts2";
		}
		else
		{
			if (self.team_no == 3)
			{
				self.team_str_home = "ts3";
			}
			else
			{
				if (self.team_no == 4)
				{
					self.team_str_home = "ts4";
				}
			}
		}
	}
};
void() i_p_t = 
{
	self.classname = "info_player_teamspawn";
	info_player_teamspawn();
};
void() info_tfgoal = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (self.mdl)
	{
		precache_model(self.mdl);
		precache_model2(self.mdl);
		setmodel(self, self.mdl);
	}
	if (self.noise)
	{
		precache_sound(self.noise);
		precache_sound2(self.noise);
	}
	else
	{
		if (self.mdl == "progs/backpack.mdl")
		{
			precache_sound("items/backpack.wav");
			self.noise = "items/backpack.wav";
		}
	}
	precache_sound2 ("items/protect.wav");
	precache_sound("items/protect2.wav");
	precache_sound("items/protect3.wav");
	precache_sound("items/suit.wav");
	precache_sound("items/suit2.wav");
	precache_sound("items/inv3.wav");
	precache_sound("items/damage.wav");
	precache_sound("items/damage2.wav");
	precache_sound("items/damage3.wav");
	self.solid = TF_FLARE_OFF;
	if (self.goal_state == TF_FLARE_LIT)
	{
		self.goal_state = 2;
	}
	if (self.goal_min != '0 0 0')
	{
		setsize(self, self.goal_min, self.goal_max);
	}
	else
	{
		setsize(self, '-16 -16 -24', '16 16 32');
	}
	TF_StartGoal();
};
void() i_t_g = 
{
	self.classname = "info_tfgoal";
	info_tfgoal();
};
void() info_tfgoal_timer = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (self.mdl)
	{
		precache_model(self.mdl);
		precache_model2(self.mdl);
		setmodel(self, self.mdl);
	}
	if (self.noise)
	{
		precache_sound(self.noise);
		precache_sound2(self.noise);
	}
	if (self.search_time <= TF_FLARE_LIT)
	{
		dprint("Timer Goal created with no specified time.\n");
		dremove(self);
	}
	self.solid = TF_FLARE_LIT;
	if (self.goal_state == TF_FLARE_LIT)
	{
		self.goal_state = 2;
	}
	setsize(self, '-16 -16 -24', '16 16 32');
	TF_StartGoal();
};
void() i_t_t = 
{
	self.classname = "info_tfgoal_timer";
	info_tfgoal_timer();
};
void() item_tfgoal = 
{
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (self.mdl)
	{
		precache_model(self.mdl);
		precache_model2(self.mdl);
		setmodel(self, self.mdl);
	}
	else
	{
		self.mdl = "";
		setmodel(self, "");
	}
	precache_sound("items/itembk2.wav");
	if (self.noise)
	{
		precache_sound(self.noise);
		precache_sound2(self.noise);
	}
	self.touch = item_tfgoal_touch;
	if (self.goal_state == TF_FLARE_LIT)
	{
		self.goal_state = 2;
	}
	self.solid = TF_FLARE_OFF;
	setorigin(self, self.origin);
	if (!(self.netname))
	{
		self.netname = "goalitem";
	}
	if (self.pausetime <= TF_FLARE_LIT)
	{
		self.pausetime = 60;
	}
	if (self.delay != TF_FLARE_LIT && self.pausetime == TF_FLARE_LIT)
	{
		self.pausetime = self.delay;
	}
	setsize(self, '-16 -16 -24', '16 16 32');
	TF_StartItem();
};
void(entity AD) ParseTFDetect = 
{

	#SETVERSION
	team1lives = AD.ammo_shells;
	team2lives = AD.ammo_nails;
	team3lives = AD.ammo_rockets;
	team4lives = AD.ammo_cells;
	if (team1lives == TF_FLARE_LIT)
	{
		team1lives = -1;
	}
	if (team2lives == TF_FLARE_LIT)
	{
		team2lives = -1;
	}
	if (team3lives == TF_FLARE_LIT)
	{
		team3lives = -1;
	}
	if (team4lives == TF_FLARE_LIT)
	{
		team4lives = -1;
	}
	if (AD.hook_out == TF_FLARE_OFF)
	{
		allow_hook = TF_FLARE_LIT;
	}
	team1maxplayers = AD.ammo_medikit;
	team2maxplayers = AD.ammo_detpack;
	team3maxplayers = AD.maxammo_medikit;
	team4maxplayers = AD.maxammo_detpack;
	if (team1maxplayers == TF_FLARE_LIT)
	{
		team1maxplayers = 30;
	}
	if (team2maxplayers == TF_FLARE_LIT)
	{
		team2maxplayers = 30;
	}
	if (team3maxplayers == TF_FLARE_LIT)
	{
		team3maxplayers = 30;
	}
	if (team4maxplayers == TF_FLARE_LIT)
	{
		team4maxplayers = 30;
	}
	illegalclasses = AD.playerclass;
	illegalclasses1 = AD.maxammo_shells;
	illegalclasses2 = AD.maxammo_nails;
	illegalclasses3 = AD.maxammo_rockets;
	illegalclasses4 = AD.maxammo_cells;
	civilianteams = TF_FLARE_LIT;
	if (illegalclasses1 == -1)
	{
		illegalclasses1 = TF_FLARE_LIT;
		civilianteams = civilianteams | TF_FLARE_OFF;
	}
	if (illegalclasses2 == -1)
	{
		illegalclasses2 = TF_FLARE_LIT;
		civilianteams = civilianteams | 2;
	}
	if (illegalclasses3 == -1)
	{
		illegalclasses3 = TF_FLARE_LIT;
		civilianteams = civilianteams | 4;
	}
	if (illegalclasses4 == -1)
	{
		illegalclasses4 = TF_FLARE_LIT;
		civilianteams = civilianteams | 8;
	}
};
entity(float ino) Finditem = 
{
	local entity tg;
	local string st;
	tg = find(world, classname, "item_tfgoal");
	while (tg)
	{
		if (tg.goal_no == ino)
		{
			return tg;
		}
		tg = find(tg, classname, "item_tfgoal");
	}
	dprint("Could not find an item with a goal_no of ");
	st = ftos(ino);
	dprint(st);
	dprint(".\n");
	return world;
};
entity(float gno) Findgoal = 
{
	local entity tg;
	local string st;
	tg = find(world, classname, "info_tfgoal");
	while (tg)
	{
		if (tg.goal_no == gno)
		{
			return tg;
		}
		tg = find(tg, classname, "info_tfgoal");
	}
	dprint("Could not find a goal with a goal_no of ");
	st = ftos(gno);
	dprint(st);
	dprint(".\n");
	return(tg);		// is returning an empty entity safe? hmm
};
entity(float gno) Findteamspawn = 
{
	local entity tg;
	local string st;
	tg = find(world, classname, "info_player_teamspawn");
	while (tg)
	{
		if (tg.goal_no == gno)
		{
			return tg;
		}
		tg = find(tg, classname, "info_player_teamspawn");
	}
	dprint("Could not find a Teamspawn with a goal_no of ");
	st = ftos(gno);
	dprint(st);
	dprint(".\n");
	return(tg);		// is returning an empty entity safe? hmm
};
void(entity Goal) InactivateGoal = 
{
	if (Goal.goal_state == TF_FLARE_OFF)
	{
		if (Goal.search_time == TF_FLARE_LIT)
		{
			Goal.solid = TF_FLARE_OFF;
		}
		Goal.goal_state = 2;
		if (Goal.mdl != string_null)
		{
			setmodel(Goal, Goal.mdl);
		}
	}
};
void(entity Goal) RestoreGoal = 
{
	if (Goal.goal_state == 3)
	{
		if (Goal.search_time == TF_FLARE_LIT)
		{
			Goal.solid = TF_FLARE_OFF;
		}
		else
		{
			Goal.nextthink = time + Goal.search_time;
		}
		Goal.goal_state = 2;
		if (Goal.mdl != string_null)
		{
			setmodel(Goal, Goal.mdl);
		}
	}
};
void(entity Goal) RemoveGoal = 
{
	Goal.solid = TF_FLARE_LIT;
	Goal.goal_state = 3;
	if (Goal.mdl != string_null)
	{
		setmodel(Goal, string_null);
	}
};
float(entity Goal, entity Player, entity AP) IsAffectedBy = 
{
	local float genv;
	if (Player.playerclass == TF_FLARE_LIT)
	{
		return TF_FLARE_LIT;
	}
	if (Goal.goal_effects & 32)
	{
		genv = pointcontents(Goal.origin);
		if (pointcontents(Player.origin) != genv)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.t_length != TF_FLARE_LIT)
	{
		if (vlen(Goal.origin - Player.origin) <= Goal.t_length)
		{
			if (Goal.goal_effects & 16)
			{
				traceline(Goal.origin, Player.origin, TF_FLARE_OFF, Goal);
				if (trace_fraction == TF_FLARE_OFF)
				{
					return TF_FLARE_OFF;
				}
			}
			else
			{
				return TF_FLARE_OFF;
			}
		}
	}
	if (Goal.classname != "info_tfgoal_timer")
	{
		if (Goal.goal_effects & TF_FLARE_OFF && Player == AP)
		{
			return TF_FLARE_OFF;
		}
		if (Goal.goal_effects & 2 && AP.team_no == Player.team_no)
		{
			return TF_FLARE_OFF;
		}
		if (Goal.goal_effects & 4 && AP.team_no != Player.team_no)
		{
			return TF_FLARE_OFF;
		}
		if (Goal.goal_effects & 8 && Player != AP)
		{
			return TF_FLARE_OFF;
		}
	}
	if (Goal.maxammo_shells != TF_FLARE_LIT && Player.team_no == Goal.maxammo_shells)
	{
		return TF_FLARE_OFF;
	}
	if (Goal.maxammo_nails != TF_FLARE_LIT && Player.team_no != Goal.maxammo_shells)
	{
		return TF_FLARE_OFF;
	}
	return TF_FLARE_LIT;
};
void(entity Goal, entity Player, entity AP, float addb) Apply_Results = 
{
	local entity oldself;
	local entity te;
	local entity oldte;
	local float oa;
	stuffcmd(Player, "bf\n");
	if (Goal.classname == "item_tfgoal")
	{
		Player.item_list = Player.item_list | Goal.item_list;
	}
	if (Player == AP)
	{
		if (Goal.count != TF_FLARE_LIT)
		{
			if (Player.team_no > TF_FLARE_LIT)
			{
				TeamFortress_TeamIncreaseScore(Player.team_no, Goal.count);
				TeamFortress_TeamShowScores(2);
			}
		}
	}
	if (addb)
	{
		if (Player.health > TF_FLARE_LIT)
		{
			if (Goal.health > TF_FLARE_LIT)
			{
				T_Heal(Player, Goal.health, TF_FLARE_LIT);
			}
			if (Goal.health < TF_FLARE_LIT)
			{
				if (TF_FLARE_LIT - Player.health > Goal.health)
				{
					Player.armorvalue = TF_FLARE_LIT;
					T_Damage(Player, Goal, Goal, Player.health + TF_FLARE_OFF);
				}
				else
				{
					oa = Player.armorvalue;
					Player.armorvalue = TF_FLARE_LIT;
					T_Damage(Player, Goal, Goal, TF_FLARE_LIT - Goal.health);
					Player.armorvalue = oa;
				}
			}
		}
		if (Player.health > TF_FLARE_LIT)
		{
			if (Goal.armortype)
			{
				Player.armortype = Goal.armortype;
			}
			Player.armorvalue = Player.armorvalue + Goal.armorvalue;
			if (Goal.armorclass)
			{
				Player.armorclass = Goal.armorclass;
			}
			if (Goal.gravity > TF_FLARE_LIT)
			{
				Player.gravity = Goal.gravity;
			}
			Player.ammo_shells = Player.ammo_shells + Goal.ammo_shells;
			Player.ammo_nails = Player.ammo_nails + Goal.ammo_nails;
			Player.ammo_rockets = Player.ammo_rockets + Goal.ammo_rockets;
			Player.ammo_cells = Player.ammo_cells + Goal.ammo_cells;
			Player.ammo_medikit = Player.ammo_medikit + Goal.ammo_medikit;
			Player.ammo_detpack = Player.ammo_detpack + Goal.ammo_detpack;
			Player.no_grenades_1 = Player.no_grenades_1 + Goal.no_grenades_1;
			Player.no_grenades_2 = Player.no_grenades_2 + Goal.no_grenades_2;
			if (Player.ammo_detpack > Player.maxammo_detpack)
			{
				Player.ammo_detpack = Player.maxammo_detpack;
			}
			if (Goal.invincible_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 1048576;
				Player.invincible_time = TF_FLARE_OFF;
				Player.invincible_finished = time + Goal.invincible_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 32;
					Player.invincible_finished = time + 666;
				}
			}
			if (Goal.invisible_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 524288;
				Player.invisible_time = TF_FLARE_OFF;
				Player.invisible_finished = time + Goal.invisible_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 64;
					Player.invisible_finished = time + 666;
				}
			}
			if (Goal.super_damage_finished > TF_FLARE_LIT)
			{
				Player.mtf_items |= MTFITEM_DIVIDE_EXP;
				Player.items = Player.items | 4194304;
				Player.super_time = TF_FLARE_OFF;
				Player.super_damage_finished = time + Goal.super_damage_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 128;
					Player.super_damage_finished = time + 666;
				}
			}
			if (Goal.radsuit_finished > TF_FLARE_LIT)
			{
				Player.items = Player.items | 2097152;
				Player.rad_time = TF_FLARE_OFF;
				Player.radsuit_finished = time + Goal.radsuit_finished;
				if (Goal.classname == "item_tfgoal")
				{
					Player.tfstate = Player.tfstate | 256;
					Player.radsuit_finished = time + 666;
				}
			}
		}
		Player.lives = Player.lives + Goal.lives;
		Player.real_frags = Player.real_frags + Goal.frags;
		if (!(toggleflags & 128))
		{
			Player.frags = Player.real_frags;
		}
		
		oldself = self;
		self = Player;
		TeamFortress_CheckClassStats();
		W_SetCurrentAmmo();
		self = oldself;
	}
	if (Player.playerclass == 8 && (Goal.goal_result & 16))
	{
		self.immune_to_check = time + 4;
		Spy_RemoveDisguise(Player);
	}
	if (Goal.items != TF_FLARE_LIT && Goal.classname != "item_tfgoal")
	{
		te = Finditem(Goal.items);
		if (te)
		{
			tfgoalitem_GiveToPlayer(te, Player, Goal);
		}
	}
	if (Goal.axhitme != TF_FLARE_LIT)
	{
		te = Finditem(Goal.axhitme);
		if (te.owner == Player)
		{
			tfgoalitem_RemoveFromPlayer(te, Player, TF_FLARE_OFF);
		}
	}
	if (Goal.remove_item_group != TF_FLARE_LIT)
	{
		te = find(world, classname, "item_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.remove_item_group && te.owner == AP)
			{
				oldte = te;
				te = find(te, classname, "item_tfgoal");
				tfgoalitem_RemoveFromPlayer(oldte, Player, TF_FLARE_OFF);
			}
			else
			{
				te = find(te, classname, "item_tfgoal");
			}
		}
	}
	if (Goal.display_item_status1 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status1);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Goal.display_item_status2 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status2);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Goal.display_item_status3 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status3);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Goal.display_item_status4 != TF_FLARE_LIT)
	{
		te = Finditem(Goal.display_item_status4);
		if (te)
		{
			DisplayItemStatus(Goal, Player, te);
		}
		else
		{
			sprint(Player, 2, "Item is missing.\n");
		}
	}
	if (Player.autodiscard)
	{
		oldself = self;
		self = Player;
		TeamFortress_Discard ();
		self = oldself;
	}
	if (Goal.goal_result & 32.000000)
	{
		ForceRespawn (Player);
	}
};
void(entity Goal, entity Player) RemoveResults = 
{
	local entity oldself;
	local entity te;
	local float puinvin;
	local float puinvis;
	local float puquad;
	local float purad;
	if (Goal.classname == "item_tfgoal")
	{
		if (!(Player.item_list & Goal.item_list))
		{
			return;
		}
		if (Goal.goal_activation & 1024)
		{
			return;
		}
		Player.item_list = Player.item_list - (Player.item_list & Goal.item_list);
	}
	if (Goal.health > TF_FLARE_LIT)
	{
		TF_T_Damage(Player, Goal, Goal, Goal.health, TF_FLARE_OFF, TF_FLARE_LIT);
	}
	if (Goal.health < TF_FLARE_LIT)
	{
		T_Heal(Player, TF_FLARE_LIT - Goal.health, TF_FLARE_LIT);
	}
	Player.lives = Player.lives - Goal.lives;
	Player.armortype = Player.armortype - Goal.armortype;
	Player.armorvalue = Player.armorvalue - Goal.armorvalue;
	Player.armorclass = Player.armorclass - (Player.armorclass & Goal.armorclass);
	Player.real_frags = Player.real_frags - Goal.frags;
	if (!(toggleflags & 128))
	{
		Player.frags = Player.real_frags;
	}
	Player.ammo_shells = Player.ammo_shells - Goal.ammo_shells;
	Player.ammo_nails = Player.ammo_nails - Goal.ammo_nails;
	Player.ammo_rockets = Player.ammo_rockets - Goal.ammo_rockets;
	Player.ammo_cells = Player.ammo_cells - Goal.ammo_cells;
	Player.ammo_medikit = Player.ammo_medikit - Goal.ammo_medikit;
	Player.ammo_detpack = Player.ammo_detpack - Goal.ammo_detpack;
	Player.no_grenades_1 = Player.no_grenades_1 - Goal.no_grenades_1;
	Player.no_grenades_2 = Player.no_grenades_2 - Goal.no_grenades_2;
	puinvin = TF_FLARE_LIT;
	puinvis = TF_FLARE_LIT;
	puquad = TF_FLARE_LIT;
	purad = TF_FLARE_LIT;
	te = find(world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == Player && te != Goal)
		{
			if (te.invincible_finished > TF_FLARE_LIT)
			{
				puinvin = TF_FLARE_OFF;
			}
			if (te.invisible_finished > TF_FLARE_LIT)
			{
				puinvis = TF_FLARE_OFF;
			}
			if (te.super_damage_finished > TF_FLARE_LIT)
			{
				puquad = TF_FLARE_OFF;
			}
			if (te.radsuit_finished > TF_FLARE_LIT)
			{
				purad = TF_FLARE_OFF;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (Goal.invincible_finished > TF_FLARE_LIT && !puinvin)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 32);
		Player.items = Player.items | 1048576;
		Player.invincible_time = TF_FLARE_OFF;
		Player.invincible_finished = time + Goal.invincible_finished;
	}
	if (Goal.invisible_finished > TF_FLARE_LIT && !puinvis)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 64);
		Player.items = Player.items | 524288;
		Player.invisible_time = TF_FLARE_OFF;
		Player.invisible_finished = time + Goal.invisible_finished;
	}
	if (Goal.super_damage_finished > TF_FLARE_LIT && !puquad)
	{
		Player.mtf_items |= MTFITEM_DIVIDE_EXP;
		Player.tfstate = Player.tfstate - (Player.tfstate & 128);
		Player.items = Player.items | 4194304;
		Player.super_time = TF_FLARE_OFF;
		Player.super_damage_finished = time + Goal.super_damage_finished;
	}
	if (Goal.radsuit_finished > TF_FLARE_LIT && !purad)
	{
		Player.tfstate = Player.tfstate - (Player.tfstate & 256);
		Player.items = Player.items | 2097152;
		Player.rad_time = TF_FLARE_OFF;
		Player.radsuit_finished = time + Goal.radsuit_finished;
	}
	oldself = self;
	self = Player;
	TeamFortress_CheckClassStats();
	W_SetCurrentAmmo();
	self = oldself;
};
float(entity Goal, entity AP) APMeetsCriteria = 
{
	local float gotone;
	local entity te;
	if (AP != world)
	{
		if (Goal.team_no)
		{
			if (Goal.team_no != AP.team_no)
			{
				return TF_FLARE_LIT;
			}
		}
		if (Goal.playerclass)
		{
			if (Goal.playerclass != AP.playerclass)
			{
				return TF_FLARE_LIT;
			}
		}
		if (Goal.items_allowed)
		{
			te = Finditem(Goal.items_allowed);
			if (te.owner != AP)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	if (Goal.if_goal_is_active)
	{
		te = Findgoal(Goal.if_goal_is_active);
		if (te.goal_state != TF_FLARE_OFF)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.if_goal_is_inactive)
	{
		te = Findgoal(Goal.if_goal_is_inactive);
		if (te.goal_state != 2)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.if_goal_is_removed)
	{
		te = Findgoal(Goal.if_goal_is_removed);
		if (te.goal_state != 3)
		{
			return TF_FLARE_LIT;
		}
	}
	if (Goal.if_group_is_active)
	{
		te = find(world, classname, "info_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.if_group_is_active)
			{
				if (te.goal_state != TF_FLARE_OFF)
				{
					return TF_FLARE_LIT;
				}
			}
			te = find(te, classname, "info_tfgoal");
		}
	}
	if (Goal.if_group_is_inactive)
	{
		te = find(world, classname, "info_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.if_group_is_inactive)
			{
				if (te.goal_state != 2)
				{
					return TF_FLARE_LIT;
				}
			}
			te = find(te, classname, "info_tfgoal");
		}
	}
	if (Goal.if_group_is_removed)
	{
		te = find(world, classname, "info_tfgoal");
		while (te)
		{
			if (te.group_no == Goal.if_group_is_removed)
			{
				if (te.goal_state != 3)
				{
					return TF_FLARE_LIT;
				}
			}
			te = find(te, classname, "info_tfgoal");
		}
	}
	if (Goal.if_item_has_moved)
	{
		te = Finditem(Goal.if_item_has_moved);
		if (te)
		{
			if (te.goal_state != TF_FLARE_OFF && te.origin == te.oldorigin)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	if (Goal.if_item_hasnt_moved)
	{
		te = Finditem(Goal.if_item_hasnt_moved);
		if (te)
		{
			if (te.goal_state == TF_FLARE_OFF || te.origin != te.oldorigin)
			{
				return TF_FLARE_LIT;
			}
		}
	}
	if (AP != world)
	{
		gotone = 0;
		if (Goal.has_item_from_group)
		{
			te = find (world, classname, "item_tfgoal");
			while ((te != world) && !gotone)
			{
				if ((te.group_no == Goal.has_item_from_group) && (te.owner == AP))
				gotone = 1;
				te = find (te, classname, "item_tfgoal");
			}
			if (!gotone)
			return (0);
		}
		if (Goal.hasnt_item_from_group)
		{
			te = find (world, classname, "item_tfgoal");
			while ((te != world) && !gotone)
			{
				if ((te.group_no == Goal.hasnt_item_from_group) && (te.owner == AP))
				return (0);
			te = find (te, classname, "item_tfgoal");
			}
		}
	}
	return (1);
};
void(entity Goal) SetupRespawn = 
{
	if (Goal.search_time != TF_FLARE_LIT)
	{
		InactivateGoal(Goal);
		Goal.think = tfgoal_timer_tick;
		Goal.nextthink = time + Goal.search_time;
		return;
	}
	if (Goal.goal_result & TF_FLARE_OFF)
	{
		RemoveGoal(Goal);
		return;
	}
	if (Goal.wait > TF_FLARE_LIT)
	{
		if (self.mdl == "progs/backpack.mdl" && !self.noise3)
		{
			if (infokey(world,"newpacks") == "on" || infokey(world,"newpacks") == "1")
			{
				setmodel(self, "");
			}
		}
		Goal.nextthink = time + Goal.wait;
		Goal.think = DoRespawn;
		return;
	}
	else
	{
		if (Goal.wait == -1)
		{
			return;
		}
	}
	InactivateGoal(Goal);
};
void() DoRespawn = 
{
	RestoreGoal(self);
	InactivateGoal(self);
};
float(entity Goal, entity AP) Activated = 
{
	local float APMet;
	local float RevAct;
	local float Act;
	if (Goal.goal_state == TF_FLARE_OFF)
	{
		return TF_FLARE_LIT;
	}
	if (Goal.goal_state == 3)
	{
		return TF_FLARE_LIT;
	}
	if (Goal.goal_state == 4)
	{
		return TF_FLARE_LIT;
	}
	APMet = APMeetsCriteria(Goal, AP);
	if (Goal.classname == "item_tfgoal")
	{
		RevAct = Goal.goal_activation & 64;
	}
	else
	{
		RevAct = Goal.goal_activation & 4;
	}
	Act = TF_FLARE_LIT;
	if (APMet)
	{
		if (!RevAct)
		{
			Act = TF_FLARE_OFF;
		}
	}
	else
	{
		if (RevAct)
		{
			Act = TF_FLARE_OFF;
		}
	}
	return Act;
};
void(entity Goal, entity AP, entity ActivatingGoal) AttemptToActivate = 
{
	local entity te;
	if (Activated(Goal, AP))
	{
		if (ActivatingGoal == Goal)
		{
			DoResults(Goal, AP, TF_FLARE_OFF);
		}
		else
		{
			if (ActivatingGoal != world)
			{
				DoResults(Goal, AP, ActivatingGoal.goal_result & 2);
			}
			else
			{
				DoResults(Goal, AP, TF_FLARE_LIT);
			}
		}
	}
	else
	{
		if (Goal.else_goal != TF_FLARE_LIT)
		{
			te = Findgoal(Goal.else_goal);
			if (te)
			{
				AttemptToActivate(te, AP, ActivatingGoal);
			}
		}
	}
};
void(entity Goal, entity AP) DoGoalWork = 
{
	local entity te;
	local entity RI;
	if (Goal.activate_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.activate_goal_no);
		if (te)
		{
			AttemptToActivate(te, AP, Goal);
		}
	}
	if (Goal.inactivate_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.inactivate_goal_no);
		if (te)
		{
			InactivateGoal(te);
		}
	}
	if (Goal.restore_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.restore_goal_no);
		if (te)
		{
			RestoreGoal(te);
		}
	}
	if (Goal.remove_goal_no != TF_FLARE_LIT)
	{
		te = Findgoal(Goal.remove_goal_no);
		if (te)
		{
			RemoveGoal(te);
		}
	}
	if (Goal.return_item_no != TF_FLARE_LIT)
	{
		te = Finditem(Goal.return_item_no);
		if (te)
		{
			if (te.goal_state == TF_FLARE_OFF)
			{
				tfgoalitem_RemoveFromPlayer(te, te.owner, TF_FLARE_OFF);
			}
			RI = spawn();
			RI.enemy = te;
			RI.think = ReturnItem;
			RI.nextthink = time + 0.1;
			te.solid = TF_FLARE_LIT;
		}
	}
	if (Goal.remove_spawnpoint != TF_FLARE_LIT)
	{
		te = Findteamspawn(Goal.remove_spawnpoint);
		if (te)
		{
			te.goal_state = 3;
			te.team_str_home = string_null;
		}
	}
	if (Goal.restore_spawnpoint != TF_FLARE_LIT)
	{
		te = Findteamspawn(Goal.restore_spawnpoint);
		if (te)
		{
			if (te.goal_state == 3)
			{
				te.goal_state = 2;
				if (te.team_no == TF_FLARE_OFF)
				{
					te.team_str_home = "ts1";
				}
				else
				{
					if (te.team_no == 2)
					{
						te.team_str_home = "ts2";
					}
					else
					{
						if (te.team_no == 3)
						{
							te.team_str_home = "ts3";
						}
						else
						{
							if (te.team_no == 4)
							{
								te.team_str_home = "ts4";
							}
						}
					}
				}
			}
		}
	}
};
void(entity Goal, entity AP) DoGroupWork = 
{
	local string st;
	local entity tg;
	local float allset;
	if (Goal.all_active != TF_FLARE_LIT)
	{
		if (Goal.last_impulse == TF_FLARE_LIT)
		{
			dprint("Goal ");
			st = ftos(Goal.goal_no);
			dprint(st);
			dprint(" has a .all_active specified, but no .last_impulse\n");
		}
		else
		{
			allset = TF_FLARE_OFF;
			tg = find(world, classname, "info_tfgoal");
			while (tg)
			{
				if (tg.group_no == Goal.all_active)
				{
					if (tg.goal_state != TF_FLARE_OFF)
					{
						allset = TF_FLARE_LIT;
					}
				}
				tg = find(tg, classname, "info_tfgoal");
			}
			if (allset)
			{
				tg = Findgoal(Goal.last_impulse);
				if (tg)
				{
					DoResults(tg, AP, Goal.goal_result & 2);
				}
			}
		}
	}
	if (Goal.activate_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.activate_group_no)
			{
				DoResults(tg, AP, TF_FLARE_LIT);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.inactivate_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.inactivate_group_no)
			{
				InactivateGoal(tg);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.remove_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.remove_group_no)
			{
				RemoveGoal(tg);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.restore_group_no != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_tfgoal");
		while (tg)
		{
			if (tg.group_no == Goal.restore_group_no)
			{
				RestoreGoal(tg);
			}
			tg = find(tg, classname, "info_tfgoal");
		}
	}
	if (Goal.remove_spawngroup != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_player_teamspawn");
		while (tg)
		{
			if (tg.group_no == Goal.remove_spawngroup)
			{
				tg.goal_state = 3;
				tg.team_str_home = string_null;
			}
			tg = find(tg, classname, "info_player_teamspawn");
		}
	}
	if (Goal.restore_spawngroup != TF_FLARE_LIT)
	{
		tg = find(world, classname, "info_player_teamspawn");
		while (tg)
		{
			if (tg.group_no == Goal.restore_spawngroup)
			{
				tg.goal_state = 2;
				if (tg.team_no == TF_FLARE_OFF)
				{
					tg.team_str_home = "ts1";
				}
				else
				{
					if (tg.team_no == 2)
					{
						tg.team_str_home = "ts2";
					}
					else
					{
						if (tg.team_no == 3)
						{
							tg.team_str_home = "ts3";
						}
						else
						{
							if (tg.team_no == 4)
							{
								tg.team_str_home = "ts4";
							}
						}
					}
				}
			}
			tg = find(tg, classname, "info_player_teamspawn");
		}
	}
};
void(entity Item, entity AP) DoItemGroupWork = 
{
	local entity tg;
	local entity carrier;
	local float allcarried;
	local string st;
	allcarried = TF_FLARE_OFF;
	if (Item.distance != TF_FLARE_LIT)
	{
		if (Item.pain_finished == TF_FLARE_LIT)
		{
			dprint("GoalItem ");
			st = ftos(Item.goal_no);
			dprint(st);
			dprint(" has a .distance specified, but no .pain_finished\n");
		}
		tg = find(world, classname, "item_tfgoal");
		while (tg)
		{
			if (tg.group_no == Item.distance)
			{
				if (tg.goal_state != TF_FLARE_OFF)
				{
					allcarried = TF_FLARE_LIT;
				}
			}
			tg = find(tg, classname, "item_tfgoal");
		}
		if (allcarried == TF_FLARE_OFF)
		{
			tg = Findgoal(Item.pain_finished);
			if (tg)
			{
				DoResults(tg, AP, Item.goal_result & 2);
			}
		}
	}
	allcarried = TF_FLARE_OFF;
	if (Item.speed != TF_FLARE_LIT)
	{
		if (Item.attack_finished == TF_FLARE_LIT)
		{
			dprint("GoalItem ");
			st = ftos(Item.goal_no);
			dprint(st);
			dprint(" has a .speed specified, but no .attack_finished\n");
		}
		carrier = world;
		tg = find(world, classname, "item_tfgoal");
		while (tg)
		{
			if (tg.group_no == Item.speed)
			{
				if (tg.goal_state != TF_FLARE_OFF)
				{
					allcarried = TF_FLARE_LIT;
				}
				else
				{
					if (carrier == world)
					{
						carrier = tg.owner;
					}
					else
					{
						if (carrier != tg.owner)
						{
							allcarried = TF_FLARE_LIT;
						}
					}
				}
			}
			tg = find(tg, classname, "item_tfgoal");
		}
		if (allcarried == TF_FLARE_OFF)
		{
			tg = Findgoal(Item.attack_finished);
			if (tg)
			{
				DoResults(tg, AP, Item.goal_result & 2);
			}
		}
	}
};
void(entity Goal, entity AP) DoTriggerWork = 
{
	local entity t;
	local entity stemp;
	local entity otemp;
	if (Goal.killtarget)
	{
		t = world;
		do
		{
			t = find(t, targetname, Goal.killtarget);
			if (t != world)
			{
				remove(t);
			}
		} while (t != world);
	}
	if (Goal.target)
	{
		t = world;
		activator = AP;
		do
		{
			t = find(t, targetname, Goal.target);
			if (t == world)
			{
				return;
			}
			stemp = self;
			otemp = other;
			self = t;
			other = stemp;
			if (self.use != SUB_Null)
			{
				if (self.use)
				{
					self.use();
				}
			}
			self = stemp;
			other = otemp;
			activator = AP;
		} while (t != world);
	}
};
void() tfgoal_touch = 
{
	if (!(self.goal_activation & TF_FLARE_OFF))
	{
		return;
	}
	if (other.classname != "player")
	{
		return;
	}
	if (self.goal_state == TF_FLARE_OFF)
	{
		return;
	}
	if (self.mdl == "progs/backpack.mdl" && !self.noise3)
	{
		if (infokey(world,"newpacks") == "on" || infokey(world,"newpacks") == "1")
		{
		local float resp;
		resp = FALSE;
		if (self.ammo_cells && other.ammo_cells < other.maxammo_cells)
			resp = TRUE;
		if (self.ammo_shells && other.ammo_shells < other.maxammo_shells)
			resp = TRUE;
 		if (self.ammo_rockets && other.ammo_rockets < other.maxammo_rockets)
			resp = TRUE;
		if (self.ammo_nails && other.ammo_nails < other.maxammo_nails)
			resp = TRUE;
		if (self.armorvalue && other.armorvalue < other.maxarmor)
			resp = TRUE;
		if (self.health && other.health < other.max_health)
			resp = TRUE;
		if (self.ammo_medikit && other.ammo_medikit < TeamFortress_GetMaxAmmo(other, 4))
			resp = TRUE;
		if (self.ammo_detpack && other.ammo_detpack < TeamFortress_GetMaxAmmo(other, 131072))
			resp = TRUE;
		if (resp == FALSE)
		{
			return;
		}
		}
	}
	AttemptToActivate(self, other, self);
};
void() info_tfgoal_use = 
{
	AttemptToActivate(self, activator, self);
};
void() tfgoal_timer_tick = 
{
	if (self.goal_state != 3)
	{
		if (APMeetsCriteria(self, world))
		{
			DoResults(self, world, TF_FLARE_OFF);
		}
		else
		{
			InactivateGoal(self);
			self.think = tfgoal_timer_tick;
			self.nextthink = time + self.search_time;
		}
	}
};
void() item_tfgoal_touch = 
{
	local entity te;
	if (other.classname != "player")
	{
		return;
	}
	if (other.health <= TF_FLARE_LIT)
	{
		return;
	}
	if (other.is_feigning)	// TF 2.9'd!
		return;
	if ( (self.tent == other) && (time < self.option5) )
	{
		return;
	}
	if (Activated(self, other))
	{
		tfgoalitem_GiveToPlayer(self, other, self);
		self.goal_state = TF_FLARE_OFF;
	}
	else
	{
		if (self.else_goal != TF_FLARE_LIT)
		{
			te = Findgoal(self.else_goal);
			if (te)
			{
				AttemptToActivate(te, other, self);
			}
		}
	}
};
void(entity Item, entity AP, entity Goal) tfgoalitem_GiveToPlayer = 
{
	Item.owner = AP;
	if (Item.mdl != string_null)
	{
		setmodel(Item, string_null);
	}
	Item.solid = TF_FLARE_LIT;
	if (Item.goal_activation & TF_FLARE_OFF)
	{
		AP.effects = AP.effects | 8;
	}
	if (Item.goal_activation & 2)
	{
		TeamFortress_SetSpeed(AP);
	}
	if (Item.goal_activation & 512)
	{
		Item.effects = Item.effects - (Item.effects | 8);
	}
	if (Item.items & 131072)
	{
		AP.items = AP.items | 131072;
		AP.effects = AP.effects | 64;
		newmis = spawn();
		newmis.owner = AP;
		newmis.movetype = 4;
		newmis.solid = TF_FLARE_LIT;
		setsize(newmis, '0 0 0', '0 0 0');
		newmis.angles = AP.angles;
		newmis.nextthink = time + 0.5;
		newmis.think = MoveFlag;
		newmis.skin = TF_FLARE_OFF;
		setmodel(newmis, "progs/tf_flag.mdl");
		setorigin(newmis, AP.origin);
	}
	if (Item.items & 262144)
	{
		AP.items = AP.items | 262144;
		AP.effects = AP.effects | 128;
		newmis = spawn();
		newmis.owner = AP;
		newmis.movetype = 4;
		newmis.solid = TF_FLARE_LIT;
		setsize(newmis, '0 0 0', '0 0 0');
		newmis.angles = AP.angles;
		newmis.nextthink = time + 0.5;
		newmis.think = MoveFlag;
		newmis.skin = 2;
		setmodel(newmis, "progs/tf_flag.mdl");
		setorigin(newmis, AP.origin);
	}
	if (Goal != Item)
	{
		if (Goal.goal_result & 8)
		{
			Item.goal_state = TF_FLARE_OFF;
			return;
		}
	}
	if (AP.playerclass == 8 && (Item.goal_result & 16))
	{
		AP.is_unabletospy = TF_FLARE_OFF;
	}
	DoResults(Item, AP, TF_FLARE_OFF);
	DoItemGroupWork(Item, AP);
};
void() ReturnItem = 
{
	self.enemy.goal_state = 2;
	self.enemy.solid = TF_FLARE_OFF;
	self.enemy.movetype = TF_FLARE_LIT;
	self.enemy.touch = item_tfgoal_touch;
	self.enemy.origin = self.enemy.oldorigin;
	if (self.enemy.mdl != string_null)
	{
		setmodel(self.enemy, self.enemy.mdl);
	}
	setorigin(self.enemy, self.enemy.origin);
	sound(self.enemy, 2, "items/itembk2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	tfgoalitem_checkgoalreturn(self.enemy);
	dremove(self);
};
void(entity Item, entity AP, float method2) mtf_tfgoalitem_RemoveFromPlayer = 
{
	local entity te;
	local float lighton;
	local float slowon;
	local float key1on;
	local float key2on;
	local float spyoff;
	local entity DelayReturn;
	if (Item == world)
	{
		dprint("error: tfgoalitem_RemoveFromPlayer(): Item == world");
		return;
	}
	lighton = TF_FLARE_LIT;
	slowon = TF_FLARE_LIT;
	key1on = TF_FLARE_LIT;
	key2on = TF_FLARE_LIT;
	spyoff = TF_FLARE_LIT;
	te = find(world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == AP && te != Item)
		{
			if (te.goal_activation & TF_FLARE_OFF)
			{
				lighton = TF_FLARE_OFF;
			}
			if (te.goal_activation & 2)
			{
				slowon = TF_FLARE_OFF;
			}
			if (te.items & 131072)
			{
				key1on = TF_FLARE_OFF;
			}
			if (te.items & 262144)
			{
				key2on = TF_FLARE_OFF;
			}
			if (te.goal_result & 16)
			{
				spyoff = TF_FLARE_OFF;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (!lighton)
	{
		if (AP.invincible_finished > time + 3)
		{
			lighton = TF_FLARE_OFF;
		}
	}
	if (!lighton)
	{
		AP.effects = AP.effects - (AP.effects & 8);
	}
	if (Item.goal_activation & 512)
	{
		Item.effects = Item.effects | 8;
	}
	if (!spyoff)
	{
		AP.is_unabletospy = TF_FLARE_LIT;
	}
	if (!key1on)
	{
		AP.items = AP.items - (AP.items & 131072);
	}
	if (!key2on)
	{
		AP.items = AP.items - (AP.items & 262144);
	}
	te = find(world, classname, "player");
	while (te != world)
	{
		if (IsAffectedBy(Item, te, AP))
		{
			RemoveResults(Item, te);
		}
		te = find(te, classname, "player");
	}
	if ((method2 == TF_FLARE_LIT) || (method2 == 2))
	{
		te = find(world, classname, "player");
		while (te != world)
		{
			if (te.team_no == Item.owned_by)
			{
				if (Item.team_drop != string_null)
				{
					CenterPrint2(te, "\n\n\n", Item.team_drop);
				}
				if (Item.netname_team_drop != string_null)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Item.netname_team_drop);
				}
			}
			else
			{
				if (Item.non_team_drop != string_null)
				{
					CenterPrint2(te, "\n\n\n", Item.non_team_drop);
				}
				if (Item.netname_non_team_drop != string_null)
				{
					sprint(te, 2, AP.netname);
					sprint(te, 2, Item.netname_non_team_drop);
				}
			}
			te = find(te, classname, "player");
		}
		if (Item.goal_activation & 8)
		{
			DelayReturn = spawn();
			DelayReturn.enemy = Item;
			DelayReturn.think = ReturnItem;
			DelayReturn.nextthink = time + 0.5;
		}
		else
		{
			if (Item.goal_activation & 4)
			{
				if (method2 == 0)
					mtf_tfgoalitem_drop(Item);
			}
			else
			{
				Item.owner = world;
				dremove(Item);
				TeamFortress_SetSpeed(AP);
				return;
			}
		}
		Item.owner = world;
		TeamFortress_SetSpeed(AP);
		return;
	}
	if (method2 == TF_FLARE_OFF)
	{
		if (Item.goal_activation & 16)
		{
			DelayReturn = spawn();
			DelayReturn.enemy = Item;
			DelayReturn.think = ReturnItem;
			DelayReturn.nextthink = time + 0.5;
			Item.owner = world;
			TeamFortress_SetSpeed(AP);
			return;
		}
		Item.solid = TF_FLARE_LIT;
		Item.owner = world;
		TeamFortress_SetSpeed(AP);
		return;
	}
	dprint("Invalid method passed into tfgoalitem_RemoveFromPlayer.\n");
};
void (entity Item, entity AP, float method3) tfgoalitem_RemoveFromPlayer =
{
	local entity te;
	local float lighton;
	local float slowon;
	local float key1on;
	local float key2on;
	local float spyoff;
	local entity DelayReturn;
	if (Item == world)
	{
		objerror ("error: tfgoalitem_RemoveFromPlayer(): Item == world");
		return;
	}
	lighton = 0;
	slowon = 0;
	key1on = 0;
	key2on = 0;
	spyoff = 0;
	te = find (world, classname, "item_tfgoal");
	while (te)
	{
	if ((te.owner == AP) && (te != Item))
	{
		if (te.goal_activation & 1)
		lighton = 1;
		if (te.goal_activation & 2)
		slowon = 1;
		if (te.items & 131072)
		key1on = 1;
		if (te.items & 262144)
		key2on = 1;
		if (te.goal_result & 16)
		spyoff = 1;
	}
	te = find (te, classname, "item_tfgoal");
	}
	if (!lighton)
	{
		if (AP.invincible_finished > (time + 3))
	{
		lighton = 1;
	}
	else
	if (AP.super_damage_finished > (time + 3))
	{
		lighton = 1;
	}
	}
	if (!lighton)
	{
		AP.effects = AP.effects - (AP.effects & 8);
		AP.effects = AP.effects - (AP.effects & 64);
		AP.effects = AP.effects - (AP.effects & 128);
	}
	if (Item.goal_activation & 512)
	Item.effects = Item.effects | 8;
	if (!spyoff)
	AP.is_unabletospy = 0;
	if (!key1on)
	AP.items = AP.items - (AP.items & 131072);
	if (!key2on)
	AP.items = AP.items - (AP.items & 262144);
	te = find (world, classname, "player");
	while (te != world)
	{
	if (IsAffectedBy (Item, te, AP))
	    RemoveResults (Item, te);
	te = find (te, classname, "player");
	}
	if ((method3 == 0) || (method3 == 2))
	{
	te = find (world, classname, "player");
	while (te != world)
	{
		if (te.team_no == Item.owned_by)
		{
			if (Item.team_drop != string_null)
				CenterPrint2 (te, "\n\n\n", Item.team_drop);
		if (Item.netname_team_drop != string_null)
			{
				sprint (te, 2, AP.netname, Item.netname_team_drop);
			}
		}
		else
		{
		if (Item.non_team_drop != string_null)
			CenterPrint2 (te, "\n\n\n", Item.non_team_drop);
		if (Item.netname_non_team_drop != string_null)
		{
			sprint (te, 2, AP.netname, Item.netname_non_team_drop);
		}
		}
		te = find (te, classname, "player");
	}
	if (Item.goal_activation & 8)
	{
		DelayReturn = spawn ();
		DelayReturn.enemy = Item;
		if (method3 == 0)
		{
			DelayReturn.weapon = 0;
		}
	else
	{
		DelayReturn.weapon = 1;
	}
	DelayReturn.think = ReturnItem;
	DelayReturn.nextthink = time + 0.5;
	}
	else
	{
	if (Item.goal_activation & 4)
		{
			if ((method3 == 2))
			{
				tfgoalitem_drop (Item, 1, AP);
			}
	else
		{
			tfgoalitem_drop (Item, 0, AP);
		}
		}
		else
		{
		Item.owner = world;
		dremove (Item);
		TeamFortress_SetSpeed (AP);
		return;
	    }
	}
	Item.owner = world;
	Item.flags = Item.flags - (Item.flags & 512);
	TeamFortress_SetSpeed (AP);
	return;
	}
	else
	{
	if (method3 == 1)
	{
		if (Item.goal_activation & 16)
		{
			DelayReturn = spawn ();
			DelayReturn.enemy = Item;
			DelayReturn.weapon = 2;
			DelayReturn.think = ReturnItem;
			DelayReturn.nextthink = time + 0.5;
			Item.owner = world;
			TeamFortress_SetSpeed (AP);
			return;
		}
	Item.solid = 0;
	Item.owner = world;
	TeamFortress_SetSpeed (AP);
	return;
	}
	}
	objerror ("Invalid method passed into tfgoalitem_RemoveFromPlayer.\n");
};
void() tfgoalitem_dropthink = 
{
	local float pos;
	if (self.no_bounce > time)
		self.movetype = 6;
	else
		self.movetype = 10; //6;
	if (self.pausetime != TF_FLARE_LIT)
	{
		pos = pointcontents(self.origin);
		if (pos == -4)
		{
			self.nextthink = time + self.pausetime / 4;
		}
		else
		{
			if (pos == -5)
			{
				self.nextthink = time + 5;
			}
			else
			{
				if (pos == -2 || pos == -6)
				{
					self.nextthink = time + 2;
				}
				else
				{
					self.nextthink = time + self.pausetime;
				}
			}
		}
		self.think = tfgoalitem_remove;
	}
};
void () tfgoalitem_droptouch =
{
	self.touch = item_tfgoal_touch;
	self.nextthink = time + .25;
	self.think = tfgoalitem_dropthink;
};
void(entity Item) mtf_tfgoalitem_drop = 
{
	Item.origin = Item.owner.origin - '0 0 8';
	Item.velocity_z = 1;
	Item.velocity_x = 0;
	Item.velocity_y = 0;
	Item.goal_state = 2;
	Item.movetype = 6;
	Item.solid = TF_FLARE_OFF;
	Item.touch = item_tfgoal_touch;
	setorigin(Item, Item.origin - '0 0 16');
	setsize(Item, '-16 -16 0', '16 16 56');
	if (Item.mdl != string_null)
	{
		setmodel(Item, Item.mdl);
	}
	Item.nextthink = time + 5;
	Item.think = tfgoalitem_dropthink;
};
void (entity Item, float PAlive, entity P) tfgoalitem_drop =
{
	Item.origin = Item.owner.origin;
	setorigin (Item, Item.origin);
	Item.camangle = Item.owner.origin - '0 0 8';
	Item.camdist = 0;
	Item.velocity_z = 400;
	Item.velocity_x = -50 + (random () * 100);
	Item.velocity_y = -50 + (random () * 100);
	Item.goal_state = 2;
	Item.movetype = 6;
	if (Item.goal_activation & 8192)
	{
		Item.solid = 2;
	}
	else
	{
		Item.solid = 1;
	}
	if (Item.mdl != string_null)
	{
		setmodel (Item, Item.mdl);
	}
	setsize(Item, '-16 -16 0', '16 16 56');		// replaced!
	Item.owner = P;
	if (PAlive == 1)
	{
		setsize(Item, '-16 -16 0', '16 16 56');
		makevectors (P.v_angle);
		if (P.v_angle_x)
		{
			Item.velocity = (v_forward * 400) + (v_up * 200);
		}
	else
	{
		Item.velocity = aim (P, 10000);
		Item.velocity = Item.velocity * 400;
		Item.velocity_z = 200;
	}
	Item.userid = 1;
	Item.touch = SUB_Null;
	Item.nextthink = time + 0.25;
	Item.think = tfgoalitem_droptouch;
	}
	else
	{
		Item.touch = item_tfgoal_touch;
		Item.nextthink = time + 5;
		Item.think = tfgoalitem_dropthink;
	}
};
void() tfgoalitem_remove = 
{
	local entity te;
	if (self.goal_state == TF_FLARE_OFF)
	{
		return;
	}
	if (self.goal_activation & 32)
	{
		self.solid = TF_FLARE_OFF;
		self.touch = item_tfgoal_touch;
		self.origin = self.oldorigin;
		if (self.mdl != string_null)
		{
			setmodel(self, self.mdl);
		}
		setorigin(self, self.origin);
		sound(self, 2, "items/itembk2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		tfgoalitem_checkgoalreturn(self);
		if (self.noise3 != string_null || self.noise4 != string_null)
		{
			te = find(world, classname, "player");
			while (te)
			{
				if (te.team_no == self.owned_by)
				{
					CenterPrint2(te, "\n\n\n", self.noise3);
				}
				else
				{
					CenterPrint2(te, "\n\n\n", self.noise4);
				}
				te = find(te, classname, "player");
			}
		}
		return;
	}
	dremove(self);
};
void(entity Item) tfgoalitem_checkgoalreturn = 
{
	local entity te;
	if (Item.impulse != TF_FLARE_LIT)
	{
		te = Findgoal(Item.impulse);
		if (te)
		{
			te = Findgoal(Item.impulse);
			if (te)
			{
				AttemptToActivate(te, world, Item);
			}
		}
	}
};
void(entity Goal, entity Player, entity Item) DisplayItemStatus = 
{
	if (Item.goal_state == TF_FLARE_OFF)
	{
		if (Player.team_no == Item.owned_by)
		{
			sprint(Player, 2, Goal.team_str_carried);
		}
		else
		{
			sprint(Player, 2, Goal.non_team_str_carried);
		}
		sprint(Player, 2, " ");
		if (Player == Item.owner)
		{
			sprint(Player, 2, " You");
		}
		else
		{
			sprint(Player, 2, Item.owner.netname);
		}
		sprint(Player, 2, ".");
	}
	else
	{
		if (Item.origin != Item.oldorigin)
		{
			if (Player.team_no == Item.owned_by)
			{
				sprint(Player, 2, Goal.team_str_moved);
			}
			else
			{
				sprint(Player, 2, Goal.non_team_str_moved);
			}
		}
		else
		{
			if (Player.team_no == Item.owned_by)
			{
				sprint(Player, 2, Goal.team_str_home);
			}
			else
			{
				sprint(Player, 2, Goal.non_team_str_home);
			}
		}
	}
	sprint(Player, 2, "\n");
};
void() info_player_team1 = 
{
		dremove(self);
	CTF_Map = TF_FLARE_OFF;
	self.classname = "info_player_teamspawn";
	self.team_no = 2;
	self.goal_effects = TF_FLARE_OFF;
	self.team_str_home = "ts2";
};
void() info_player_team2 = 
{
		dremove(self);
	CTF_Map = TF_FLARE_OFF;
	self.classname = "info_player_teamspawn";
	self.team_no = TF_FLARE_OFF;
	self.goal_effects = TF_FLARE_OFF;
	self.team_str_home = "ts1";
};
void() item_flag_team2 = 
{
	dremove(self);
	local entity dp;
	CTF_Map = TF_FLARE_OFF;
	precache_model("progs/w_s_key.mdl");
	precache_sound("ogre/ogwake.wav");
	precache_sound2 ("boss2/pop2.wav");
	self.classname = "item_tfgoal";
	self.netname = "Team 1 Flag";
	self.broadcast = " ÇÏÔ the enemy team's flag!\n";
	self.deathtype = "You've got the enemy flag!\n";
	self.noise = "ogre/ogwake.wav";
	self.mdl = "progs/tf_flag.mdl";
	self.skin = TF_FLARE_LIT;
	setmodel(self, self.mdl);
	self.goal_no = TF_FLARE_OFF;
	self.goal_activation = TF_FLARE_OFF | 4 | 128 | 32 | 16 | 512;
	self.goal_effects = TF_FLARE_OFF;
	self.pausetime = 128;
	setsize(self, '-16 -16 -24', '16 16 32');
	self.touch = item_tfgoal_touch;
	self.goal_state = 2;
	self.solid = TF_FLARE_OFF;
	setorigin(self, self.origin);
	self.nextthink = time + 0.2;
	self.think = TF_PlaceItem;
	dp = spawn();
	dp.origin = self.origin;
	dp.classname = "info_tfgoal";
	dp.goal_activation = TF_FLARE_OFF;
	dp.team_no = TF_FLARE_OFF;
	dp.items_allowed = 2;
	dp.goal_no = 3;
	dp.goal_effects = 3;
	dp.broadcast = " ÃÁÐÔÕÒÅÄ the enemy flag!\n";
	dp.message = "You ÃÁÐÔÕÒÅÄ the enemy flag!\n";
	dp.noise = "boss2/pop2.wav";
	dp.goal_result = 2;
	dp.activate_goal_no = 5;
	dp.axhitme = 2;
	dp.count = 10;
	dp.frags = 10;
	dp.solid = TF_FLARE_OFF;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
	dp = spawn();
	dp.origin = dp.origin;
	dp.classname = "info_tfgoal";
	dp.goal_effects = TF_FLARE_OFF;
	dp.frags = 5;
	dp.goal_activation = TF_FLARE_LIT;
	dp.goal_no = 5;
	dp.solid = TF_FLARE_LIT;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
};
void() item_flag_team1 = 
{
		dremove(self);
	local entity dp;
	CTF_Map = TF_FLARE_OFF;
	precache_model("progs/tf_flag.mdl");
	precache_sound("ogre/ogwake.wav");
	precache_sound("boss2/pop2.wav");
	self.classname = "item_tfgoal";
	self.netname = "Team 2 Flag";
	self.broadcast = " ÇÏÔ the enemy team's flag!\n";
	self.deathtype = "You've got the enemy flag!\n";
	self.noise = "ogre/ogwake.wav";
	self.mdl = "progs/tf_flag.mdl";
	setmodel(self, self.mdl);
	self.skin = TF_FLARE_OFF;
	self.goal_no = 2;
	self.goal_activation = TF_FLARE_OFF | 4 | 128 | 32 | 16 | 512;
	self.goal_effects = TF_FLARE_OFF;
	self.pausetime = 128;
	setsize(self, '-16 -16 -24', '16 16 32');
	self.touch = item_tfgoal_touch;
	self.goal_state = 2;
	self.solid = TF_FLARE_OFF;
	setorigin(self, self.origin);
	self.nextthink = time + 0.2;
	self.think = TF_PlaceItem;
	dp = spawn();
	dp.origin = self.origin;
	dp.classname = "info_tfgoal";
	dp.goal_activation = TF_FLARE_OFF;
	dp.team_no = 2;
	dp.items_allowed = TF_FLARE_OFF;
	dp.goal_no = 4;
	dp.goal_effects = 3;
	dp.broadcast = " ÃÁÐÔÕÒÅÄ the enemy flag!\n";
	dp.message = "You ÃÁÐÔÕÒÅÄ the enemy flag!\n";
	dp.noise = "boss2/pop2.wav";
	dp.goal_result = 2;
	dp.activate_goal_no = 6;
	dp.axhitme = TF_FLARE_OFF;
	dp.count = 10;
	dp.frags = 10;
	dp.solid = TF_FLARE_OFF;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
	dp = spawn();
	dp.origin = dp.origin;
	dp.classname = "info_tfgoal";
	dp.goal_effects = TF_FLARE_OFF;
	dp.frags = 5;
	dp.goal_activation = TF_FLARE_LIT;
	dp.goal_no = 6;
	dp.solid = TF_FLARE_LIT;
	dp.goal_state = 2;
	setsize(dp, '-16 -16 -24', '16 16 32');
	dp.nextthink = time + 0.2;
	dp.think = TF_PlaceGoal;
};
void() CTF_FlagCheck = 
{
	local entity te;
	local float flagcount;
	local float pos;
	flagcount = TF_FLARE_LIT;
	te = find(world, classname, "item_tfgoal");
	while (te != world)
	{
		if (te.goal_no == TF_FLARE_OFF)
		{
			pos = pointcontents(te.origin);
			if (pos == -2 || pos == -6)
			{
				dprint("*****BUG*****\nFlag(s) outside world.\nPlease report this.\n");
				te.nextthink = time + 0.2;
				te.think = tfgoalitem_remove;
			}
			flagcount = flagcount + TF_FLARE_OFF;
		}
		else
		{
			if (te.goal_no == 2)
			{
				pos = pointcontents(te.origin);
				if (pos == -2 || pos == -6)
				{
					dprint("*****BUG*****\nFlag(s) outside world.\nPlease report this.\n");
					te.nextthink = time + 0.2;
					te.think = tfgoalitem_remove;
				}
				flagcount = flagcount + TF_FLARE_OFF;
			}
		}
		te = find(te, classname, "item_tfgoal");
	}
	if (flagcount != 2)
	{
		dprint("*****BUG*****\nFlag(s) missing.\nPlease report this.\n");
	}
	self.nextthink = time + 30;
};
void (entity P) ForceRespawn =
{
	local entity spot;
	local entity te;
	local entity oldself;
	oldself = self;
	self = P;
	spot = SelectSpawnPoint ();
	if ((self.playerclass != 0.000000))
	{
		spawn_tdeath (spot.origin, self);
	}
	self.observer_list = spot;
	self.origin = (spot.origin + '0.000000 0.000000 1.000000');
	self.angles = spot.angles;
	self.fixangle = 1.000000;
	if ((spot.classname == "info_player_teamspawn"))
	{
		if ((spot.items != 0.000000))
		{
			te = Finditem (spot.items);
			if (te)
			{
				tfgoalitem_GiveToPlayer (te, self, self);
			}
			if (!(spot.goal_activation & 1.000000))
			{
				spot.items = 0.000000;
			}
		}
		if (spot.message)
		{
			CenterPrint (self, spot.message);
			if (!(spot.goal_activation & 2.000000))
			{
				spot.message = string_null;
			}
		}
		if ((spot.activate_goal_no != 0.000000))
		{
			te = Findgoal (spot.activate_goal_no);
			if (te)
			{
				AttemptToActivate (te, self, spot);
			}
		}
		if ((spot.goal_effects == 1.000000))
		{
			spot.classname = "deadpoint";
			spot.team_str_home = string_null;
			spot.nextthink = (time + 1.000000);
			spot.think = SUB_Remove;
		}
	}
	if ((deathmatch || coop))
	{
		makevectors (self.angles);
		if ((self.playerclass != 0.000000))
		{
			spawn_tfog ((self.origin + (v_forward * 20.000000)));
		}
	}
	self = oldself;
};
void () DropGoalItems =
{
	local entity te;
	newmis = spawn ();
	makevectors (self.v_angle);
	v_forward = normalize (v_forward) * 64;
	newmis.origin = self.origin + v_forward;
	te = find (world, classname, "item_tfgoal");
	while (te)
	{
		if (te.owner == self)
			if (te.goal_activation & 4096 || te.owner == self)
			{
				tfgoalitem_RemoveFromPlayer (te, self, 2);
				te.no_bounce = time + 2;
				te.option5 = time + 2;
				te.tent = self;
			}
	te = find (te, classname, "item_tfgoal");
	}
	dremove (newmis);
};
vector(entity proj) bounce_off_wall =		// returns the velocity for bouncing off walls
{
	local vector vec;
	local float backoff, change;
	makevectors (proj.angles);
	v_forward_z = v_forward_z * -1;
	traceline (proj.origin, proj.origin + v_forward*64, FALSE, proj);
	if (trace_fraction == 1)
		return proj.velocity;
	proj.velocity = v_forward * 1000;//proj.old_velocity;
	backoff = (proj.velocity * trace_plane_normal);
	backoff = backoff * 1.5;
	change = trace_plane_normal_x * backoff;
	vec_x = proj.velocity_x - change;
	if (vec_x > -0.1 && vec_x < 0.1)
		vec_x = 0;
	change = trace_plane_normal_y * backoff;
	vec_y = proj.velocity_y - change;
	if (vec_y > -0.1 && vec_y < 0.1)
		vec_y = 0;
	change = trace_plane_normal_z * backoff;
	vec_z = proj.velocity_z - change;
	if (vec_z > -0.1 && vec_z < 0.1)
		vec_z = 0;
	proj.angles = vectoangles (vec);
	proj.flags = proj.flags - ( proj.flags & FL_ONGROUND );
	return vec;
};
void() EMPGrenadeExplode = 
{
	local float expsize;
	local entity te;
	local entity oldself;
	WriteByte(4, 23);
	WriteByte(4, 4);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	local entity head;
		head = findradius (self.origin, 175);
		while (head)
{
			if (head.classname == "monster_zombie" && head.is_monster == 1)
			{
deathmsg = 30;
TF_T_Damage(head, self, self.owner, 200, TF_FLARE_LIT, 4);
			}
			head = head.chain;
		}
	te = findradius(self.origin, 240);
	while (te)
	{
		if (te.touch == ammo_touch || te.touch == weapon_touch)
		{
			te.solid = TF_FLARE_LIT;
			te.enemy = self.owner;
			te.nextthink = time + TF_FLARE_OFF + random() * 2;
			te.think = EMPExplode;
		}
		else
		{
			if (te.think == TeamFortress_DetpackExplode)
			{
				te.solid = TF_FLARE_LIT;
				te.nextthink = time + TF_FLARE_OFF + random() * 2;
				dremove(te.oldenemy);
			}
			else
			{
				if (te.classname == "pipebomb")
				{
					te.nextthink = time + 0.1 + random() * 2;
				}
				else
				{
					if (te.classname == "building_dispenser" || (te.classname == "building_sentrygun" && te.ammo_rockets > 0))
					{
						TF_T_Damage(te, self, self.owner, 200, TF_FLARE_LIT, 4);
					}
					else
					{
						if ((te.classname == "building_tesla"))
						{
							if ((te.ammo_cells < 1))
							{
								te.ammo_cells = 0.000000;
							}
							TF_T_Damage (te, self, self.owner, 100, TF_FLARE_LIT, 4);
						}
						else
						{
						if (te.classname == "ammobox")
						{
							expsize = TF_FLARE_LIT;
							expsize = expsize + te.ammo_shells * 0.75;
							expsize = expsize + te.ammo_rockets * 0.75 * 2;
							expsize = expsize + te.ammo_cells * 0.75 * 2;
							if (expsize > TF_FLARE_LIT)
							{
								te.solid = TF_FLARE_LIT;
								deathmsg = 30;
								T_RadiusDamage(te, self.owner, expsize, te);
								te.think = SUB_Remove;
								te.nextthink = time + 0.1;
								WriteByte(4, 23);
								WriteByte(4, 3);
								WriteCoord(4, te.origin_x);
								WriteCoord(4, te.origin_y);
								WriteCoord(4, te.origin_z);
								multicast(te.origin, TF_FLARE_OFF);
							}
						}
						else
						{
							if (te.classname == "player" || te.touch == BackpackTouch || te.classname == "player_prop"/*&& (te.bugger == 0)*/)
							{
								expsize = TF_FLARE_LIT;
								expsize = expsize + te.ammo_shells * 0.75;
								expsize = expsize + te.ammo_rockets * 0.75 * 2;
								if (te.playerclass != 9)
								{
									expsize = expsize + te.ammo_cells * 0.75;
								}
								if (expsize > TF_FLARE_LIT)
								{
									deathmsg = 30;
									T_RadiusDamage(te, self.owner, expsize, te);
									if (te.touch != BackpackTouch)
									{
										TF_T_Damage(te, self, self.owner, expsize, TF_FLARE_LIT, 4);
										te.ammo_shells = ceil(te.ammo_shells * 0.25);
										te.ammo_rockets = ceil(te.ammo_rockets * 0.25);
										if (te.playerclass != 9)
										{
											te.ammo_cells = ceil(te.ammo_cells * 0.25);
										}
										oldself = self;
										self = te;
										W_SetCurrentAmmo();
										self = oldself;
									}
									else
									{
										te.think = SUB_Remove;
										te.nextthink = time + 0.1;
									}
									WriteByte(4, 23);
									WriteByte(4, 3);
									WriteCoord(4, te.origin_x);
									WriteCoord(4, te.origin_y);
									WriteCoord(4, te.origin_z);
									multicast(te.origin, TF_FLARE_OFF);
								}
							}
							else
							{
								if (((te.team_no != self.owner.team_no) && (te.bugger > 0.000000)/* && te.mdl != "progs/player.mdl"*/))
								{
									oldself = self;
									self = oldself;
								}
								else
								{
									if (((te.team_no != self.owner.team_no) && (te.classname == "camera")/* && te.mdl != "progs/player.mdl"*/))
									{
										oldself = self;
										camera_die (te);
										self = oldself;
									}
								}
							}
						}
					}
				}
			} }
		}
		te = te.chain;
	}
	BecomeExplosion();
	self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	dremove(self);
};
void () GasGrenadeMakeGas =
{
	local entity _l_9407;
	local entity _l_9408;
	local entity _l_9409;
	self.nextthink = (time + 0.750000);
	_l_9407 = findradius (self.origin, 200.000000);
	while ((_l_9407 != world))
	{
		if ((((_l_9407.team_no == self.owner.team_no) && (_l_9407.last_used < time)) && (_l_9407.classname == "player")))
		{
			sound (_l_9407, 4.000000, "player/gas_mask.wav", 1.000000, 1.000000);
			_l_9407.last_used = (time + 2.000000);
		}
		if (!(_l_9407.items & 2097152.000000))
		{
			if (((((_l_9407.classname == "player") && (_l_9407.deadflag == 0.000000)) && (_l_9407.team_no != self.owner.team_no)) && (_l_9407.bugger == 0.000000)) || (Coop_IsMonster(_l_9407, #MONSTERTYPE_NORMAL)))
			{
				deathmsg = 24.000000;
				TF_T_Damage (_l_9407, world, self.owner, 10.000000, 2.000000, 0.000000);
				if (Coop_IsMonster(_l_9407, #MONSTERTYPE_NORMAL))
				{
					// do some extra damage
					TF_T_Damage (_l_9407, world, self.owner, 25.000000, 2.000000, 0.000000);
				}
				else 
				if ((_l_9407.tfstate & 16384.000000))
				{
					_l_9409 = find (world, classname, "timer");
					while ((((_l_9409.owner != _l_9407) || (_l_9409.think != HallucinationTimer)) && (_l_9409 != world)))
					{
						_l_9409 = find (_l_9409, classname, "timer");
					}
					if ((_l_9409 != world))
					{
						_l_9409.health = (_l_9409.health + 25.000000);
						if ((_l_9409.health < 100.000000))
						{
							_l_9409.health = 100.000000;
						}
						_l_9409.nextthink = (time + 0.500000);
					}
				}
				else
				{
					sprint (_l_9407, 2.000000, "Far out man!\n");
					_l_9408 = find (world, classname, "timer");
					while ((((_l_9408.owner != _l_9407) || (_l_9408.think != ConcussionGrenadeTimer)) && (_l_9408 != world)))
					{
						_l_9408 = find (_l_9408, classname, "timer");
					}
					if ((_l_9408 == world))
					{
						if (Coop_IsMonster(_l_9407, #MONSTERTYPE_NORMAL))
						stuffcmd (_l_9407, "v_idlescale 10\n");
					}
					_l_9407.tfstate = (_l_9407.tfstate | 16384.000000);
					_l_9409 = spawn ();
					_l_9409.nextthink = (time + 0.500000);
					_l_9409.think = HallucinationTimer;
					_l_9409.classname = "timer";
					_l_9409.owner = _l_9407;
					_l_9409.health = 100.000000;
					_l_9409.team_no = self.team_no;
				}
			}
		}
		_l_9407 = _l_9407.chain;
	}
	self.heat = (self.heat + 1.000000);
	if ((self.heat == 1.000000))
	{
		WriteByte (4.000000, 23.000000);
		WriteByte (4.000000, 4.000000);
		WriteCoord (4.000000, self.origin_x);
		WriteCoord (4.000000, self.origin_y);
		WriteCoord (4.000000, self.origin_z);
		multicast (self.origin, 2.000000);
		return;
	}
	if ((self.heat <= 20.000000))
	{
		self.weapon = (self.weapon + 1.000000);
		if ((self.weapon == 1.000000))
		{
			WriteByte (4.000000, 23.000000);
			WriteByte (4.000000, 10.000000);
			WriteCoord (4.000000, self.origin_x);
			WriteCoord (4.000000, self.origin_y);
			WriteCoord (4.000000, (self.origin_z - 24.000000));
			multicast (self.origin, 2.000000);
			sound (self, 0.000000, "misc/vapeur2.wav", 1.000000, 1.000000);
		}
		else
		{
			if ((self.weapon == 2.000000))
			{
				self.weapon = 0.000000;
			}
		}
		return;
	}
	self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	dremove (self);
};
void () HallucinationTimer =
{
	local entity _l_9418;
	local entity _l_9419;
	local float _l_9420;
	local float _l_9421;
	local float _l_9422;
	if (self.owner.is_monster == 1)
	{
		dremove(self);
		return;
	}
	self.health = (self.health - 2.500000);
	if ((self.owner.playerclass == 5.000000))
	{
		self.health = (self.health - 2.500000);
	}
	if ((self.health <= 0.000000))
	{
		self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & 16384.000000));
	}
	if (!(self.owner.tfstate & 16384.000000))
	{
		sprint (self.owner, 2.000000, "You're sobering up now.\n");
		stuffcmd (self.owner, "v_idlescale 0\n");
		dremove (self);
		return;
	}
	_l_9419 = find (world, classname, "timer");
	while ((((_l_9419.owner != self.owner) || (_l_9419.think != ConcussionGrenadeTimer)) && (_l_9419 != world)))
	{
		_l_9419 = find (_l_9419, classname, "timer");
	}
	if ((_l_9419 == world))
	{
		stuffcmd (self.owner, "v_idlescale 10\n");
	}
	self.nextthink = (time + 0.500000);
	if ((random () < 0.500000))
	{
		KickPlayer (-10.000000, self.owner);
	}
	_l_9420 = (random () * 800.000000) - 400.000000;
	_l_9421 = (random () * 800.000000) - 400.000000;
	_l_9422 = random ();
	msg_entity = self.owner;
	if ((_l_9422 < 0.400000))
	{
		WriteByte (1.000000, 23.000000);
		if ((_l_9422 < 0.500000))
		{
			WriteByte (1.000000, 3.000000);
		}
		else
		{
			if ((_l_9422 < 0.550000))
			{
				WriteByte (1.000000, 4.000000);
			}
			else
			{
				WriteByte (1.000000, 10.000000);
			}
		}
		WriteCoord (1.000000, (msg_entity.origin_x + _l_9420));
		WriteCoord (1.000000, (msg_entity.origin_y + _l_9421));
		WriteCoord (1.000000, msg_entity.origin_z);
	}
	else
	{
		if ((_l_9422 < 0.700000))
		{
			WriteByte (1.000000, 23.000000);
			WriteByte (1.000000, 11.000000);
			WriteCoord (1.000000, (msg_entity.origin_x + _l_9420));
			WriteCoord (1.000000, (msg_entity.origin_y + _l_9421));
			WriteCoord (1.000000, msg_entity.origin_z);
		}
		else
		{
			_l_9418 = spawn ();
			_l_9418.origin_x = (msg_entity.origin_x + _l_9420);
			_l_9418.origin_y = (msg_entity.origin_y + _l_9421);
			_l_9418.origin_z = msg_entity.origin_z;
			WriteByte (1.000000, 23.000000);
			WriteByte (1.000000, 6.000000);
			WriteEntity (1.000000, _l_9418);
			WriteCoord (1.000000, _l_9418.origin_x);
			WriteCoord (1.000000, _l_9418.origin_y);
			WriteCoord (1.000000, _l_9418.origin_z);
			_l_9420 = (random () * 800.000000) - 400.000000;
			_l_9421 = (random () * 800.000000) - 400.000000;
			WriteCoord (1.000000, (msg_entity.origin_x + _l_9420));
			WriteCoord (1.000000, (msg_entity.origin_y + _l_9421));
			WriteCoord (1.000000, msg_entity.origin_z);
			dremove (_l_9418);
		}
	}
};
void() NailGrenadeLaunchNail = 
{
	local float i;
	local float j;
	i = TF_FLARE_LIT;
	while (i < TF_FLARE_OFF)
	{
		j = (random() + 2) * 5;
		current_yaw = anglemod(self.angles_y + j);
		self.angles_y = current_yaw;
		self.angles_x = TF_FLARE_LIT;
		self.angles_z = TF_FLARE_LIT;
		makevectors(self.angles);
		deathmsg = 9;
		launch_spike(self.origin, v_forward);
		newmis.touch = superspike_touch;
		newmis.weapon = 9;
		i = i + TF_FLARE_OFF;
	}
	self.playerclass = self.playerclass + TF_FLARE_OFF;
	self.nextthink = time + 0.1;
	if (self.playerclass > 40)
	{
		self.weapon = 9;
		self.think = GrenadeExplode;
	}
};
void() FlareGrenadeExplode = 
{
	self.skin = TF_FLARE_OFF;
	self.health = time + 40;
	self.nextthink = time + 0.05 + random() * 0.1;
	sound(self, 3, "items/flare1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	self.solid = TF_FLARE_LIT;
	self.think = FlareGrenadeThink;
};
void() FlashGrenadeTouch = 
{
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
void() FlashGrenadeExplode = 
{
	local entity te;
	self.effects = self.effects | 4;
	WriteByte(4, 23);
	WriteByte(4, 4);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	te = findradius(self.origin, 200);
	while (te)
	{
		if (Coop_IsMonster(te, #MONSTERTYPE_NORMAL))
{
			te.enemy = world;
			if (te.#mflash_time < (time - 10))
			{
				te.#mflash_time = time + 4;
				deathmsg = 35;
				TF_T_Damage(te, self, self.owner, 60, TF_FLARE_LIT, 16);
				newmis = spawn ();
				setmodel (newmis, "progs/s_bubble.spr");
				setorigin (newmis, te.origin);
				newmis.movetype = 8;
				newmis.solid = 0;
				newmis.velocity = '0.000000 0.000000 15.000000';
				newmis.nextthink = (time + 0.500000);
				newmis.think = bubble_bob;
				newmis.touch = bubble_remove;
				newmis.classname = "bubble";
				newmis.frame = 0;
				newmis.cnt = 0;
				setsize (newmis, '-8.000000 -8.000000 -8.000000', '8.000000 8.000000 8.000000');
			}
		}
		if (te.classname == "player" && (te.team_no != self.owner.team_no || (self_flash == 1 && self.owner == te)))
		{
			deathmsg = 35;
			TF_T_Damage(te, self, self.owner, 60, TF_FLARE_LIT, 16);
			if (te.health > TF_FLARE_LIT)
			{
				if (te.FlashTime == TF_FLARE_LIT)
				{
					newmis = spawn ();
					newmis.classname = "timer";
					newmis.netname = "flashtimer";
					newmis.team_no = self.owner.team_no;
					newmis.owner = te;
					newmis.think = FlashTimer;
					newmis.nextthink = (time + 0.100000);
				}
				if (infokey(world, "newflash") == "1" || infokey(world, "newflash") == "on")
				{
					te.FlashTime = 4.500000;
				}
				else
				{
					te.FlashTime = 2.5;
				}
				if (((te.client != "zquake") && (te.client != "fuhquake")))
				{
					stuffcmd (te, "gl_polyblend 1\ngl_cshiftpercent 100\n");
				}
				stuffcmd (te, "v_cshift 255 255 255 255\n");
			}
		}
		te = te.chain;
	}
	BecomeExplosion ();
	self.owner.active_grenades_1 = (self.owner.active_grenades_1 - 1.000000);
	dremove (self);
};
void() OnPlayerFlame_touch = 
{
	local entity flame;
	local vector vtemp;
	if (other != world && other.health > TF_FLARE_LIT && other != self.enemy)
	{
		if (other.numflames >= 3)
		{
			return;
		}
		if (other.classname == "player")
		{
			if (teamplay & 16 && other.team_no > TF_FLARE_LIT && other.team_no == self.owner.team_no)
			{
				return;
			}
			CenterPrint(other, "You are on fire!\n");
			stuffcmd(other, "bf\n");
		}
		if (other.numflames < TF_FLARE_OFF)
		{
			flame = FlameSpawn("1", other);
			sound(flame, 2, "ambience/fire1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		}
		else
		{
			flame = FlameSpawn("3", other);
			if (flame == world)
			{
				return;
			}
		}
		flame.classname = "fire";
		flame.health = 30;
		other.numflames = other.numflames + TF_FLARE_OFF;
		flame.velocity = other.velocity;
		flame.enemy = other;
		flame.touch = OnPlayerFlame_touch;
		flame.owner = self.owner;
		vtemp = self.origin;
		setorigin(flame, vtemp);
		flame.nextthink = time + 0.1;
		flame.real_owner = self.owner;
		flame.think = FlameFollow;
	}
};
float () Coop_ExpCurve =
{
	local float rtrn;
	rtrn = cvar("monster_expmultiplier");
	if (rtrn == 0)
		rtrn = 1;
	if (mapname == "g1m3")
		rtrn *= .20;
	else
	if (mapname == "harde1m1")
		rtrn *= .15;
	else
	if (mapname == "coop2ft5")
		rtrn *= .20;
	else
	if (mapname == "08")
		rtrn *= .15;
	else
	if (mapname == "04")
		rtrn *= .15;
	return rtrn;
};
void ( float exptotal, string reason, float sayamount ) MTF_Coop_AddExpToAll =
{
	local entity te;
	if (reason != string_null)
	{
		bprint( 2, reason );
		bprint( 2, "\n" );
	}
	te = find ( world, classname, "player" );
	while (te)
	{
		if (te.coop_exp != -1 && te != other && te.has_disconnected != 1)
		{
			MTF_Coop_AddExpAndWrite (te, world, exptotal, sayamount);
		}
		te = find (te, classname, "player");
	}
};
void() FlameFollow = 
{
	local vector dir;
	local vector vtemp;
	local vector boundsize;
	local float damage;
	vtemp = self.enemy.absmin;
	boundsize = self.enemy.size;
	self.solid = TF_FLARE_LIT;
	self.movetype = TF_FLARE_LIT;
	if (self.enemy.numflames == TF_FLARE_LIT)
	{
		FlameDestroy(self);
		return;
	}
	if (self.enemy.health < TF_FLARE_OFF)
	{
		deathmsg = 15;
		T_RadiusDamage(self, self, 10, self);
		self.enemy.numflames = TF_FLARE_LIT;
		FlameDestroy(self);
		return;
	}
	if (self.enemy.armorclass & 16)
	{
		if (self.enemy.armorvalue > TF_FLARE_LIT)
		{
			self.health = TF_FLARE_LIT;
		}
	}
	if (self.health < TF_FLARE_OFF)
	{
		if (self.effects != 8 || self.enemy.numflames <= TF_FLARE_OFF)
		{
			self.enemy.numflames = self.enemy.numflames - TF_FLARE_OFF;
			self.enemy.numflames = TF_FLARE_LIT;
			FlameDestroy(self);
			return;
		}
	}
	self.health = self.health - TF_FLARE_OFF;
	if (vlen(self.enemy.velocity) < 50)
	{
		dir_x = random() * boundsize_x / 2 + boundsize_x / 4;
		dir_y = random() * boundsize_y / 2 + boundsize_y / 4;
		dir_z = random() * boundsize_z / 3 + boundsize_z / 2;
		vtemp = vtemp + dir;
		setorigin(self, vtemp);
		if (self.model != "progs/flame2.mdl")
		{
			self.model = "progs/flame2.mdl";
			setmodel(self, self.model);
		}
	}
	else
	{
		if (self.model == "progs/flame2.mdl")
		{
			self.model = string_null;
			setmodel(self, self.model);
		}
	}
	traceline(self.origin, self.origin, TF_FLARE_OFF, self);
	if (trace_inwater == TF_FLARE_OFF)
	{
		sound(self, 2, "misc/vapeur2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		self.enemy.numflames = self.enemy.numflames - TF_FLARE_OFF;
		FlameDestroy(self);
		return;
	}
	self.nextthink = time + 0.1;
	if (self.effects == 8 && self.heat >= 3)
	{
		damage = self.enemy.numflames * 0.3 * 3;
		if (damage < TF_FLARE_OFF)
		{
			damage = TF_FLARE_OFF;
		}
		self.heat = TF_FLARE_OFF;
		deathmsg = 15;
		if (self.real_owner != world)
			self.owner = self.real_owner;

		if (self.owner.playerclass == 1)
			TF_T_Damage(self.enemy, self, self.owner, damage*4, 2, 16);
		else
			TF_T_Damage(self.enemy, self, self.owner, damage+30, 2, 16);
	}
	else
	{
		if (self.effects == 8)
		{
			self.heat = self.heat + TF_FLARE_OFF;
		}
	}
};
void (entity t_plyr, float t_exp) CSQC_SendExperience =
{
	stuffcmd( t_plyr, "cmd setexp " );
	stuffcmd( t_plyr, ftos(t_exp) );
	stuffcmd( t_plyr, "\n" );
};
void() WorldFlame_touch = 
{
	local entity flame;
	local vector vtemp;
	deathmsg = 15;
	TF_T_Damage(other, self, self.enemy, 66, 2, 16);
	if (other != world && other.solid != TF_FLARE_OFF && other.health > TF_FLARE_LIT)
	{
		if (other.numflames >= 3)
		{
			return;
		}
		if (other.classname == "player")
		{
			if (teamplay & 16 && other.team_no > TF_FLARE_LIT && other.team_no == self.owner.team_no)
			{
				return;
			}
			CenterPrint(other, "You are on fire!\n");
			stuffcmd(other, "bf\n");
		}
		if (other.numflames < TF_FLARE_OFF)
		{
			flame = FlameSpawn("1", other);
			sound(flame, 2, "ambience/fire1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		}
		else
		{
			flame = FlameSpawn("3", other);
			if (flame == world)
			{
				return;
			}
		}
		flame.classname = "fire";
		flame.health = TF_FLARE_LIT;
		other.numflames = other.numflames + TF_FLARE_OFF;
		flame.velocity = other.velocity;
		flame.enemy = other;
		flame.touch = OnPlayerFlame_touch;
		flame.owner = self.owner;
		vtemp = self.origin + '0 0 10';
		setorigin(flame, vtemp);
		flame.nextthink = time + 0.15;
		flame.think = FlameFollow;
	}
};
float(string id_flame) RemoveFlameFromQueue = 
{
	local entity tmp;
	if (num_world_flames < 45)
	{
		dprint("ERROR in RemoveFlameFromQueue\n");
		return 0;
	}
	num_world_flames = num_world_flames - TF_FLARE_OFF;
	tmp = find(world, flame_id, "4");
	if (!tmp)
	{
		if (id_flame == "4")
		{
			return TF_FLARE_LIT;
		}
		tmp = find(world, flame_id, "3");
		if (!tmp)
		{
			if (id_flame == "3")
			{
				return TF_FLARE_LIT;
			}
			tmp = find(world, flame_id, "2");
			if (!tmp)
			{
				if (id_flame == "2")
				{
					return TF_FLARE_LIT;
				}
				tmp = find(world, flame_id, "1");
				if (!tmp)
				{
					dprint("\n\nRemoveFlameFromQueue():BOOM!\n");
					dprint("!! please report this bug !!\n");
					return TF_FLARE_LIT;
				}
			}
		}
	}
	remove(tmp);
	return TF_FLARE_OFF;
};
void() GrenadeTouch = 
{
	if (other == self.owner)
	{
		return;
	}
	if (other.takedamage == 2)
	{
		GrenadeExplode();
		return;
	}
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
void() GrenadeExplode = 
{
	local float damg;
	if (self.classname == "pipebomb")
	{
		num_world_pipebombs = num_world_pipebombs - TF_FLARE_OFF;
		decrement_team_pipebombs(self.owner.team_no);
	}
	deathmsg = self.weapon;
	if ((self.weapon == 9.000000))
	{
		self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	}
	if ((self.weapon == 10.000000))
	{
		self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
		if ((ftos (self.owner.active_grenades_2) == " -0.0"))
		{
			self.owner.active_grenades_2 = 0.000000;
		}
	}
	self.weapon = 40;
	self.weapon = 10;
		if (self.classname == "pipebomb")
			damg += 25;
			
		if (self.option == 1)
			T_RadiusDamage(self, self.owner, 140 + damg, world);
		else
			T_RadiusDamage(self, self.owner, 120 + damg, world);
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	BecomeExplosion();
	dremove(self);
};
void () review_timeleft =
{
	local string st;
	local float minutes;
	local float seconds;
	local float remaining;
	self.no_grenades_1 = self.no_grenades_1 + 1;
	self.nextthink = (time + 1);
	st = infokey (world,"timelimit");
	minutes = stof(st);
	seconds = minutes * 60;
	if (st == "0") 
	return;
	votetimeleft = seconds - self.no_grenades_1;
	remaining = seconds - self.no_grenades_1;
	if ((remaining == 5) & (seconds >= 5))
	{
		bprint(2,"5 seconds remaining!\n");
	}
	else
	if ((remaining == 30) & (seconds >= 30))
	{
		 bprint(2,"30 seconds remaining.\n");
	}
	else
	if ((remaining == 60) & (seconds >= 60))
	{
		 bprint(2,"60 seconds remaining.\n");
	}
	else
	if ((remaining == 300) & (seconds >= 300))
	{
		 bprint(2,"5 minutes remaining.\n");
	}
	else
	if ((remaining == 900) & (seconds >= 900))
	{
		bprint(2, "15 minutes remaining.\n");
	}
	else
	if ((remaining == 1800) & (seconds >= 1800))
	{
		bprint(2, "30 minutes remaining.\n");
	}
	else
	if (remaining <= 0) 
	{
		self.nextthink = (time + 9999);
	}
	self.think = review_timeleft;
};
void (float rank_pos, string nname, float exp) MTF_Coop_WriteNewMapRank =
{
	nname = strzone(nname);
	local string rname, rval;
	local float file, dummyfile;
	local float i;
	i=0;
	file = open ("topmaps.tfi", 0);
	if (file == -1)
	{
		bprint(2,"topmaps.tfi does not exist! Add it to /fortress or experience unholy amounts of crashes!\n");
		return;
	}
	dummyfile = open ("dummy_topmaps.tfi", 2);
	while ( i < (#MAX_MAPRANKS * 2) )
	{
		write( dummyfile, read(file) );
		write( dummyfile, "\n" );
		i++;
	}
	close ( dummyfile );
	dummyfile = open ("dummy_topmaps.tfi", 0);
	close (file);
	file = open ("topmaps.tfi", 2);
	i=0;
	while (i < #MAX_MAPRANKS)
	{
		i++;
		if (i == rank_pos)
		{
			write( file, nname );
			write( file, "\n" );
			write( file, ftos(exp) );
			write( file, "\n" );
		}
		else
		{
			rname = read(dummyfile);
			if (rname == nname)
			{
				rname = read(dummyfile);
				rname = read(dummyfile);
			}
			rname = strzone(rname);
			rval = read(dummyfile);
			rval = strzone(rval);
			write( file, rname );
			write( file, "\n" );
			write( file, rval );
			write( file, "\n" );
			strunzone (rval);
			strunzone (rname);
		}
	}
	strunzone( nname );
	close( file );
	close( dummyfile );
};
void ( entity t_player, entity t_monster, float exptotal, float sayamount) MTF_Coop_AddExpAndWrite =
{
	MTF_Coop_AddExperience(t_player, t_monster, exptotal);
	MTF_Coop_PreWriteExperience( t_player, t_player.connect_name, t_player.coop_exp );
	if (sayamount == #TRUE)
		stuffcmd(t_player, "cmd sayexp\n");
};

void ( entity t_player, entity t_other, float exptotal, float exp_srv ) MTF_Coop_AddServiceExp =
{
	if (self.#next_srv_time > time)
		return;
	if (t_player == t_other)
		return;
	if (t_player.coop_exp == -1)
		return;
	self.#next_srv_time = time + 1;
	if ( exp_srv == 0 )
	{
		bprint( 2, "MTF_Coop_AddServiceExp: No service specified.\n" );
		return;
	}
	sprint( t_player, 2, "+" );
	sprint( t_player, 2, ftos(exptotal) );
	sprint( t_player, 2, " exp " );
	if ( exp_srv == #SRV_HEAL )
	{
		sprint( t_player, 2, "(player heal)\n" );
	}
	else
	if ( exp_srv == #SRV_TELEPORT )
	{
		sprint( t_player, 2, "(player teleport)\n" );
		self.#next_srv_time = time + 3;
	}
	else
	if ( exp_srv == #SRV_ACHIEVEMENT )
	{
		sprint( t_player, 2, "(new achievement)\n" );
	}
	else
	if ( exp_srv == #SRV_RESURRECT )
	{
		sprint( t_player, 2, "(resurrect player)\n" );
	}
	MTF_Coop_AddExpAndWrite ( t_player, world, exptotal, #FALSE );
};
float ( string fname ) invalid_exp_name =
{
	if ( fname == "topranks.tfi" )
		return ( 1 );
	return ( 0 );
};
void (entity plyr) Attributes_over_limit =
{
	bprint(2, "Player " );
	bprint(2, plyr.connect_name);
	bprint(2, " has attributes over the limit. Blame one of my admins, or set them on fire or something.\n");
	sprint(plyr, 2,"Your attributes have been reset.\n");
	
};
float (float attrib_count) CheckAttributes =
{
	if (attrib_count > #MAX_SPEND)
	{
		return 1;
	}
	return 0;
};
void (float file) MTF_Coop_GetAttributes =
{
	local string b;
	local float treif;
	b = read (file);
	b = strzone(b);
	self.attribute_points = stof(b);
	strunzone(b);
	b = read (file);
	b = read (file);
	b = strzone(b);
	self.health_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.armor_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.damage_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.misc_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.ammo_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.crit_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.reload_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.minion_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.quickshot_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.clipex_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	b = read (file);
	b = strzone(b);
	self.proj_attr = stof(b);
	treif = treif + CheckAttributes(stof(b));
	strunzone(b);
	strunzone(b);
};
void ( entity te ) Coop_ResetAttributes =
{
	te.health_attr = 0; te.armor_attr = 0; te.damage_attr = 0; te.ammo_attr = 0; te.misc_attr = 0; te.crit_attr = 0; te.reload_attr = 0;
	te.minion_attr = 0; te.quickshot_attr = 0; te.clipex_attr = 0; te.proj_attr = 0;
	te.attribute_points = Coop_GetLevel(te.coop_exp);
};

float (entity plyr, float type_a) Coop_GetAttributeTotal =
{
	local float r_total;
	if (type_a == 0)
		r_total = plyr.attribute_points + plyr.health_attr + plyr.armor_attr + plyr.damage_attr + plyr.misc_attr + plyr.ammo_attr + plyr.crit_attr + plyr.reload_attr + plyr.minion_attr + plyr.quickshot_attr + plyr.clipex_attr + plyr.proj_attr;
	else
	if (type_a == #ATTRIB_HEALTH)
		r_total = plyr.health_attr;
	else
	if (type_a == #ATTRIB_ARMOR)
		r_total = plyr.armor_attr;
	else
	if (type_a == #ATTRIB_DAMAGE)
		r_total = plyr.damage_attr;
	else
	if (type_a == #ATTRIB_MISC)
		r_total = plyr.misc_attr;
	else
	if (type_a == #ATTRIB_AMMO)
		r_total = plyr.ammo_attr;
	else
	if (type_a == #ATTRIB_CRIT)
		r_total = plyr.crit_attr;
	else
	if (type_a == #ATTRIB_RELOAD)
		r_total = plyr.reload_attr;
	else
	if (type_a == #ATTRIB_MINION)
		r_total = plyr.minion_attr;
	else
	if (type_a == #ATTRIB_QUICKSHOT)
		r_total = plyr.quickshot_attr;
	else
	if (type_a == #ATTRIB_CLIPEX)
		r_total = plyr.clipex_attr;
	else
	if (type_a == #ATTRIB_PROJECTILE)
		r_total = plyr.proj_attr;
	return (r_total);
};

float (string nname) MTF_Coop_GetExperience =
{
	nname = strzone(nname);	// er.. might be a good idea to move this AFTER "if ( nname ==..."
	local string a;
	local string filename, oopsname;
	local float file, exp;
	local float slip;
	local float resetme;
	if (nname != self.connect_name)
	{
		bprint(2, "ERROR RETRIEVING EXP FROM ");
		bprint(2, self.netname);
		bprint(2, " - please reconnect. (connect name: ");
		bprint(2, self.connect_name);
		bprint(2, ")\n");
	}
	if ( nname == "" || !nname )
		return ( -1 );
	filename = /*strzone(*/frik_strcat( "ranks/", nname, ".tfi" )/*)*/;
	filename = strzone(filename);
	if ( invalid_exp_name(filename) == 1 )
	{
		strunzone(nname);
		strunzone(filename);
		return ( -1 );
	}
	if ( checkfilename(filename) != 1 )
	{	// done in C - makes sure the file name 
		strunzone(nname);
		strunzone(filename);
		if (checkfilename( "ranks/test" ) == #FALSE)
			bprint( 2, "WARNING: Folder /ranks cannot be found! Server admin needs to create /fortress/ranks/ folder!\n" );
		return ( -1 );				// is writable
	}
	oopsname = frik_strcat( "ranks/", self.connect_name, ".tfi" );
	oopsname = strzone(oopsname);
	if (filename != oopsname || self.has_disconnected == 1)
	{
		bprint(2, "!!!!!!!!!!!!! EXP BUG ERROR IN READ!!! FILENAME IS NOT THE SAME AS CONNECT NAME !!!!!!!!!!!!! \n");
		bprint(2, "CNAME: ");
	bprint(2, self.connect_name);
	bprint(2, " filename: ");
	bprint(2, filename);
	bprint(2, " oopsname: ");
	bprint(2, oopsname);
	bprint(2,"\n");
		strunzone(filename);
		strunzone(oopsname);
		return ( -1 );
	}
	strunzone(oopsname);
	file = open (filename, 0);
	if ((file == -1))
	{
		bprint(2,"NEW PLAYA\n");
		file = open (filename, 2);
		write (file, "0\n");
		write (file, "// free attribute points:\n");
		write (file, "5\n"); //was 0, you start with 5 attrib points to get up the curve. -arg
		write (file, "// Attributes: health, armor, damage, misc, ammo\n");
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n"); // What about adding the attributes 5-11 silly? Fixed. -arg 2/2020
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n");
		write (file, "0\n");
		close (file);
		strunzone(filename);
		strunzone(nname);
		return ( 0 );
	}
	a = read (file);
	exp = stof(a);
	a = read (file);
	if (a != "// free attribute points:" && a != "")
		resetme = FALSE; //changed to false to stop it from resetting on every reconnect. wtf -arg
	MTF_Coop_GetAttributes (file);	// set attribute points (note: change call location)
	close (file);
	if (resetme)
	{
		MTF_Coop_ShowAttrib();
		sprint(self, 2, "********\n");
		sprint(self, 2, "********\n");
		sprint(self, 2, "******* PLEASE NOTE: Your attributes have been reset under the new EXP system.\n******* Check your points in CMD attrib and re-allocate them using CMD spend.\n");
		sprint(self, 2, "(your old attributes are printed above).\n");
		sprint(self, 2, "********\n");
		sprint(self, 2, "********\n");
	}
	slip = Coop_GetAttributeTotal(self, #FALSE);
	if ( (slip == 0) && (exp >= #COOP_LEVEL_ONE) )
	{
		MTF_Coop_CheckNewLevel( 0, exp );
		MTF_Coop_WriteExperience( nname, exp );
	}
	strunzone(nname);
	strunzone(filename);
	return ( exp );
};
float (string nname) MTF_Coop_GetUserExperience =
{
	nname = strzone(nname);	// er.. might be a good idea to move this AFTER "if ( nname ==..."
	local string a;
	local string filename;
	local float file, exp;
	if ( nname == "" || !nname )
	{
		strunzone(nname);
		return ( -1 );
	}
	filename = /*strzone(*/frik_strcat( "ranks/", nname, ".tfi" )/*)*/;
	filename = strzone(filename);
	if ( invalid_exp_name(filename) == 1 )
	{
		strunzone(nname);
		strunzone(filename);
		return ( -1 );
	}
	file = open (filename, 0);
	if ((file == -1))
	{
		strunzone(nname);
		strunzone(filename);
		return ( -1 );
	}
	a = read (file);
	exp = stof(a);
	strunzone(nname);
	strunzone(filename);
	close (file);
	return ( exp );
};
void (float rank_pos, string nname, float exp) MTF_Coop_WriteNewRank =
{
	nname = strzone(nname);
	local string rname, rval;
	local float file, dummyfile;
	local float i;
	i=0;
	file = open ("topranks.tfi", 0);
	if (file == -1)
	{
		bprint(2,"topranks.tfi does not exist! Add it to /fortress or experience unholy amounts of crashes!\n");
		return;
	}
	dummyfile = open ("dummy_topranks.tfi", 2);
	while ( i < (#MAX_RANKS * 2) )
	{
		write( dummyfile, read(file) );
		write( dummyfile, "\n" );
		i++;
	}
	close ( dummyfile );
	dummyfile = open ("dummy_topranks.tfi", 0);
	close (file);
	file = open ("topranks.tfi", 2);
	i=0;
	while (i < #MAX_RANKS)
	{
		i++;
		if (i == rank_pos)
		{
			write( file, nname );
			write( file, "\n" );
			write( file, ftos(exp) );
			write( file, "\n" );
		}
		else
		{
			rname = read(dummyfile);
			if (rname == nname)
			{
				rname = read(dummyfile);
				rname = read(dummyfile);
			}
			rname = strzone(rname);
			rval = read(dummyfile);
			rval = strzone(rval);
			write( file, rname );
			write( file, "\n" );
			write( file, rval );
			write( file, "\n" );
			strunzone (rval);
			strunzone (rname);
		}
	}
	strunzone( nname );
	close( file );
	close( dummyfile );
};
void () MTF_Coop_RanksExperienceSet =
{
	local entity t_plyr;
	local float exp;
	local string a;
	local float file, i;
	t_plyr = self.enemy;
	exp = t_plyr.coop_exp;
	if (t_plyr == world || t_plyr.has_disconnected == 1 || t_plyr.classname != "player" || t_plyr.connect_name == string_null || t_plyr.connect_name == "")
	{
		dremove(self);
		return;
	}
	file = open ("topranks.tfi", 0);
	i = 0;
	while (i < #MAX_RANKS)
	{
		i++;
		a = read (file);
		a = read (file);
		if (stof(a) <= exp)
		{
			close (file);
			MTF_Coop_WriteNewRank( i, t_plyr.connect_name/*nname*/, exp );
			dremove(self);
			return;
			break;
		}
	}
	dremove(self);
	close (file);
};
void (string nname, float exp) MTF_Coop_RanksExperience =
{
	local entity rank_ent, te, trank;
	trank = world;
	te = find(world, connect_name, nname);
	while (te)
	{
		if (te.classname == "player")
			trank = te;
		te = find(te, connect_name, nname);
	}
	if (trank == world)
	{
		bprint(2, "MTF_Coop_RanksExperience: Cannot update experience for a disconnected player.\n");
		bprint(2, nname);
		bprint(2, "\n");
		return;
	}
	rank_ent = spawn();
	rank_ent.enemy = trank;
	rank_ent.health = exp;
	rank_ent.think = MTF_Coop_RanksExperienceSet;
	rank_ent.nextthink = time + .4 + random();
};
float ( float getlevel ) Coop_ExpReq =
{
	switch  ( getlevel )
	{
		case 1:
			return #COOP_LEVEL_ONE;
		case 2:
			return 300;
		case 3:
			return 500;
		case 4:
			return 800;
		case 5:
			return 1100;
		case 6:
			return 1700;
		case 7:
			return 2250;
		case 8:
			return 2700;
		case 9:
			return 3300;
		case 10:
			return 4000;
		case 11:
			return 4900;
		case 12:
			return 6000;
		case 13:
			return 7000;
		case 14:
			return 8500;
		case 15:
			return 10000;
		case 16:
			return 11700;
		case 17:
			return 13400;
		case 18:
			return 15100;
		case 19:
			return 16800;
		case 20:
			return 18000;
		case 21:
			return 19000;
		case 22:
			return 20000;
		case 23:
			return 21400;
		case 24:
			return 22200;
		case 25:
			return 23200;
		case 26:
			return 24000;
		case 27:
			return 25000;
		case 28:
			return 26500;
		case 29:
			return 28000;
		case 30:
			return 30000;
		case 31:
			return 34000;
		case 32:
			return 37000;
		case 33:
			return 40000;
		case 34:
			return 44000;
		case 35:
			return 49000;
		case 36:
			return 57000;
		case 37:
			return 69000;
		case 38:
			return 80000;
		case 39:
			return 100000;
		case 40:
			return 150000;
		case 41:
			return 220000;
		case 42:
			return 300000;
		case 43:
			return 380000;
		case 44:
			return 460000;
		case 45:
			return 540000;
		case 46:
			return 620000;
		case 47:
			return 700000;
		case 48:
			return 790000;
		case 49:
			return 895000;
		case 50:
			return 1000000;
		case 51:
			return 1150000;
		case 52:
			return 1350000;
		case 53:
			return 1500000;
		case 54:
			return 1700000;
		case 55:
			return 1930000;
		case 56:
			return 2200000;
		case 57:
			return 2450000;
		case 58:
			return 2750000;
		case 59:
			return 3000000;
		case 60:
			return 3270000;
		case 61:
			return 3500000;
		case 62:
			return 3800000;
		case 63:
			return 4200000;
		case 64:
			return 4600000;
		case 65:
			return 5000000;
		case 66:
			return 5300000;
		case 67:
			return 5600000;
		case 68:
			return 5900000;
		case 69:
			return 6200000;
		case 70:
			return 6500000;
		case 71:
			return 6800000;
		case 72:
			return 7100000;
		case 73:
			return 7500000;
		case 74:
			return 7800000;
		case 75:
			return 8000000;
		case 76:
			return 8400000;
		case 77:
			return 8800000;
		case 78:
			return 9200000;
		case 79:
			return 9600000;
		case 80:
			return 10000000;
		case 81:
			return 10425000;
		case 82:
			return 10875000;
		case 83:
			return 11335000;
		case 84:
			return 11810000;
		case 85:
			return 12310000;
		case 86:
			return 12810000;
		case 87:
			return 13335000;
		case 88:
			return 13865000;
		case 89:
			return 14410000;			// + 525,000
		case 90:
			return 15000000;
		case 91:
			return 15500000;
		case 92:
			return 16000000;
		case 93:
			return 16500000;
		case 94:
			return 17000000;
		case 95:
			return 17500000;
		case 96:
			return 18000000;
		case 97:
			return 18500000;
		case 98:
			return 19000000;
		case 99:
			return 19500000;
		case 100:
			return 20000000;
		case 101:
			return 20750000;
		case 102:
			return 21600000;
		case 103:
			return 22400000;
		case 104:
			return 23200000;
		case 105:
			return 24020000;
		case 106:
			return 24860000;
		case 107:
			return 25720000;
		case 108:
			return 26600000;
		case 109:
			return 27500000;
		case 110:
			return 28420000;
		case 111:
			return 29360000;
		case 112:
			return 30320000;
		case 113:
			return 31300000;
		case 114:
			return 32300000;
		case 115:
			return 33320000;
		case 116:
			return 34360000;
		case 117:
			return 35420000;
		case 118:
			return 36500000;
		case 119:
			return 37600000;
		case 120:
			return 38720000;
		default:
			return 999999999;
	}
	return 999999999;
};
void (float origexp, float newexp) MTF_Coop_CheckNewLevel =
{
	local float lvlg, newlvl, chklvl;
	newlvl = 0;
	// fixme addme: stop messing around and add a while() loop here
	lvlg = #COOP_LEVEL_ONE;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 1;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_TWO;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 2;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_THREE;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 3;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_FOUR;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 4;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_FIVE;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 5;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_SIX;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 6;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_SEVEN;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 7;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_EIGHT;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 8;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_NINE;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 9;
		self.attribute_points += 1;
	}
	lvlg = #COOP_LEVEL_TEN;
	if (origexp < lvlg && newexp >= lvlg)
	{
		newlvl = 10;
		self.attribute_points += 1;
	}
//fixme: goes from 200k to 300k and then to 500k - should be 400k then 500k
	lvlg = #COOP_LEVEL_AFTERTEN;
	if (newexp >= lvlg)
	{
		chklvl = 1;
		while (chklvl)
		{
			lvlg += ((chklvl - 1) * 100000);
			if (origexp < lvlg && newexp >= lvlg)
			{
				newlvl = 10 + chklvl;
				chklvl = 0;
			}
			else
			if (newexp > lvlg)
				chklvl += 1;
			else
				chklvl = 0;
		}
	}
	if (newlvl > 0)
	{
		bprint(2, self.netname);
		bprint(2, " is now level ");
		bprint(2, ftos(newlvl));
		bprint(2, "!\n");
		sprint(self, 2, "CONGRATULATIONS! To check your attributes, type cmd attrib!\n");
	}
};
void (string nname, float exp/*, float reset_attribs*/) MTF_Coop_ForceWriteExperience =
{
	local string filename;
	local float file;
	if ( nname == "" || !nname )
		return;
	if ( exp < 0 )
		return;
	nname = strzone(nname);
	filename = strzone( frik_strcat( "ranks/", nname, ".tfi" ) );
	if ( checkfilename(filename) != 1 )
	{	// done in C - makes sure the file name 
		return;				// is writable
	}
	file = open (filename, 0);
	if ((file == -1))
	{
		file = open (filename, 2);
		write (file, ftos(exp));
		write (file, "\n");
		write (file, "// free attribute points:\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, "// Attributes: health, armor, damage, misc, ammo, crit, reload, summon,\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n"); // What about the rest of the attributes ? -arg bugged.
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n");
		write (file, ftos(0));
		write (file, "\n"); // There all 11 attributes overwritten.
		close (file);
		strunzone(nname);
		strunzone(filename);
		return;
	}
	close (file);
	file = open (filename, 2);
	write (file, ftos(exp));
	write (file, "\n");
	write (file, "// free attribute points:\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, "// Attributes: health, armor, damage, misc, ammo, critical strike, reload\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0)); //What about the rest of the attributes ? bugged -arg
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n");
	write (file, ftos(0));
	write (file, "\n"); // There all 11 attributes overwritten.
	close (file);
	strunzone(filename);
	MTF_Coop_RanksExperience ( nname, exp );
	strunzone(nname);
};
void ( float howmany ) MTF_Coop_ViewTopRanks =
{
	local string rname;
	local float rank, level;
	local float file;
	local float i;
	if (howmany > #MAX_RANKS)
		howmany = #MAX_RANKS;
	if (howmany <= 0)
		{
		howmany = 1;
		sprint( self, 2, "To show more, specify the number of RANKING PLAYERS with cmd showtop . \n" );
		}
	file = open ("topranks.tfi", 0);
	sprint( self, 2, "-- TOP " );
	sprint( self, 2, ftos( howmany ) );
	sprint( self, 2, " RANKING PLAYERS (sorted by exp) --\n" );
	sprint( self, 2, "Rank *       Name      *       Exp        *  Level\n" );
	if (file == -1)
	{
		bprint(2,"topranks.tfi does not exist! Add it to /fortress directory, or experience unholy amounts of crashes!\n");
		return;
	}
	i = 0;
	while (i < howmany)
	{
		i++;
		rname = read(file);
		rname = frik_strcat(rname, "                        ");
		rname = substr(rname, 0, 16);
		rname = strzone(rname);
		if (i < 10)
			sprint( self, 2, " " );
		sprint( self, 2, " " );
		sprint( self, 2, ftos(i) );
		sprint( self, 2, "  - " );
		sprint( self, 2, rname );
		sprint( self, 2, ": " );
		rank = stof(read(file));
		sprint( self, 2, substr( frik_strcat( ftos(rank), "                      " ), 0, 9) );
		sprint( self, 2, "         level: " );
		level = Coop_GetLevel(rank);
		sprint( self, 2, ftos(level) );
		sprint( self, 2, " \n" );
		strunzone(rname);
	}
	close (file);
};
void () MTF_Coop_ViewTopMapRanks =
{
	local string rname, fname;
	local float file;
	fname = frik_strcat( "ranks/maps/", mapname, ".tfi" );
	file = open (fname, 0);
	if ( file == -1 )
	{
		sprint( self, 2, "No top ranks recorded for [" );
		sprint( self, 2, mapname );
		sprint( self, 2, "].\n" );
		return;
	}
	sprint( self, 2, "Top frags for map [" );
	sprint( self, 2, mapname );
	sprint( self, 2, "].\n" );
	read(file);		// skip line 1
	rname = strzone(read(file));
	rname = strzone(rname);
	sprint( self, 2, "Fastest completion time: " );
	sprint( self, 2, rname );
	sprint( self, 2, " seconds.\n" );
	strunzone(rname);
	rname = strzone(read(file));
	rname = strzone(rname);
	sprint( self, 2, "Top player: " );
	sprint( self, 2, rname );
	sprint( self, 2, ".\n" );
	strunzone(rname);
	rname = strzone(read(file));
	rname = strzone(rname);
	sprint( self, 2, "Top player's frags: " );
	sprint( self, 2, rname );
	sprint( self, 2, ".\n" );
	strunzone(rname);
	close (file);
};
void () MTF_Coop_ShowAttrib =
{
	sprint(self, 2, "----- Your Attribute status: -----\n");
	sprint(self, 2, " -- Free Attribute Points: ");
	sprint(self, 2, ftos(self.attribute_points));
	sprint(self, 2, "\n -- 1) Health Attributes: ");
	sprint(self, 2, ftos(self.health_attr));
	sprint(self, 2, "\n -- 2) Armor Attributes: ");
	sprint(self, 2, ftos(self.armor_attr));
	sprint(self, 2, "\n -- 3) Rage Attributes: ");
	sprint(self, 2, ftos(self.damage_attr));
	sprint(self, 2, "\n -- 4) Misc Attributes: ");
	sprint(self, 2, ftos(self.misc_attr));
	sprint(self, 2, "\n -- 5) Ammo Attributes: ");
	sprint(self, 2, ftos(self.ammo_attr));
	sprint(self, 2, "\n -- 6) Critical Strike Attributes: ");
	sprint(self, 2, ftos(self.crit_attr));
	sprint(self, 2, "\n -- 7) Quick Reload Attributes: ");
	sprint(self, 2, ftos(self.reload_attr));
	sprint(self, 2, "\n -- 8) Minion Summon Attributes: ");
	sprint(self, 2, ftos(self.minion_attr));
	sprint(self, 2, "\n -- 9) Quick Shot Attributes: ");
	sprint(self, 2, ftos(self.quickshot_attr));
	sprint(self, 2, "\n -- 10) Clip Extender Attributes: ");
	sprint(self, 2, ftos(self.clipex_attr));
	sprint(self, 2, "\n -- 11) Projectile Speed Attributes: ");
	sprint(self, 2, ftos(self.proj_attr));
	sprint(self, 2, "\n -- Max spend of attribute points per category is: ");
	sprint(self, 2, ftos(#MAX_SPEND));
	sprint(self, 2, " .\n");
	sprint(self, 2, "\nType [cmd spend] for information on spending attributes.\n");
};
float ( float currexp, float attrib_type ) Coop_GetNextLevelNeeded =
{
	local float current_amount;
	current_amount = Coop_GetAttributeTotal( self, attrib_type );
	current_amount += 1;
	if (attrib_type == #ATTRIB_DAMAGE)
	{
		if (current_amount == 1)
			return #COOP_LEVEL_ONE;
		else
		if (current_amount == 2)
			return #COOP_LEVEL_THREE;
		else
		if (current_amount == 3)
			return #COOP_LEVEL_SIX;
		else
		if (current_amount == 4)
			return #COOP_LEVEL_EIGHT;
		else
		if (current_amount == 5)
			return #COOP_LEVEL_TEN;
		else
		if (current_amount == 6)
			return #COOP_LEVEL_TEN;  // edited to ten instead of 12 and 15 since the #defines are not there ? whatever. -arg
		else
		if (current_amount == 7)
			return #COOP_LEVEL_TEN;
	}
	else
		return 0;
};
void ( float attrib_type ) MTF_Coop_SpendAttrib =
{
	local string attr_name;
	local float for_dmg;
	local float attrib_count, attrib_cost;
	if (attrib_type == 0 || ! attrib_type)
	{
		sprint(self, 2, "To spend attributes type \"cmd spend attrib#\". Attrib#'s are:\n");
		sprint(self, 2, "1 - health (higher health attributes allow better armor types).\n");
		sprint(self, 2, "2 - armor (percent increase in total armor).\n");
		sprint(self, 2, "3 - rage (players inflict and receive more damage).\n");
		sprint(self, 2, "4 - misc (monster loot lasts longer, and pentagram/invisible drop possibility).\n");
		sprint(self, 2, "5 - ammo (increases max ammo and higher levels increase max grens).\n");
		sprint(self, 2, "6 - critical strike (small percent chance to inflice 4x damage).\n");
		sprint(self, 2, "7 - quick reload (reload time decreased by 33%).\n");
		sprint(self, 2, "8 - minion summon (summon minion(s) to fight for you).\n");
		sprint(self, 2, "9 - quick shot (faster fire rate for non-automatic weapons).\n");
		sprint(self, 2, "10 - clip extender (increases clip size on all weapons.\n");
		sprint(self, 2, "11 - projectile speed (increases speed of rockets, tranq, rails, flames, etc.\n");
		sprint(self, 2, "Each increase in attribute level costs the previous level plus one in free attribute points.\n");
		sprint(self, 2, "For example level 5 costs 6 free attribute points.\n");		
		sprint(self, 2, " -- Max attribute points spent per category is: ");	
		sprint(self, 2, ftos(#MAX_SPEND));
		sprint(self, 2, " .\n");
		return;
	}
	attrib_count = Coop_GetAttributeTotal( self, attrib_type );
	attrib_cost = attrib_count + 1;
	if (attrib_cost > 7)
		attrib_cost = 7;
	if (self.attribute_points < attrib_cost)
	{
		sprint(self, 2, "You need ");
		sprint(self, 2, ftos(attrib_cost - self.attribute_points));
		sprint(self, 2, " more free points to upgrade this attribute to level ");
		sprint(self, 2, ftos(attrib_count + 1));
		sprint(self, 2, ".\n");
		return;
	}
	if (attrib_count >= #MAX_SPEND)
	{
		sprint(self, 2, "You cannot spend any more of that attribute on this server.\n");
		return;
	}
	if (attrib_type == #ATTRIB_HEALTH)
	{
		attr_name = "Health Increase";
		self.health_attr += 1;
		self.max_health = floor( self.max_health * MTF_Coop_AttribGain(self, #ATTRIB_HEALTH) );

		if (self.health > 0)
			self.health = self.max_health;
	}
	else
	if (attrib_type == #ATTRIB_ARMOR)
	{
		attr_name = "Armor Increase";
		self.armor_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_DAMAGE)
	{
		for_dmg = Coop_GetLevel( Coop_GetNextLevelNeeded( self.coop_exp, attrib_type ) );
		if ( Coop_GetLevel( self.coop_exp ) < for_dmg )
		{
			sprint( self, 2, "You cannot spend another point on rage until you are level " );
			sprint( self, 2, ftos( for_dmg ) );
			sprint( self, 2, " .\n" );
			return;
		}
		attr_name = "Rage Increase";
		self.damage_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_MISC)
	{
		attr_name = "Loot Increase";
		self.misc_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_AMMO)
	{
		attr_name = "Ammo Increase";
		self.ammo_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_CRIT)
	{
		attr_name = "Critical Strike Increase";
		self.crit_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_RELOAD)
	{
		attr_name = "Quick Reload Increase";
		self.reload_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_MINION)
	{
		attr_name = "Minion Summon Increase";
		self.minion_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_QUICKSHOT)
	{
		attr_name = "Quick Shot Increase";
		self.quickshot_attr += 1;
	}
	else
	if (attrib_type == #ATTRIB_CLIPEX)
	{
		attr_name = "Clip Extender";
		self.clipex_attr += 1;
	}	
	else
	if (attrib_type == #ATTRIB_PROJECTILE)
	{
		attr_name = "Projectile Speed Increase";
		self.proj_attr += 1;
	}		
	else
	{
		sprint(self, 2, "Invalid Attribute # specified.\n");
		MTF_Coop_SpendAttrib ( 0 );
		return;
	}
	sprint(self, 2, "You spend one attribute on ");
	sprint(self, 2, attr_name);
	sprint(self, 2, ".\n");
	if (attr_name == "Rage Increase")
		sprint(self, 2, "NOTE: The more rage attributes you have, the more vulnerable you become to monster attacks.\n");
	else
	if (attr_name == "Critical Strike Increase")
		sprint(self, 2, "NOTE: The more crit strike attributes you have, the more damage monsters do to you when they inflict critical strike.\n");
	else
	if (attr_name == "Minion Summon Increase")
		sprint(self, 2, "Note: Use \"cmd summon\" to summon a minion.\n");
	self.attribute_points = self.attribute_points - attrib_cost;
	MTF_Coop_WriteExperience ( self.connect_name, self.coop_exp );
	if ( Coop_HasMasterSkill( self, attrib_type ) == #TRUE )
	{
		sprint( self, 2, " You have unlocked a new Masters Skill!\n Check \"CMD help masters\" to see what it is!\n" );
	}
};
float (entity plyr, float attrib_type) MTF_Coop_AttribGain =
{
	if (attrib_type == #ATTRIB_HEALTH)
	{
		return ( 1 + (.55 * plyr.health_attr) );
	}
	else
	if (attrib_type == #ATTRIB_ARMOR)
	{
		return ( 1 + (.35 * plyr.armor_attr) );
	}
	else
	if (attrib_type == #ATTRIB_DAMAGE)
	{
		return ( 1 + (.17 * plyr.damage_attr) );
	}
	else
	if (attrib_type == #ATTRIB_MISC)
	{
		return ( (.15 * plyr.misc_attr) );
	}
	else
	if (attrib_type == #ATTRIB_AMMO)
	{
		return ( 1 + (.36 * plyr.ammo_attr) );		// 2/23/11: used to be .2
	}
	else
	if (attrib_type == #ATTRIB_CRIT)
	{
		return ( 1 + (1.75 * plyr.crit_attr) );
	}
	else
	if (attrib_type == #ATTRIB_RELOAD)
	{
		return ( 1 + ( plyr.reload_attr * .65) );	// higher the return value, shorter the reload time
	}
	else
	if (attrib_type == #ATTRIB_MINION)
	{
		return ( 1 * plyr.minion_attr );
	}
	else
	if (attrib_type == #ATTRIB_QUICKSHOT)
	{
		return ( 1 + (self.quickshot_attr * .4) );	// delay is divided by this ammount
	}
	else
	if (attrib_type == #ATTRIB_CLIPEX)
	{
		return ( self.clipex_attr*(.20) );
	}		
	else
	if (attrib_type == #ATTRIB_PROJECTILE)
	{
		return ( self.proj_attr*(.30) );
	}		
	else
	{
		bprint(2, "Warning: Invalid attribute type (");
		bprint(2, ftos(attrib_type));
		bprint(2, ") called.\n");
		return ( 1 );
	}
};
float (entity plyr, float atype) MTF_Coop_SetArmorAttrib =
{
	if (plyr.health_attr < 1)
	{
		if (atype == 1)
			return ( plyr.armortype );
		else
			return ( plyr.armor_allowed );
	}
	if (plyr.health_attr == 1)
		return (0.6);
	else
	if (plyr.health_attr == 2)
		return (0.7);
	else
	if (plyr.health_attr >= 3)
		return (0.8);

	return ( plyr.armor_allowed );
};
void () Coop_MinionMonsterTouch =
{
	local float dist, strength;
	local vector delta;
	if (other == self.owner || other.health <= 0)
		return;
	if (other.classname != "player")
		return;
	if (self.#next_push_time > time)
		return;
	self.#next_push_time = time + 3;
	delta = self.origin - other.origin + other.view_ofs;
	if (delta_z < 0)
		delta_z = delta_z / -2;
	delta = delta * 0.7;
	if (delta_z < 100)
		delta_z = 100;
	dist = vlen(delta);
	strength = 800;
	delta = normalize(delta);
	delta = delta * strength;
	delta_z *= .3;
	if (self.flags & FL_ONGROUND)
	{
		self.flags = self.flags - FL_ONGROUND;
		self.#fixflags = 1;
	}
	self.velocity = self.velocity + delta;
};
void () summon_think =
{
	local float fls, mhp;
	local vector endp;
	fls = self.owner.maxs_z * 1;
	endp = self.owner.origin;
	endp_z += fls;
	//set minion's color fob to the same at the player's. -arg
	self.frame = self.owner.team_no - 1;
	if (self.owner == world || self.owner.is_monster != 1)
	{
		dremove(self);
		return;
	}
	if (self.owner.flags & FL_ONGROUND)
		self.owner.touch = Coop_MinionMonsterTouch;
	if ( self.owner.#fixflags )
	{
		self.owner.flags = self.owner.flags & FL_ONGROUND;
		self.owner.#fixflags = 0;
	}
	if (self.owner.owner != self.real_owner)
		self.owner.owner = self.real_owner;
	if (self.#health_check == #FALSE && self.owner.health > 0)
	{
		self.classname = self.owner.classname;		// hackish in order to get MTF_Monster_Health2 workin' right
		mhp = MTF_Monster_Health2(self.max_health);
		if (self.owner.health > mhp)
		{
			sprint(self.real_owner, 2, "You need more minion attributes to sustain the type of monster you summoned.\n");
			self.armorvalue = 1;
		}
		self.#health_check = #TRUE;
		self.classname = "monster_goalie";
	}
	if (time >= self.armorvalue)		// time for summoned monster to die! :(
	{
		if (self.owner.th_die)
		{
			self.owner.flags = self.flags | FL_MONSTER;
			self.owner.deathtype = "monster_respawn";
			self.owner.health = -60;
			Killed (self.owner, world);
//TODO put in a function to kill the head too. no pete monsters? -arg
			self.enemy = self.owner;
			self.think = MTF_RemoveMonster;
			self.nextthink = time + 5;
			return;
		}
	}
	if (endp == self.orig_origin)	// save some bandwidth
	{
		self.nextthink = time + .1;
		return;
	}
	self.orig_origin = endp;
	setorigin(self, endp);
	self.nextthink = time + .1;
};
float ( float currexp ) Coop_GetLevel =
{
	local float i;
	while (i < #MAX_LEVEL)
	{
		i++;
		if ( currexp < Coop_ExpReq( i ) )
		{
			return ( i - 1 );
			break;
		}
	}
	return #MAX_LEVEL;
};
float ( float currexp ) Coop_ExpForNextLevel =
{
	local float t_lvl;
	t_lvl = Coop_GetLevel( currexp );
	return ( Coop_ExpReq( t_lvl + 1 ) - currexp );
};
string (string nname, float currexp) MTF_Coop_GetSkin =
{
	local string filename, a;
	local float file;
	if ( Coop_GetLevel(currexp) < 10 )
		return "";
	if (self.#custom_skin == "off")
	{
		return "";
	}
	if (self.#custom_skin != string_null)
	{
		return self.#custom_skin;
	}
	else
	{
		filename = frik_strcat( "ranks/", nname, "_skin.tfi" );
		if ( validatefile(filename) )		// file exists, open and return&set the skin
		{
			file = open (filename, 0);
			a = read(file);
			a = strzone(a);
			self.#custom_skin = a;
			self.#custom_skin = strzone(self.#custom_skin);
			close(file);
			strunzone(a);
			return ( self.#custom_skin );
		}
		else
		{
			return "";
		}
	}
};
void (entity p, string newskin) MTF_Coop_SetCustomSkin =
{
	local string filename;
	local float file;
	if ( !MTF_Coop_IsValidPlayer(p) )
		return;
	if ( Coop_GetLevel(p.coop_exp) < 10 )
	{
		sprint(p, 2, "You need to be at least level 10 to access this feature!\n");
		return;
	}
		
	if (newskin == "")
	{
		sprint(p, 2, "No skin specified. Use CMD customskin skinname\n");
		return;
	}
	filename = frik_strcat( "skins/", newskin, ".pcx" );
	if ( validatefile(filename) || newskin == "off")
	{
		filename = frik_strcat( "ranks/", self.connect_name, "_skin.tfi" );
		file = open (filename, 2);
		write (file, newskin);
		write (file, "\n");
		close(file);
		if (newskin == "off")
		{
			sprint(p, 2, "You have turned off your custom skin.\n");
			self.#custom_skin = "off";
			self.#custom_skin = strzone(self.#custom_skin);
			TeamFortress_SetSkin(p);
			return;
		}
		sprint(p, 2, "Your new custom skin is set to: ");
		sprint(p, 2, newskin);
		sprint(p, 2, ".\n");
		stuffcmd(p, "skin ");
		stuffcmd(p, newskin);
		stuffcmd(p, "\n");
		self.#custom_skin = newskin;
		self.#custom_skin = strzone(self.#custom_skin);
	}
	else
	{
		sprint(p, 2, "The skin you tried to select is not on this server.\n Please contact an admin about uploading the specified skin.\n");
	}
};
float (entity plyr) MTF_Coop_IsValidPlayer =
{
	if (self.coop_exp < 1)
		return 0;
	else
		return 1;
};
float ( entity t_plyr, float attrib_type ) Coop_HasMasterSkill =
{
	local float attr_total;
	attr_total = Coop_GetAttributeTotal( t_plyr, attrib_type );
	if ( attr_total >= #MASTERS_LEVEL )
	{				// no longer MAX_SPEND because I raised the caqp from 7 to 10 now
		return #TRUE;
	}
	return #FALSE;
};
void () Masters_MinionSpawnThink =
{
	droptofloor (0, 0);
	if (self.owner == world || self.owner.health < 1)
	{
		dremove(self);
		return;
	}
	if (InSolid(self))
	{
		sprint( self.enemy, 2, "Move to a more open area to teleport your minion in\n" );
		dremove(self);
		return;
	}
	setorigin( self.owner, self.origin );
	WriteByte (MSG_BROADCAST, SVC_TEMPENTITY);
	WriteByte (MSG_BROADCAST, TE_TELEPORT);
	WriteCoord (MSG_BROADCAST, self.origin_x);
	WriteCoord (MSG_BROADCAST, self.origin_y);
	WriteCoord (MSG_BROADCAST, self.origin_z);
	multicast (self.origin, MULTICAST_PHS);
	dremove(self);
};
void ( entity t_plyr, float attrib_type, float skill_no ) Coop_UseMasterSkill =
{
	local entity te, monsterwarp, m_to_w;
	local float i, dist;
	if ( t_plyr.deadflag >= 2)
		return;
	if ( t_plyr.health < 1 )
		return;
// If you don't have the skill and not medic class back you go. -arg
	if ( Coop_HasMasterSkill( t_plyr, attrib_type ) == #FALSE && (self.playerclass != 5) )
	{
		sprint( t_plyr, 2, "You don't have the master skill for this particular attribute\n" );
		return;
	}
	if ( time < t_plyr.#next_masters_time )
	{
		sprint ( t_plyr, 2, "Your Masters Skill needs to recharge.\n" );
		return;
	}
//allows to cmd aura if you are medic class regardless. -arg
	if ( attrib_type == #ATTRIB_HEALTH || (self.playerclass == 5))
	{
		te = findradius( self.origin, 1550 ); //was 550 but too short to help when players get separated.
		while (te)
		{
			if ( te.classname == "player" && te.team_no == self.team_no && te.health > 0 && te.health < te.max_health && te != t_plyr )
			{
				i = 1;		// Just so we know that someone got healed
				sprint( self, 2, "You healed " );
				sprint( self, 2, te.connect_name );
				sprint( self, 2, "!\n +50 EXP Bonus & +150 Health\n" );
				WriteByte (MSG_BROADCAST, SVC_TEMPENTITY);
				WriteByte (MSG_BROADCAST, TE_LIGHTNING1);
				WriteEntity (MSG_BROADCAST, self);
				WriteCoord (MSG_BROADCAST, self.origin_x);
				WriteCoord (MSG_BROADCAST, self.origin_y);
				WriteCoord (MSG_BROADCAST, self.origin_z);
				WriteCoord (MSG_BROADCAST, te.origin_x);
				WriteCoord (MSG_BROADCAST, te.origin_y);
				WriteCoord (MSG_BROADCAST, te.origin_z);
				te.health = te.health + 190;				// was 90,addme: maybe give a little more than that?
				if ( te.health > te.max_health )
					te.health = te.max_health;
				MTF_Coop_AddExpAndWrite ( self, world, 50, #FALSE );		// was 2 we get 50 exp for healing others -arg
				self.health = self.health + 150; //physician heal thyself some.
				if ( self.health > self.max_health )
					self.health = self.max_health;
			}
			te = te.chain;
		}
		if ( i == 0 )
		{
			sprint( self, 2, "Nobody to heal nearby.\n" );
			t_plyr.#next_masters_time = time + 1;
		}
		else
			t_plyr.#next_masters_time = time + 5; // was 10 -arg
	}
	else
	if ( attrib_type == #ATTRIB_ARMOR )
	{
	}
	else
	if ( attrib_type == #ATTRIB_MINION )
	{
		m_to_w = world;
		te = find(world, classname, "monster_goalie");
		while (te)
		{
			if (te.owner.is_minion == 1 && te.owner.owner == t_plyr)
			{
				if (m_to_w != world)
				{
					if ( vlen(te.origin - t_plyr.origin) > dist || dist == 0 )
					{
						m_to_w = te;
						dist = vlen(te.origin - t_plyr.origin);
					}
				}
				else
				{
					m_to_w = te;
					dist = vlen(te.origin - t_plyr.origin);
				}
			}
			te = find(te, classname, "monster_goalie");
		}
		if (m_to_w != world)
		{
			te = m_to_w.owner;
			monsterwarp = spawn();
			monsterwarp.size = te.size;
			monsterwarp.mins = te.mins;
			monsterwarp.maxs = te.maxs;
			monsterwarp.movetype = MOVETYPE_BOUNCE;
			monsterwarp.owner = te;
			monsterwarp.origin = (t_plyr.origin/* - '0 0 24'*/);
			monsterwarp.velocity_z = 400;
			monsterwarp.velocity_x = (-100 + (random () * 300));
			monsterwarp.velocity_y = (-100 + (random () * 300));
			monsterwarp.think = Masters_MinionSpawnThink;
			monsterwarp.nextthink = time + .35;
			monsterwarp.enemy = t_plyr;
		}
		else
			sprint ( t_plyr, 2, "No minion found to warp\n" );
	}
};
void ( float howmany ) MTF_Coop_ViewVoteTopRanks =
{
	local string rname;
	local float rank;
	local float file;
	local float i;
	if (howmany > #MAX_MAPRANKS)
		howmany = #MAX_MAPRANKS;
	if (howmany <= 0)
		howmany = 15;
	file = open ("topmaps.tfi", 0);
	sprint( self, 2, "-- TOP " );
	sprint( self, 2, ftos( howmany ) );
	sprint( self, 2, " RANKING MAPS (sorted by vote count) --\n" );
	sprint( self, 2, "Rank *    Map Name     *       # Votes    \n" );
	if (file == -1)
	{
		bprint(2,"topmaps.tfi does not exist! Add it to /fortress or experience unholy amounts of crashes!\n");
		return;
	}
	i = 0;
	while (i < howmany)
	{
		i++;
		rname = read(file);
		rname = frik_strcat(rname, "                        ");
		rname = substr(rname, 0, 16);
		rname = strzone(rname);
		if (i < 10)
			sprint( self, 2, " " );
		sprint( self, 2, " " );
		sprint( self, 2, ftos(i) );
		sprint( self, 2, "  - " );
		sprint( self, 2, rname );
		sprint( self, 2, ":          ");
		rank = stof(read(file));
		sprint( self, 2, substr( frik_strcat( ftos(rank), "\n" ), 0, 9) );
		strunzone(rname);
	}	
	close (file);
};
void(entity spy) Spy_RemoveDisguise = 
{
	local string st;
	local float tc;
	if (invis_only != 1)
	{
		if (spy.playerclass == 8)
		{
			if (spy.undercover_skin != 0)
			{
				spy.items = spy.items - (spy.items & 524288);
				spy.immune_to_check = time + 10;
				spy.undercover_skin = 0;
				spy.skin = 0;
				TeamFortress_SetSkin(spy);
			}
			if (spy.undercover_team != 0)
			{
				spy.items = spy.items - (spy.items & 524288);
				spy.immune_to_check = time + 10;
				spy.undercover_team = 0;
				stuffcmd(spy, "color ");
				tc = TeamFortress_TeamGetColor(spy.team_no) - 1;
				st = ftos(tc);
				stuffcmd(spy, st);
				stuffcmd(spy, "\n");
			}
			spy.is_undercover = 0;
			self.StatusRefreshTime = time + 0.1;
			TeamFortress_SpyCalcName(spy);
		}
	}
	else
	{
		if (spy.is_undercover)
		{
			spy.is_undercover = 0;
			spy.modelindex = modelindex_player;
			if (spy.items & 524288)
			{
				spy.items = spy.items - 524288;
			}
			self.StatusRefreshTime = time + 0.1;
		}
	}
	VWEPS_Update(spy);
};
void (vector org,vector dir) launch_spike =
{
	newmis = spawn ();
	if (self.weapon & 256/*#MWEAPON_BOUNCEMISSILE*/)
		newmis.attack_finished = 3;
	newmis.owner = self;
	newmis.movetype = 9;
	newmis.solid = 2;
	newmis.angles = vectoangles (dir);
	newmis.touch = spike_touch;
	newmis.weapon = 3;
	newmis.classname = "spike";
	newmis.think = SUB_Remove;
	newmis.nextthink = (time + 3);
	if ((deathmsg != 9))
	{
		setmodel (newmis, "progs/spike.mdl");
	}
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = (dir * 2000);
};
void () superspike_touch =
{
	local float ndmg;
	if ((other == self.owner))
	{
		return;
	}
	if ((other.solid == 1))
	{
		return;
	}
	if ((pointcontents (self.origin) == -6.000000))
	{
		dremove (self);
		return;
	}
	if (other.takedamage)
	{
		spawn_touchblood (18);
		deathmsg = self.weapon;
		if ((deathmsg == 9))
		{
			ndmg = 40;
		}
		else
		{
			ndmg = 13;
		}
		if ((self.owner.classname == "grenade"))
		{
			TF_T_Damage (other, self, self.owner.owner, ndmg, 2, 2);
		}
		else
		{
			TF_T_Damage (other, self, self.owner, ndmg, 2, 2);
		}
	}
	else
	{
		WriteByte (4, 23);
		WriteByte (4, 1);
		WriteCoord (4, self.origin_x);
		WriteCoord (4, self.origin_y);
		WriteCoord (4, self.origin_z);
		multicast (self.origin, 1);
	}
	dremove (self);
};
void() Remove = 
{
	FlameDestroy(self);
};
void() FlareGrenadeThink = 
{
	local float rnum;
	local float time_left;
	time_left = self.health - time;
	if (time_left > 37)
	{
		rnum = random();
		if (rnum < 0.5)
		{
			self.effects = 8;
		}
		else
		{
			self.effects = TF_FLARE_LIT;
		}
		self.nextthink = time + 0.05 + random() * 0.1;
	}
	else
	{
		if (time_left > 34)
		{
			rnum = random();
			if (rnum < 0.5)
			{
				self.effects = 4;
			}
			else
			{
				self.effects = 8;
			}
			self.nextthink = time + 0.05 + random() * 0.1;
		}
		else
		{
			if (time_left > 15)
			{
				self.effects = 4;
				self.nextthink = time + 10;
			}
			else
			{
				if (time_left < TF_FLARE_OFF)
				{
					self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
					remove(self);
				}
				else
				{
					self.effects = 8;
					self.nextthink = time + time_left;
				}
			}
		}
	}
};
void() RemoveFlare = 
{
	self.owner.effects = self.owner.effects - (self.owner.effects & 4);
	self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	dremove(self);
};
void() ammo_touch = 
{
	local entity stemp;
	local float best;
	local float gotgren;
	local float gotbox;
	gotgren = TF_FLARE_LIT;
	gotbox = TF_FLARE_LIT;
	if (other.classname != "player")
	{
		return;
	}
	if (other.health <= TF_FLARE_LIT)
	{
		return;
	}
	if (other.is_feigning)
	{
		return;
	}
	if (other.tfstate & 65536)
	{
		return;
	}
	stemp = self;
	self = other;
	best = W_BestWeapon();
	self = stemp;
	self.aflag *= ceil(4);
	if (self.weapon == TF_FLARE_OFF)
	{
		if (other.ammo_shells >= TeamFortress_GetMaxAmmo(other, 256))
		{
			return;
		}
		other.ammo_shells = other.ammo_shells + self.aflag;
		gotbox = TF_FLARE_OFF;
	}
	if (self.weapon == 2)
	{
		if (other.ammo_nails >= TeamFortress_GetMaxAmmo(other, 512))
		{
			return;
		}
		other.ammo_nails = other.ammo_nails + self.aflag;
		gotbox = TF_FLARE_OFF;
	}
	else
	{
		if (self.weapon == 3)
		{
			gotgren = GetGrenadePossibility();
			if (other.ammo_rockets >= TeamFortress_GetMaxAmmo(other, 1024))
			{
				gotbox = TF_FLARE_LIT;
			}
			else
			{
				gotbox = TF_FLARE_OFF;
				other.ammo_rockets = other.ammo_rockets + self.aflag;
			}
		}
		else
		{
			if (self.weapon == 4)
			{
				if (other.ammo_cells >= TeamFortress_GetMaxAmmo(other, 2048))
				{
					return;
				}
				other.ammo_cells = other.ammo_cells + self.aflag;
				gotbox = TF_FLARE_OFF;
			}
		}
	}
	if (!gotbox && !gotgren)
	{
		return;
	}
	sound(other, 3, "weapons/lock4.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	stuffcmd(other, "bf\n");
	if (gotbox)
	{
		bound_other_ammo(other);
		sprint(other, TF_FLARE_LIT, "You got the ");
		sprint(other, TF_FLARE_LIT, self.netname);
		sprint(other, TF_FLARE_LIT, ".\n");
		stemp = self;
		self = other;
		W_SetCurrentAmmo();
		self = stemp;
	}
	if (self.orig_origin != '0 0 0')
	{
		self.origin = self.orig_origin;
		//self.orig_origin = '0 0 0';
	}
	Respawn_Item(self, other);
};
void() item_shells = 
{
	if (Hipnotic_SaveModels2() == 1)
	{
		dremove(self);
		return;
	}
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	self.touch = ammo_touch;
	if (self.spawnflags & TF_FLARE_OFF)
	{
#ifdef mtf_coop_halloween
		precache_model ("progs/pumpkin.mdl");
		setmodel(self, "progs/pumpkin.mdl");
#else
		precache_model("maps/b_shell1.bsp");
		setmodel(self, "maps/b_shell1.bsp");
#endif
		self.aflag = 40;
	}
	else
	{
#ifdef mtf_coop_halloween
		precache_model ("progs/pumpkin.mdl");
		setmodel(self, "progs/pumpkin.mdl");
#else
		precache_model("maps/b_shell0.bsp");
		setmodel(self, "maps/b_shell0.bsp");
#endif
		self.aflag = 20;
	}
	self.weapon = TF_FLARE_OFF;
	self.netname = "shells";
	setsize(self, '0 0 0', '32 32 56');
	StartItem();
};
void () FlashTimer =
{
	local entity te;
	local string st;
	te = self.owner;
	te.FlashTime = (te.FlashTime - 0.100000);
	if ((te.FlashTime < 0.000000))
	{
		te.FlashTime = 0.000000;
		stuffcmd (te, "v_cshift 0\n");
		remove (self);
		return;
	}
	if ((te.FlashTime < 1.700000))
	{
		st = ftos ((te.FlashTime * 150.000000));
		stuffcmd (te, "v_cshift ");
		stuffcmd (te, st);
		stuffcmd (te, " ");
		stuffcmd (te, st);
		stuffcmd (te, " ");
		stuffcmd (te, st);
		stuffcmd (te, " ");
		stuffcmd (te, st);
		stuffcmd (te, "\n");
	}
	if ((te.FlashTime >= 1.700000))
	{
		stuffcmd (te, "v_cshift 255 255 255 255\n");
	}
	if (((te.client != "zquake") && (te.client != "fuhquake")))
	{
		stuffcmd (te, "gl_polyblend 1\n");
	}
	if ((te.client == "moreqw"))
	{
		stuffcmd (te, "gl_cshiftpercent 100\n");
	}
	self.nextthink = (time + 0.100000);
};
void() ConcussionGrenadeTouch = 
{
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};
void() ConcussionGrenadeExplode = 
{
	T_RadiusBounce(self, self.owner, 240, world);
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	BecomeExplosion();
	multicast(self.origin, TF_FLARE_OFF);
	self.owner.active_grenades_2 = (self.owner.active_grenades_2 - 1.000000);
	dremove(self);
};
void(entity this) FlameDestroy = 
{
	num_world_flames = num_world_flames - TF_FLARE_OFF;
	remove(this);
};
void() weapon_touch = 
{
	local float hadammo;
	local float best;
	local float new;
	local float old;
	local entity stemp;
	local float leave;
	if (!(other.flags & 8))
	{
		return;
	}
	if (other.is_feigning)
	{
		return;
	}
	if (other.tfstate & 65536)
	{
		return;
	}
	stemp = self;
	self = other;
	best = W_BestWeapon();
	self = stemp;
	if (deathmatch == 2 || coop)
	{
		leave = TF_FLARE_OFF;
	}
	else
	{
		leave = TF_FLARE_LIT;
	}
	if (self.classname == "weapon_nailgun")
	{
		if (leave && (other.weapons_carried & 512))
		{
			return;
		}
		if (!TeamFortress_CanGetWeapon(other, 512))
		{
			return;
		}
		hadammo = other.ammo_nails;
		new = 512;
		other.ammo_nails = other.ammo_nails + 30;
	}
	else
	{
		if (self.classname == "weapon_supernailgun")
		{
			if (leave && (other.weapons_carried & 1024))
			{
				return;
			}
			if (!TeamFortress_CanGetWeapon(other, 1024))
			{
				return;
			}
			hadammo = other.ammo_rockets;
			new = 1024;
			other.ammo_nails = other.ammo_nails + 30;
		}
		else
		{
			if (self.classname == "weapon_supershotgun")
			{
				if (leave && (other.weapons_carried & 256))
				{
					return;
				}
				if (!TeamFortress_CanGetWeapon(other, 256))
				{
					return;
				}
				hadammo = other.ammo_rockets;
				new = 256;
				other.ammo_shells = other.ammo_shells + 5;
			}
			else
			{
				if (self.classname == "weapon_rocketlauncher")
				{
					if (leave && (other.weapons_carried & 8192))
					{
						return;
					}
					if (!TeamFortress_CanGetWeapon(other, 8192))
					{
						return;
					}
					hadammo = other.ammo_rockets;
					new = 8192;
					other.ammo_rockets = other.ammo_rockets + 5;
				}
				else
				{
					if (self.classname == "weapon_grenadelauncher")
					{
						if (leave && (other.weapons_carried & 2048))
						{
							return;
						}
						if (!TeamFortress_CanGetWeapon(other, 2048))
						{
							return;
						}
						hadammo = other.ammo_rockets;
						new = 2048;
						other.ammo_rockets = other.ammo_rockets + 5;
					}
					else
					{
						if (self.classname == "weapon_lightning")
						{
							if (leave && (other.weapons_carried & 65536))
							{
								return;
							}
							if (!TeamFortress_CanGetWeapon(other, 65536))
							{
								return;
							}
							hadammo = other.ammo_rockets;
							new = 65536;
							other.ammo_cells = other.ammo_cells + 15;
						}
	else
	if (self.classname == "weapon_laser_gun")
	{
	if (leave && (other.items & IT_LASER_CANNON) )
			return;
		hadammo = other.ammo_rockets;
		new = IT_LASER_CANNON;
		other.ammo_cells = other.ammo_cells + 30;
	}
	else
	if (self.classname == "weapon_mjolnir")
	{
		if (leave && (other.items & IT_MJOLNIR) )
			return;
		hadammo = other.ammo_rockets;
		new = IT_MJOLNIR;
		other.ammo_cells = other.ammo_cells + 30;
	}
	else
	if (self.classname == "weapon_proximity_gun")
	{
		if (leave && (other.items & IT_PROXIMITY_GUN) )
			return;
		hadammo = other.ammo_rockets;
		new = IT_PROXIMITY_GUN;
		other.ammo_rockets = other.ammo_rockets + 6;
	}
						else
						{
							objerror("weapon_touch: unknown classname");
						}
					}
				}
			}
		}
	}
	sprint(other, TF_FLARE_LIT, "You got the ");
	sprint(other, TF_FLARE_LIT, self.netname);
	sprint(other, TF_FLARE_LIT, "\n");
	sound(other, 3, "weapons/pkup.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	stuffcmd(other, "bf\n");
	bound_other_ammo(other);
	old = other.weapons_carried;
	other.weapons_carried = other.weapons_carried | new;
	stemp = self;
	self = other;
	Deathmatch_Weapon(old, new);
	W_SetCurrentAmmo();
	self = stemp;
	if (leave)
	{
		return;
	}
	Respawn_Item(self, other);
};
void() EMPExplode = 
{
	local float expsize;
	expsize = 10;
	if (self.touch == weapon_touch)
	{
		expsize = 60;
	}
	else
	{
		if (self.classname == "item_shells")
		{
			expsize = 50 + self.aflag;
		}
		else
		{
			if (self.classname == "item_spikes")
			{
				expsize = 40;
			}
			else
			{
				if (self.classname == "item_rockets")
				{
					expsize = 100 + self.aflag * 4;
				}
				else
				{
					if (self.classname == "item_cells")
					{
						expsize = 100 + self.aflag * 3;
					}
					else
					{
						if (self.classname == "item_weapon")
						{
							expsize = 60;
						}
						else
						{
							dprint("EMPExplode: Attempting to explode a ");
							dprint(self.classname);
							dprint("\n");
							return;
						}
					}
				}
			}
		}
	}
	deathmsg = 31;
	T_RadiusDamage(self, self.enemy, expsize, world);
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, TF_FLARE_OFF);
	Respawn_Item(self, self.enemy);
};
float (float orighp) MTF_Monster_Health2 =
{
	if (self.classname == "player")
		return ( orighp );
	if (self.classname == "monster_zombie" && self.spawnflags & 1/*SPAWN_CRUCIFIED*/)
		return ( orighp );
	if (self.classname == "monster_wrath")	// Make wrath easier
		orighp *= ceil(.65);
	if (self.monster_items & MITEM_MEGAHEALTH)
		orighp *= 2.5;
	if (self.classname == "monster_army")
		return (orighp * (18 * random()));		// in nehahra they have better AI, so lets lessen their hp a bit..
	else
	if (self.classname == "monster_dog")
		return (orighp * (17 * random()));
	else
		return (orighp * 3);
};
float (entity ent) InSolid =
{
	local entity tente, oself;
	local vector oldownerorg, oldorg, neworg;
	local float ret;
	if ( ent.owner != world )
	{
		oldownerorg = ent.owner.origin;
		ent.owner.origin_z = ent.owner.origin_z + ent.owner.maxs_z * 2;
		setorigin( ent.owner, ent.owner.origin + '0 0 200' );
	}
	tente = spawn ();
	tente.owner = ent;
	tente.solid = SOLID_SLIDEBOX;
	tente.movetype = MOVETYPE_STEP;
	tente.flags = FL_ONGROUND | FL_PARTIALGROUND;
	setsize (tente, ent.mins, ent.maxs);
	setorigin (tente, ent.origin);
	oself = self;
	self = tente;
	oldorg = tente.origin;
	ret = walkmove (0, 0);
	neworg = tente.origin;
	setorigin (tente, oldorg);
	if (oldorg != neworg && !droptofloor())
		ret = #FALSE;
	self = oself;
	if ( ent.owner != world )
		setorigin( ent.owner, oldownerorg );
	remove (tente);
	return !ret;
};
void(entity spy) TeamFortress_SpyCalcName = 
{
	local entity te;
	spy.undercover_name = string_null;
	if (spy.undercover_team != 0)
	{
		te = find(world, classname, "player");
		while (te)
		{
			if (te.team_no == spy.undercover_team && te.skin == spy.undercover_skin)
			{
				spy.undercover_name = te.netname;
				te = world;
			}
			else
			{
				te = find(te, classname, "player");
			}
		}
		if (spy.undercover_name == string_null)
		{
			te = find(world, classname, "player");
			while (te)
			{
				if (te.team_no == spy.undercover_team)
				{
					spy.undercover_name = te.netname;
					te = world;
				}
				else
				{
					te = find(te, classname, "player");
				}
			}
		}
	}
};
void (entity vwup) VWEPS_Update =
{
	local entity rpl;
	rpl = self;
	self = vwup;
	VWEPS_SetModel();
	self = rpl;
};
void (float damage) spawn_touchblood =
{
	local vector vel;
	vel = (wall_velocity () * 0.2);
	SpawnBlood ((self.origin + (vel * 0.01)), damage);
};
void () TeamFortress_DetpackExplode =
{
	local float pos;
	bprint (TF_FLARE_OFF,"FIRE IN THE HOLE!\n");
	sound (self,TF_FLARE_OFF,"weapons/detpack.wav",TF_FLARE_OFF,TF_FLARE_LIT);
	pos = pointcontents (self.origin);
	if ((pos != -2) && (pos != -6)) 
	{
		deathmsg = 12;
		T_RadiusDamage (self,self.owner,700,world);
		WriteByte (4,23);
		WriteByte (4,3);
		WriteCoord (4,self.origin_x);
		WriteCoord (4,self.origin_y);
		WriteCoord (4,self.origin_z);
		multicast (self.origin,TF_FLARE_OFF);
	if (self.weaponmode == TF_FLARE_OFF)
		TeamFortress_SetSpeed (self.enemy);
		dremove (self.oldenemy);
		dremove (self.observer_list);
	}
	BecomeExplosion ();
};
float () W_BestWeapon =
{
	local float it;
	it = self.weapons_carried;
	if ((((self.ammo_cells >= 1) && (it & 65536)) && (self.waterlevel <= 1)))
	{
		return (65536);
	}
	else
	{
		if ((((self.ammo_cells >= 6) && (self.ammo_shells >= 1)) && (it & 32768)))
		{
			return (32768);
		}
		else
		{
			if (((self.ammo_cells >= 1) && (it & 4096)))
			{
				return (4096);
			}
			else
			{
				if (((self.ammo_nails >= 2) && (it & 1024)))
				{
					return (1024);
				}
				else
				{
					if (((self.ammo_shells >= 2) && (it & 256)))
					{
						return (256);
					}
					else
					{
						if (((self.ammo_nails >= 1) && (it & 524288)))
						{
							return (524288);
						}
						else
						{
							if (((self.ammo_nails >= 1) && (it & 512)))
							{
								return (512);
							}
							else
							{
								if (((self.ammo_shells >= 1) && (it & 128)))
								{
									return (128);
								}
								else
								{
									if (((self.ammo_shells >= 1) && (it & 262144)))
									{
										return (262144);
									}
									else
									{
										if ((it & 4))
										{
											return (4);
										}
										else
										{
											if ((it & 8))
											{
												return (8);
											}
											else
											{
												if ((it & 16))
												{
													return (16);
												}
#ifdef NEW_CLASS1
										else
										{
											if ((it & #WEAPON_THUMPER))
											{
												return (#WEAPON_CROSSBOW);
											}
											else
											if ((it & #WEAPON_CROSSBOW))
											{
												return (#WEAPON_THUMPER);
											}
										}
#endif
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return (0.000000);
};
void() StartItem = 
{
	self.nextthink = time + 0.2;
	self.think = PlaceItem;
};
void () BackpackTouch =
{
	local string s;
	if (other.is_monster == 1)
		return;
	if (other.classname != "player")
	{
		return;
	}
	if ((other.health <= 0.000000))
	{
		return;
	}
	if (other.button0)
	{
		return;
	}
	other.ammo_shells = (other.ammo_shells + self.ammo_shells);
	other.ammo_nails = (other.ammo_nails + self.ammo_nails);
	other.ammo_rockets = (other.ammo_rockets + self.ammo_rockets);
	other.ammo_cells = (other.ammo_cells + self.ammo_cells);
	bound_other_ammo (other);
	sprint (other, 0.000000, "You get ");
	if (self.ammo_shells)
	{
		s = ftos (self.ammo_shells);
		sprint (other, 0.000000, s);
		sprint (other, 0.000000, " shells.  ");
	}
	if (self.ammo_nails)
	{
		s = ftos (self.ammo_nails);
		sprint (other, 0.000000, s);
		sprint (other, 0.000000, " nails. ");
	}
	if (self.ammo_rockets)
	{
		s = ftos (self.ammo_rockets);
		sprint (other, 0.000000, s);
		sprint (other, 0.000000, " rockets.  ");
	}
	if (self.ammo_cells)
	{
		s = ftos (self.ammo_cells);
		sprint (other, 0.000000, s);
		sprint (other, 0.000000, " cells.  ");
	}
	if (((self.armorvalue && (other.playerclass == 9.000000)) && (other.ammo_cells < other.maxammo_cells)))
	{
		s = ftos (self.armorvalue);
		sprint (other, 0.000000, s);
		sprint (other, 0.000000, " metal.  ");
		other.ammo_cells = (other.ammo_cells + self.armorvalue);
		if ((other.ammo_cells > other.maxammo_cells))
		{
			other.ammo_cells = other.maxammo_cells;
		}
	}
	sprint (other, 0.000000, "\n");
	if (other.autodiscard)
	{
		TeamFortress_Discard ();
	}
	sound (other, 3.000000, "weapons/lock4.wav", 1.000000, 1.000000);
		stuffcmd (other, "bf\n");  // what does this do? 
	dremove (self);
	self = other;
	sprint5(other, 2, "You picked up some misc ammunition.\n ");
	sprint5(other, 2, "You picked up 1 beartrap, 1 gravity well, 1 can of pork n beans, 1 auto sentry turrret.\n ");  //report pk goodies -arg
	self.pk_gravitywellammo = self.pk_gravitywellammo +1;
	self.pk_turretammo = self.pk_turretammo +1;
	self.pk_canpabammo = self.pk_canpabammo +1;
	self.pk_beartrapammo = self.pk_beartrapammo +1;
	W_SetCurrentAmmo ();
};
float() GetGrenadePossibility = 
{
	if (random() < 0.5)
	{
		return TF_FLARE_LIT;
	}
	if (random() < 0.5)
	{
		if (other.tp_grenades_1 != TF_FLARE_LIT && other.no_grenades_1 < 4)
		{
			other.no_grenades_1 = other.no_grenades_1 + 2;
			sprint(other, 2, "You found a ");
			PrintGrenadeType(other, other.tp_grenades_1);
			sprint(other, 2, " grenade\n");
			return TF_FLARE_OFF;
		}
	}
	else
	{
		if (other.tp_grenades_2 != TF_FLARE_LIT && other.no_grenades_2 < 4)
		{
			other.no_grenades_2 = other.no_grenades_2 + 2;
			sprint(other, 2, "You found a ");
			PrintGrenadeType(other, other.tp_grenades_2);
			sprint(other, 2, " grenade\n");
			return TF_FLARE_OFF;
		}
	}
	return TF_FLARE_LIT;
};
void(float old, float new) Deathmatch_Weapon = 
{};
void(entity ritem, entity act) Respawn_Item = 
{
	local entity oldself;
	oldself = self;
	self = ritem;
	self.model = string_null;
	self.solid = TF_FLARE_LIT;
	if (deathmatch != 2)
	{
		self.nextthink = time + 30;
	}
	else
	{
		if (coop && ritem.touch == ammo_touch)
		{
			self.nextthink = time + 45;
		}
	}
	self.think = SUB_regen;
	activator = act;
	SUB_UseTargets();
	self = oldself;
};
vector () wall_velocity =
{
	local vector vel;
	vel = normalize (self.velocity);
	vel = normalize (((vel + (v_up * (random () - 0.5))) + (v_right * (random () - 0.5))));
	vel = (vel + (2 * trace_plane_normal));
	vel = (vel * 200);
	return (vel);
};
void (string nname, float exp) MTF_Coop_WriteExperience =
{
	local string filename;
	local float file;
	if ( nname == "" || !nname )
		return;
	if (nname != self.connect_name)
	{
		bprint(2, "If you see this message tell the DEV that exp was trying to be added to ");
		bprint(2, self.connect_name);
		bprint(2, " in the name of ");
		bprint(2, nname);
		bprint(2, "\n");
		return;
	}
	if ( exp < 0 )
		return;
	nname = strzone(nname);
	filename = strzone( frik_strcat( "ranks/", nname, ".tfi" ) );
	strzone(filename);
	if ( checkfilename(filename) != 1 )
	{	// done in C - makes sure the file name 
		return;				// is writable
	}
	file = open (filename, 0);
	if ((file == -1))
	{
		file = open (filename, 2);
		write (file, ftos(exp));
		write (file, "\n");
		write (file, "// attribute points:\n");
		write (file, ftos(self.attribute_points));
		write (file, "\n");
		write (file, "// Attributes: health, armor, damage, misc, ammo\n");
		write (file, ftos(self.health_attr));
		write (file, "\n");
		write (file, ftos(self.armor_attr));
		write (file, "\n");
		write (file, ftos(self.damage_attr));
		write (file, "\n");
		write (file, ftos(self.misc_attr));
		write (file, "\n");
		write (file, ftos(self.ammo_attr));
		write (file, "\n");
		write (file, ftos(self.crit_attr));  // What about writing the other attributes? -arg bugged, fixed. 
		write (file, "\n");
		write (file, ftos(self.reload_attr));
		write (file, "\n");
		write (file, ftos(self.minion_attr));
		write (file, "\n");
		write (file, ftos(self.quickshot_attr));
		write (file, "\n");
		write (file, ftos(self.clipex_attr));
		write (file, "\n");
		write (file, ftos(self.proj_attr));
		write (file, "\n");
		close (file);
		strunzone(nname);
		strunzone(filename);
		return;
	}
	close (file);
	file = open (filename, 2);
	write (file, ftos(exp));
	write (file, "\n");
	write (file, "// attribute points:\n");
	write (file, ftos(self.attribute_points));
	write (file, "\n");
	write (file, "// Attributes: health, armor, damage, misc, ammo, critical strike\n");
	write (file, ftos(self.health_attr));
	write (file, "\n");
	write (file, ftos(self.armor_attr));
	write (file, "\n");
	write (file, ftos(self.damage_attr));
	write (file, "\n");
	write (file, ftos(self.misc_attr));
	write (file, "\n");
	write (file, ftos(self.ammo_attr));
	write (file, "\n");
	write (file, ftos(self.crit_attr));
	write (file, "\n");
	write (file, ftos(self.reload_attr)); // fixed, write attributes 7-11 also -arg
	write (file, "\n");
	write (file, ftos(self.minion_attr)); // why was this missing? -arg
	write (file, "\n");
	write (file, ftos(self.quickshot_attr));
	write (file, "\n");
	write (file, ftos(self.clipex_attr));
	write (file, "\n");
	write (file, ftos(self.proj_attr));
	write (file, "\n");
	close (file);
	strunzone(filename);
	MTF_Coop_RanksExperience ( nname, exp );
	strunzone(nname);
};
void() PlaceItem = 
{
	local float oldz;
	self.mdl = self.model;
	self.flags = 256;
	self.solid = TF_FLARE_OFF;
	self.movetype = 6;
	self.velocity = '0 0 0';
	self.origin_z = self.origin_z + 6;
	oldz = self.origin_z;
	if (!droptofloor())
	{
		dprint("Bonus item fell out of level at ");
		dprint(vtos(self.origin));
		dprint("\n");
		dremove(self);
		return;
	}
};
void(entity pl, float typ) PrintGrenadeType = 
{
	local string st;
	if (typ == TF_FLARE_OFF)
	{
		st = "Normal";
	}
	else
	{
		if (typ == 2)
		{
			st = "Concussion";
		}
		else
		{
			if (typ == 3)
			{
				st = "Nail";
			}
			else
			{
				if (typ == 4)
				{
					st = "Mirv";
				}
				else
				{
					if (typ == 5)
					{
						st = "Napalm";
					}
					else
					{
						if (typ == 6)
						{
							st = "Flare";
						}
						else
						{
							if (typ == 7)
							{
								st = "Gas";
							}
							else
							{
								if (typ == 8)
								{
									st = "EMP";
								}
								else
								{
									if (typ == 9)
									{
										st = "Flash";
									}
								}
							}
						}
					}
				}
			}
		}
	}
	sprint(pl, 2, st);
};
void() SUB_regen = 
{
	if (self.active_vehicle == 1)
	{
		self.think = SUB_regen;
		self.nextthink = time + .5;
		return;
	}
	self.model = self.mdl;
	self.solid = TF_FLARE_OFF;
	sound(self, 2, "items/itembk2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	setorigin(self, self.origin);
};
float() Sentry_FindTarget = 
{
	local entity the_client;
	local float r;
	local float gotone;
	local float loopc;
	local entity head;
	r = 0;
	loopc = 0;
	gotone = 0;
		head = findradius(self.origin, 1000);
		while (head)
		{
			if (head.health > 0 && head.is_monster == 1 && head.is_minion == #FALSE)
			{
				if (visible (head))
				{
					the_client = head;
					gotone = 1;
				}
			}
			head = head.chain;
		}
		if (!gotone)
		{
	the_client = findradius(self.origin, 1000);
	while (the_client != world && gotone != 1)
	{
		gotone = 1;
		if (!the_client)
		{
			gotone = 0;
		}
		if (the_client == self)
		{
			gotone = 0;
		}
		if (the_client.th_die == Reset_My_Grapple)
			gotone = 0;
		if (the_client.has_disconnected == 1)
		{
			gotone = 0;
		}
		if (!(the_client.takedamage))
		{
			gotone = 0;
		}
		if (teamplay)
		{
			if (the_client.team_no == self.team_no && self.team_no != 0)
			{
				gotone = 0;
			}
			if (the_client.undercover_team == self.team_no && self.team_no != 0)
			{
				gotone = 0;
			}
		}
		if (the_client == self.real_owner)
		{
			gotone = 0;
		}
		if (the_client.is_feigning)
		{
			gotone = 0;
		}
		if (the_client.flags & 128)
		{
			gotone = 0;
		}
		if (the_client.items & 524288)
		{
			gotone = 0;
		}
		if (!visible(the_client))
		{
			gotone = 0;
		}
		r = range(the_client);
		if (r == 3)
		{
			gotone = 0;
		}
		else
		{
			if (r == 2 && !infront(the_client))
			{
				gotone = 0;
			}
		}
		if (!gotone)
		{
			the_client = the_client.chain;
		}
	}
	}
	if (!gotone)
	{
		return 0;
	}
	self.enemy = the_client;
	Sentry_FoundTarget();
	return 1;
};
float turret_clearGround (entity head) =
{
	local entity e, parent;
	local float radius;
	local float childrenOfHeadOnGround;  
	radius = vlen (head.size);
	e = findradius (head.origin, radius);
	childrenOfHeadOnGround = FALSE;
	parent = head;
	while(e)
	{
	if(e != parent && e.groundentity == parent && e.flags & FL_ONGROUND)
	{
	childrenOfHeadOnGround = TRUE;
	parent = e;
		radius = vlen (parent.size);
		e = findradius (parent.origin, radius);
	}
	else
	{
		e = e.chain; 
	}
	}
	parent.flags = parent.flags - FL_ONGROUND;
	if(childrenOfHeadOnGround)
	{
		return TRUE;  
	}
	else
	{
		return FALSE;
	}
};
void() Reset_My_Grapple = 
{
	sound(self.owner, TF_FLARE_OFF, "doors/ddoor2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.owner == world)
		return;
	self.owner.on_hook = TF_FLARE_LIT;
	self.owner.hook_out = TF_FLARE_LIT;
	self.owner.fire_held_down = TF_FLARE_LIT;
	self.owner.weaponframe = TF_FLARE_LIT;
	self.think = SUB_Remove;
	self.nextthink = time;
};
void() Sentry_FoundTarget = 
{
	if (self.ammo_shells > 0 || (self.ammo_rockets > 0 && self.weapon == 3))
	{
		sound(self, 2, "weapons/pain.wav", 1, 1);
		self.last_saveme_sound = time + 5;
	}
	Sentry_HuntTarget();
	if (self.super_damage_finished < time)
	{
		self.super_damage_finished = time + 0.5;
	}
};
void() Sentry_HuntTarget = 
{
	self.goalentity = self.enemy;
	if (self.weapon == 1)
	{
		self.think = lvl1_sentry_atk1;
	}
	else
	{
		if (self.weapon == 2)
		{
			self.think = lvl2_sentry_atk1;
		}
		else
		{
			self.think = lvl3_sentry_atk1;
		}
	}
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
	self.nextthink = time + 0.1;
	SUB_AttackFinished(1);
};
void() ai_face = 
{
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
	self.ideal_yaw = anglemod(self.ideal_yaw);
	ChangeYaw();
};
void() lvl1_sentry_stand = [0, lvl1_sentry_stand]
{
	Sentry_Rotate();
};
void() lvl1_sentry_atk1 = [1, lvl1_sentry_atk3]
{
	ai_face();
	if (self.enemy == world || self.enemy.health <= 0 || !visible(self.enemy)/* || self.enemy.has_disconnected == 1 || (self.enemy.team_no == 0 && !self.is_monster)*/)
	{
		lvl1_sentry_stand();
	}
	else
	{
		if (self.ammo_shells <= 0)
		{
			lvl1_sentry_stand();
		}
		else
		{
			if (Sentry_Fire() == 0)
			{
				lvl1_sentry_atk3();
			}
		}
	}
};
void() lvl1_sentry_atk2 = [2, lvl1_sentry_atk3]
{
	ai_face();
	Sentry_Fire();
};
void() lvl1_sentry_atk3 = [0, lvl1_sentry_atk1]
{
	ai_face();
};
void() lvl2_sentry_stand = [3, lvl2_sentry_stand]
{
	Sentry_Rotate();
};
void() lvl2_sentry_atk1 = [4, lvl2_sentry_atk2]
{
	ai_face();
	if (self.enemy == world || self.enemy.health <= 0 || !visible(self.enemy)/* || self.enemy.has_disconnected == 1 || (self.enemy.team_no == 0 && !self.is_monster)*/)
	{
		lvl2_sentry_stand();
	}
	else
	{
		if (self.ammo_shells <= 0)
		{
			lvl2_sentry_stand();
		}
		else
		{
			if (Sentry_Fire() == 0)
			{
				lvl2_sentry_atk3();
			}
		}
	}
};
void() lvl2_sentry_atk2 = [5, lvl2_sentry_atk3]
{
	ai_face();
	Sentry_Fire();
};
void() lvl2_sentry_atk3 = [3, lvl2_sentry_atk1]
{
	ai_face();
	Sentry_Fire();
};
void() lvl3_sentry_stand = [6, lvl3_sentry_stand]
{
	Sentry_Rotate();
};
void() lvl3_sentry_atk1 = [7, lvl3_sentry_atk2]
{
	ai_face();
	if (self.enemy == world || self.enemy.health <= 0 || !visible(self.enemy)/* || self.enemy.has_disconnected == 1 || (self.enemy.team_no == 0 && !self.is_monster)*/)
	{
		lvl3_sentry_stand();
	}
	else
	{
		if (self.ammo_shells <= 0 && self.ammo_rockets <= 0)
		{
			lvl3_sentry_stand();
		}
		else
		{
			if (Sentry_Fire() == 0)
			{
				lvl3_sentry_atk3();
			}
		}
	}
};
void() lvl3_sentry_atk2 = [8, lvl3_sentry_atk3]
{
	ai_face();
	Sentry_Fire();
};
void() lvl3_sentry_atk3 = [6, lvl3_sentry_atk1]
{
	ai_face();
	Sentry_Fire();
};
void() Sentry_Rotate = 
{
	local float ay;
	CheckSentry(self);
	if (Sentry_FindTarget())
	{
		return;
	}
	if (self.heat == 0)
	{
		self.angles_x = 0;
		self.ideal_yaw = self.waitmin;
		ChangeYaw();
		ay = anglemod(self.angles_y);
		ay = rint(ay);
		if (ay == rint(self.waitmin))
		{
			self.heat = 1;
			if (random() < 0.1)
			{
				sound(self, 3, "weapons/gunidle1.wav", 0.5, 1);
			}
		}
	}
	else
	{
		self.ideal_yaw = self.waitmax;
		ChangeYaw();
		ay = anglemod(self.angles_y);
		ay = rint(ay);
		if (ay == rint(self.waitmax))
		{
			self.heat = 0;
		}
	}
};
void() Sentry_Pain = 
{
	self.real_owner.StatusRefreshTime = time + 0.2;
};
void() Sentry_Die = 
{
	sprint(self.real_owner, 2, "Your sentry gun was destroyed.\n");
	self.real_owner.has_sentry = 0;
	ThrowGib("progs/tgib1.mdl", -70);
	ThrowGib("progs/tgib2.mdl", -70);
	ThrowGib("progs/tgib3.mdl", -70);
	if (self.classname == "building_sentrygun_base")
	{
		if (self.oldenemy)
		{
			dremove(self.oldenemy);
		}
	}
	else
	{
		dremove(self.trigger_field);
	}
	WriteByte(4, 23);
	WriteByte(4, 3);
	WriteCoord(4, self.origin_x);
	WriteCoord(4, self.origin_y);
	WriteCoord(4, self.origin_z);
	multicast(self.origin, 1);
	BecomeExplosion();
};
float() Sentry_Fire = 
{
	local vector dir;
	local float dist, flytime;
	dir = self.enemy.origin - self.origin;
	if (self.enemy.classname == "bot" || self.enemy.classname == "player")
	{
	if (self.enemy.is_feigning)
		return #FALSE;
	if ((self.enemy.classname == "bot"))
	{
		if ((self.enemy.netname == "airmirv"))
		{
			dir = dir - (0.150000 * self.enemy.velocity);
		}
		else
		{
			dir = (self.enemy.origin + '0.000000 0.000000 -35.000000') - self.origin;
		}
	}
	if ((((self.ideal_yaw - anglemod (self.angles_y)) < -10.000000) || ((self.ideal_yaw - anglemod (self.angles_y)) > 10.000000)))
	{
		return (0.000000);
	}
	}
	sound (self, 1.000000, "weapons/plaser.wav", 1.000000, 1.000000);
	self.ammo_shells = (self.ammo_shells - 1.000000);
	if (self.#sentry_power == #SENTRY_QUAD)
		self.ammo_shells = (self.ammo_shells - 3);
	if ((self.ammo_shells < 0.000000))
	{
		self.ammo_shells = 0.000000;
	}
	traceline (self.origin + '0 0 20', self.enemy.origin, 0, self);
	if (trace_fraction != 1.0 && trace_ent.takedamage && self.ammo_shells > 0.000000)
	{
		deathmsg = 27.000000;
		if (coloredlights)
		{
			if ((self.real_owner.team_no == 1.000000))
			{
				self.effects = (self.effects | 64.000000);
			}
			else
			{
				if ((self.real_owner.team_no == 2.000000))
				{
					self.effects = (self.effects | 128.000000);
				}
				else
				{
					muzzleflash();
				}
			}
		}
		else
		{
			muzzleflash();
		}
		if (self.#sentry_power == #SENTRY_FLAME)
		{
			newmis = spawn();
			newmis.owner = self;
			newmis.team_no = self.team_no;		// Make sure the flames don't torch your own team members -arg
			newmis.real_owner = self;
			newmis.movetype = 9;
			makevectors(self.angles);
			newmis.velocity = normalize ((self.enemy.origin - self.origin));
			newmis.velocity = (newmis.velocity * 10000);
			newmis.velocity = newmis.velocity * 100;
			newmis.solid = 1;
			newmis.classname = "newmisrnewmis";
			muzzleflash();
			newmis.touch = sham_Flamer_stream_touch;
			newmis.think = s2_explode1;
			newmis.nextthink = time + 0.15;
			setmodel(newmis, "progs/s_expl.spr");
			setsize(newmis, '0 0 0', '0 0 0');
			setorigin(newmis, self.origin + v_forward * 16 + '0 0 16');
			self.ammo_shells = (self.ammo_shells - 1);
		}
		else
		if (self.#sentry_power == #SENTRY_SEEKER)
		{
			self.ammo_shells = self.maxammo_shells;
		}
		else
		if (self.#sentry_power == #SENTRY_QUAD)
		{
			FireBullets (3.000000, dir, '0.100000 0.100000 0.000000');
		}
		else
		FireBullets (1.000000, dir, '0.100000 0.100000 0.000000');
		self.angles = vectoangles (dir);		// look up and down at enemy
	}
	traceline (self.origin + '0 0 20', self.enemy.origin, #TL_BSP_ONLY, self);
	if (trace_fraction != 1 || trace_endpos != self.enemy.origin)
	{
		return FALSE;
	}
	if (self.#sentry_power == #SENTRY_FLAME)
	{
	}
	else
	if (self.#sentry_power == #SENTRY_SEEKER)
	{
		if (self.ammo_rockets > 0 && self.super_damage_finished < time)
		{
			dir = normalize (((self.enemy.origin + '0 0 10') - self.origin));
			dist = vlen ((self.enemy.origin - self.origin));
			flytime = (dist * 0.002);
			if ((flytime < 0.1))
			{
				flytime = 0.1;
			}
			muzzleflash ();
			sound (self, CHAN_WEAPON, "shalrath/attack2.wav", true, ATTN_NORM);
			newmis = spawn ();
			newmis.owner = self;
			newmis.team_no = self.team_no;
			newmis.real_owner = self;
			newmis.solid = SOLID_BBOX;
			newmis.movetype = MOVETYPE_FLYMISSILE;
			setmodel (newmis, "progs/v_spike.mdl");
			setsize (newmis, VEC_ORIGIN, VEC_ORIGIN);
			newmis.origin = (self.origin + '0 0 10');
			newmis.velocity = (dir * 400);
			newmis.avelocity = '300 300 300';
			newmis.nextthink = (flytime + time);
			newmis.think = ShalHome;
			newmis.enemy = self.enemy;
			newmis.touch = ShalMissileTouch;
			self.super_damage_finished = (time + 2.000000);
			self.ammo_rockets = (self.ammo_rockets - 1.000000);
		}
	}
	else
	{
		if ((((self.weapon == 3.000000) && (self.ammo_rockets > 0.000000)) && (self.super_damage_finished < time)))
		{
			sound (self, 1.000000, "weapons/rocklr1a.wav", 1.000000, 1.000000);
			newmis = spawn ();
			newmis.owner = self;
			newmis.classname = "sentry_rockets";
			newmis.team_no = self.team_no;
			newmis.movetype = 9.000000;
			newmis.solid = 2.000000;
			newmis.velocity = (normalize (dir) * 800.000000);
			newmis.angles = vectoangles (newmis.velocity);
			newmis.weapon = 34.000000;
			newmis.touch = T_MissileTouch;
			newmis.nextthink = (time + 5.000000);
			newmis.think = SUB_Remove;
			setmodel (newmis, "progs/missile.mdl");
			setsize (newmis, '0.000000 0.000000 0.000000', '0.000000 0.000000 0.000000');
			setorigin (newmis, ((self.origin + (v_forward * 8.000000)) + '0.000000 0.000000 16.000000'));
			self.super_damage_finished = (time + 3.000000);
			self.ammo_rockets = (self.ammo_rockets - 1.000000);
			if ((self.ammo_rockets == 10.000000))
			{
				sprint (self.real_owner, 2.000000, "Sentry Gun is low on rockets.\n");
			}
		}
	}
	if (((self.ammo_shells == 0.000000) && (random () < 0.100000)))
	{
		sprint (self.real_owner, 2.000000, "Sentry Gun is out of shells.\n");
	}
	else
	{
		if ((self.ammo_shells == 20.000000))
		{
			sprint (self.real_owner, 2.000000, "Sentry Gun is low on shells.\n");
		}
	}
	if ((((self.ammo_rockets == 0.000000) && (self.weapon == 3.000000)) && (random () < 0.100000)))
	{
		sprint (self.real_owner, 2.000000, "Sentry Gun is out of rockets.\n");
	}
	return (1.000000);
};
void (float shotcount,vector dir,vector spread) FireBullets =
{
	local vector direction;
	local vector src;
	makevectors (self.v_angle);
	src = (self.origin + (v_forward * 10));
	src_z = (self.absmin_z + (self.size_z * 0.7));
	ClearMultiDamage ();
	traceline (src, (src + (dir * 2048)), 0.000000, self);
	puff_org = (trace_endpos - (dir * 4));
	while ((shotcount > 0.000000))
	{
		direction = ((dir + ((crandom () * spread_x) * v_right)) + ((crandom () * spread_y) * v_up));
		traceline (src, (src + (direction * 2048)), 0.000000, self);
		if ((trace_fraction != 1))
		{
			if (self.classname == "building_sentrygun")
			{
				TraceAttack (6, direction);
			}
			else 
			if ((self.weapon != 32768))
			{
				TraceAttack (4, direction);
			}
			else
			{
				TraceAttack (9, direction);
			}
		}
		shotcount = (shotcount - 1);
	}
	ApplyMultiDamage ();
	Multi_Finish ();
};
void (string gibname, float dm) turret_throwGib =
{
	local entity new;
	new = spawn();
	new.origin = self.origin;
	setmodel (new, "progs/turret.mdl");
	setsize (new, '0 0 0', '0 0 0');
	new.velocity = VelocityForDamage (dm);
	new.movetype = 10;
	new.solid = SOLID_NOT;
	new.avelocity_x = random()*600;
	new.avelocity_y = random()*600;
	new.avelocity_z = random()*600;
	new.think = SUB_Remove;
	new.ltime = time;
	new.nextthink = time + 10 + random()*10;
	new.frame = 0;
	new.flags = 0;
	new.takedamage = 1;
	new.classname = "turret_gib";
	new.owner = self.owner; // changed from self.owner -arg 
	new.touch = turret_gibTouch;
};
void () ClearMultiDamage =
{
	multi_ent = world;
	multi_damage = 0.000000;
	blood_count = 0.000000;
	puff_count = 0.000000;
};
$frame gunsearch gunfire1 gunfire2 gunfire3 gunfire4 gunmisfire1 gunmisfire2
void () turret_physicsCheck = 
{
	if (self.origin != self.turret_base.origin)	
	  setorigin (self, self.turret_base.origin);
	if (self.velocity != self.turret_base.velocity)
	  self.velocity = self.turret_base.velocity;
	self.flags = self.turret_base.flags;
};
float() turret_dropTurret =
{
	local entity turret;
	local vector dir;
	if (self.pk_turretammo <= 0)
	{
		return(0); // pk112
	}
	makevectors (self.v_angle);
	dir = self.origin + self.view_ofs;
	traceline (dir, dir + v_forward * 50, 0, self);
	makevectors (self.angles);
	if (trace_fraction != 1.0 && !trace_ent.takedamage)
	{
		sprint (self, PRINT_HIGH, "Don't throw the turret when you are so close to a damn wall!!\n");
		return (0); // pk112
	}
	self.pk_turretammo = self.pk_turretammo -1;
	turret = spawn();
	turret.owner = self;
	turret.movetype = MOVETYPE_TOSS;  //efc put back in
	turret.solid = SOLID_NOT;
	turret.classname = "turret";
	turret.team_no = self.team_no;
	turret.takedamage = 1;
	turret.health = 300;
	turret.th_die = turret_deathAnim;
	turret.ammo_cells = 165; 	// was 65 -arg but we have megahealth monsters and players. so...
	turret.angles = self.angles;
	turret.v_angle = self.v_angle;
	turret.turret_ownertimeout = time + 150.5; 	//changed from 50 so it doesn't get too crazy. -arg																																			// Changed so sentries will not shoot owner -=most of the time=- SH*
	turret.nextthink = time + 0.1;
	turret.think = turret_searchForEnemy;
	setmodel (turret, "progs/turtop.mdl");
	setsize (turret, '-15 -14 -18', '21 7 10');
	makevectors (self.angles);
	setorigin (turret, self.origin + self.view_ofs + v_forward * 20); // efc put this back in
	turret.turret_base = spawn();
	turret.turret_base.owner = turret;
	turret.turret_base.movetype = MOVETYPE_TOSS;
	turret.turret_base.solid = SOLID_NOT;
	turret.turret_base.classname = "turret_base";
	turret.turret_base.takedamage = 1;
	turret.turret_base.health = 250;
	turret.turret_base.th_die = turret_deathAnimBase;
	makevectors (self.v_angle);
	turret.velocity = aim (self, 800); // efc aiming
	turret.velocity = turret.velocity * (500 + random() * 20) + '0 0 200'; // efc aiming
	turret.turret_base.v_angle = self.v_angle;
	turret.turret_timeout = time + 120;			//SH* Turret life in secs
	turret.nextthink = time + 0.1;
	if (self.super_damage_finished > time)
	{
		turret.effects = EF_BLUE;   // Make turret blue when player is on quad. :} -arg
	}
	turret.think = turret_searchForEnemy;
	setmodel (turret.turret_base, "progs/turstand.mdl");
	setsize (turret, '-5 -5 -18', '5 5 1');
	setorigin (turret.turret_base, turret.origin); // efc
	turret.turret_base.velocity = turret.velocity; // efc aiming
	if (pointcontents(self.origin) == #CONTENT_SKY)  // If it touches the sky or gets stuck there, remove it. Borrowed code from weapons.qc Fusion_Touch - arg 11/2013
	{
		remove(self);
		return(0);
	}
	return (1);
};
void() turret_searchForEnemy =
{
if ((self.owner.owner.has_disconnected == 1.000000))
	{
		turret_deathAnim ();
	}
	if (self.turret_timeout < time)
	{
		turret_deathAnim();
		return;
	}
	turret_physicsCheck();	// efc add
	if (self.solid == SOLID_NOT)
	{
		turret_checkIfCanBeSolid();
	}
	self.frame = $gunsearch;
	self.angles = self.angles + '0 10 0';
	self.v_angle = self.angles;
	turret_findTarget();
	self.nextthink = time + 0.1;
};
void() turret_findTarget =
{
	local float dist, tempDist;
	local entity head, selected;
	local vector search_area_center;
	local float attack_intermission; 
	dist = 2000; // efc: This is still much farther than the projectiles can actually reach
	selected = world;
	makevectors (self.v_angle);
	search_area_center = self.origin + (v_forward * (dist / 2));
	head = findradius (search_area_center, dist / 2);
	while (head)
	{
		attack_intermission = (intermission_running && (head.classname == "info_intermission"));
		attack_intermission |= (head.classname == "spectator");
		if (head.team_no != self.team_no) // if it's not on the team that launched it, it's fair game.
		if (((head.health > 1) && (head.takedamage)) || attack_intermission)
			if (head.classname != "beartrap")
				if (!((head.classname == "turret") && (head.owner == self.owner)))
					if (head.classname != "turret_base")
						if (self.turret_ownertimeout < time || head != self.owner)
							if (head.classname != "player" || !(head.items & IT_INVISIBILITY))
								if (head != self)
									if (head.classname != "misc_explobox") // +pk112 don't attack boxes
										if (head.classname != "misc_explobox2") // +pk112
										if (head.classname != "info_intermission" || attack_intermission) // efc, don't attack cam unless at intermission									  
											if(head.movetype != MOVETYPE_PUSH)
											{
													tempDist = vlen(head.origin - self.origin);
													traceline (self.origin, head.origin, 1, self);
													if (trace_fraction >= 1)
														if (tempDist < dist)
															if (turret_inFront(head))
																if (visible(head))
																{
																	selected = head;
																	dist = tempDist;
																}
											}
		head = head.chain;
	}
	if (self.turret_soundtimeout < time)
	{
		sound (self, CHAN_WEAPON, "weapons/sentry/turrt_3.wav", 1, ATTN_NORM);
		self.turret_soundtimeout = time + 0.5;
	}
	if (selected != world)
	{
		self.enemy = selected;
		self.angles = vectoangles (selected.origin - self.origin);
		self.think = turret_attackEnemy;
}
};
float (entity e) turret_inFront =
{
	local vector vec;
	local float dot;
	makevectors (self.v_angle);
	vec = normalize (e.origin - self.origin);
	dot = vec * v_forward;
	if (dot > 0.8) // efc: this is 36.87 degrees or less
	{
		return (1);
	}
	return (0);
};
void() turret_attackEnemy =
{
	if (self.turret_timeout < time)
	{
		turret_deathAnim();
		return;
	}
	deathmsg = 27.000000;
	 turret_physicsCheck();
	if (self.solid == SOLID_NOT)
	{
		turret_checkIfCanBeSolid();
	}
	if (self.ammo_cells > 0)
	{
		self.frame = self.frame + 1;
		if (self.frame > 5)
		{
			self.frame = $gunfire1;
		}
	}
	else
	{
		if (self.frame != 5)
		{
			self.frame = $gunmisfire1;
			sound (self, CHAN_WEAPON, "weapons/sentry/turcl_2b.wav", 0.2, ATTN_NORM);
		}
		else
		{
			self.frame = $gunmisfire2;
		}
	}
	if (visible(self.enemy) &&
			((self.enemy.health > 1 && (self.enemy.classname != "player" || !(self.enemy.items & IT_INVISIBILITY)))
			 || (intermission_running && (self.enemy.classname == "info_intermission"))))
	{
		local vector targetview;
		targetview = vectoangles ((self.enemy.origin + self.enemy.view_ofs)- self.origin);
		if (targetview != self.angles)
		{
			self.angles = targetview;
			if (self.turret_soundtimeout < time)
			{
				sound (self, CHAN_WEAPON, "weapons/sentry/turrt_3.wav", 1, ATTN_NORM);
				self.turret_soundtimeout = time + 0.5;
			}
		}
		if (self.frame == 1 || self.frame == 3)
		{
			if (self.ammo_cells > 0)
			{ 
				local vector firePosition;
				makevectors (self.angles);
				local vector projectedPosition;
				projectedPosition = self.enemy.origin; // + enemyVelocity * timeToEnemy;
				if (self.frame == 1)
				{
					firePosition = self.origin + (v_forward * 21) - (v_right * 3);
					turret_launchNail(firePosition, (projectedPosition + self.enemy.view_ofs) - firePosition);
				}
				else
				{
					firePosition = self.origin + (v_forward * 21) + (v_right * 3);
					turret_launchNail(firePosition, projectedPosition - firePosition);
				}
				self.ammo_cells = self.ammo_cells - 1;
			}
		}
	}
	else
	{
		self.think = turret_searchForEnemy;
		self.frame = $gunsearch;
		self.angles_x = 0;
		self.angles_z = 0;
		self.v_angle = self.angles;
	}
	self.nextthink = time + 0.1;
};
void() turret_explode =
{
	T_RadiusDamage (self, self, 40, self); 																																																				// 60 in m8 SH*
	WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
	WriteByte (MSG_MULTICAST, TE_EXPLOSION);
	WriteCoord (MSG_MULTICAST, self.origin_x);
	WriteCoord (MSG_MULTICAST, self.origin_y);
	WriteCoord (MSG_MULTICAST, self.origin_z);
	deathmsg = 27.000000; // categorize death obituary as a turret sentry kill. -arg
	make_explosion ();
	deathmsg=27;
	T_RadiusDamage (self, self.owner, 50, world); // team damage allowed, don't stand next to it silly.
};
void() turret_deathAnim =
{
	local float numOfGibs;
	if(self.turret_base.flags & FL_ONGROUND)
	while(turret_clearGround(self.turret_base))
	{
	}
	turret_throwGib ("progs/turgib1.mdl", -50);
	turret_throwGib ("progs/turgib2.mdl", -50);
	turret_throwGib ("progs/turgib3.mdl", -50);
	numOfGibs = random() * 5;
	while (numOfGibs > 0)
	{
		local float dam;
		dam = random() * -50;
		turret_throwGib ("progs/turgib3.mdl", dam);
		numOfGibs = numOfGibs - 1;
	}
	remove (self.turret_base);
	remove (self);
	self.nextthink = time + 0.1;
	self.think = SUB_Remove;
};
void() turret_deathAnimBase =
{
	self = self.owner;
	turret_deathAnim();
};
void() turret_gibTouch =
{
	local vector org;
	if (other == self.owner)
		return; // don't explode on owner
	if (other.solid == SOLID_TRIGGER)
		return; // trigger field, do nothing
	if (pointcontents(self.origin) == CONTENT_SKY)
	{
		return;
	}
	org = self.origin - 8 * normalize (self.velocity);
	if (other.health)
	{
		SpawnBlood (org, 10);
		T_Damage (other, self, self, 10);  // still, don't stand next to turret when it dies. dummy.
		remove (self);
		return;
	}
	else
	{
		WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
		WriteByte (MSG_MULTICAST, TE_SPIKE);
		WriteCoord (MSG_MULTICAST, self.origin_x);
		WriteCoord (MSG_MULTICAST, self.origin_y);
		WriteCoord (MSG_MULTICAST, self.origin_z);
		multicast (self.origin, MULTICAST_PHS);
	}
};
void (vector org, vector vec) turret_launchNail =
{
	vec = normalize (vec);
	newmis = spawn();
	newmis.owner = self;
	newmis.movetype = MOVETYPE_FLY;
	newmis.solid = SOLID_BBOX;
	setmodel (newmis, "progs/nail.mdl");
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, org);
	newmis.velocity = vec * TurretNailSpeed; 																																			// was 600 in m8 SH*
	newmis.angles = vectoangles (newmis.velocity);
	newmis.classname = "sentry_nail";
	newmis.nextthink = time + 3;
	newmis.think = SUB_Remove;
	newmis.touch = turret_nailTouch;
	newmis.team_no = self.team_no;  // Hey, we are on the same team, don't shoot team mates.
	newmis.weapon = 1;
	sound (self, CHAN_WEAPON, "weapons/rocket1i.wav", 1, ATTN_NORM);
};
void() turret_nailTouch =
{
	local vector org;
	if (other == self.owner)
		return; // don't explode on owner
	if (other.solid == SOLID_TRIGGER)
		return; // trigger field, do nothing
	if (pointcontents(self.origin) == CONTENT_SKY)
	{
		remove (self);
		return; // no point trying to damage the sky, the nail is gone for good. remove it.
	}
	org = self.origin - 8 * normalize (self.velocity);
	deathmsg = 44.000000; // categorize death obituary as a turret sentry kill. -arg
	if (other.health)
	{
		SpawnBlood (org, 15);
		deathmsg = 44;
		T_Damage (other, self, self.owner, 40);
		if (self.super_damage_finished > time)  // add damage if player is on quad.
		{
			deathmsg = 44;
			T_Damage (other, self, self.owner, 200);
		}
	}
	else
	{
		WriteByte (MSG_MULTICAST, SVC_TEMPENTITY);
		WriteByte (MSG_MULTICAST, TE_SPIKE);
		WriteCoord (MSG_MULTICAST, self.origin_x);
		WriteCoord (MSG_MULTICAST, self.origin_y);
		WriteCoord (MSG_MULTICAST, self.origin_z);
		multicast (self.origin, MULTICAST_PHS);
	}
	remove (self);
};
void() turret_checkIfCanBeSolid =
{
	local entity head;
	head = findradius (self.origin, 28);
	if (!head)
	{
		self.turret_base.solid = SOLID_SLIDEBOX;
		self.solid = SOLID_SLIDEBOX;
		setsize (self, '-15 -14 -18', '21 7 10');
		setsize (self.turret_base, '-15 -14 -18', '9 14 1');
	}
};
void(string gibname, float dm) ThrowGib = 
{
	newmis = spawn();
	newmis.origin = self.origin;
	setmodel(newmis, gibname);
	setsize(newmis, '0 0 0', '0 0 0');
	newmis.velocity = VelocityForDamage(dm);
	newmis.movetype = MOVETYPE_BOUNCE;
	newmis.solid = SOLID_NOT;
	newmis.avelocity_x = random() * 600;
	newmis.avelocity_y = random() * 600;
	newmis.avelocity_z = random() * 600;
	newmis.think = SUB_Remove;
	newmis.ltime = time;
	newmis.nextthink = (time + 3);
	newmis.frame = 0;
	newmis.flags = 0;
};
void (float damage,vector dir) TraceAttack =
{
	local vector vel;
	local vector org;
	vel = normalize (((dir + (v_up * crandom ())) + (v_right * crandom ())));
	vel = (vel + (2 * trace_plane_normal));
	vel = (vel * 200);
	org = (trace_endpos - (dir * 4));
	if (trace_ent.takedamage)
	{
		blood_count = (blood_count + 1);
		blood_org = org;
		AddMultiDamage (trace_ent, damage);
	}
	else
	{
		puff_count = (puff_count + 1);
	}
};
void () ApplyMultiDamage =
{
	if (!multi_ent)
	{
		return;
	}
	TF_T_Damage (multi_ent, self, self, multi_damage, 2, 1);
};
void () Multi_Finish =
{
	if (puff_count)
	{
		WriteByte (4, 23);
		WriteByte (4, 2);
		WriteByte (4, puff_count);
		WriteCoord (4, puff_org_x);
		WriteCoord (4, puff_org_y);
		WriteCoord (4, puff_org_z);
		multicast (puff_org, 2);
	}
	if (blood_count)
	{
		WriteByte (4, 23);
		WriteByte (4, 12);
		WriteByte (4, blood_count);
		WriteCoord (4, blood_org_x);
		WriteCoord (4, blood_org_y);
		WriteCoord (4, blood_org_z);
		multicast (puff_org, 2);
	}
};
void (entity hit,float damage) AddMultiDamage =
{
	if (!hit)
	{
		return;
	}
	if ((hit != multi_ent))
	{
		ApplyMultiDamage ();
		multi_damage = damage;
		multi_ent = hit;
	}
	else
	{
		multi_damage = (multi_damage + damage);
	}
};
void() Remove_Splash =
{
	splash_count = splash_count - 1;
	remove (self);
};
$frame splash1 splash2 splash3 splash4 splash5
void() do_small_splash1 = [ $splash1, do_small_splash2 ]
{};
void() do_small_splash2 = [ $splash1, do_small_splash3 ]
{};
void() do_small_splash3 = [ $splash2, do_small_splash4 ]
{};
void() do_small_splash4 = [ $splash2, do_small_splash5 ]
{};
void() do_small_splash5 = [ $splash3, do_small_splash1 ]
{
	Remove_Splash();
};
void() do_large_splash1 = [ $splash1, do_large_splash2 ]
{};
void() do_large_splash2 = [ $splash2, do_large_splash3 ]
{};
void() do_large_splash3 = [ $splash3, do_large_splash4 ]
{};
void() do_large_splash4 = [ $splash4, do_large_splash5 ]
{};
void() do_large_splash5 = [ $splash5, do_large_splash1 ]
{
	Remove_Splash();
};
void() do_lava_splash1 = [ $splash1, do_lava_splash2 ]
{};
void() do_lava_splash2 = [ $splash2, do_lava_splash3 ]
{};
void() do_lava_splash3 = [ $splash3, do_lava_splash4 ]
{};
void() do_lava_splash4 = [ $splash4, do_lava_splash1 ]
{
	Remove_Splash();
};
void (entity e) MakeSplash =
{
	if (splash_count < 20)
	{
		local entity newent;
		newent = spawn();
		setorigin (newent, e.origin);
		newent.solid = SOLID_NOT;
		newent.movetype = MOVETYPE_NONE;
		newent.nextthink = time + 0.1;
		if (pc2 == CONTENT_LAVA || e.inwater == CONTENT_LAVA)
		{
			setmodel (newent, "progs/s_splava.spr");
			newent.think = do_lava_splash1;
		}
		else
		{
			setmodel (newent, "progs/s_splash.spr");
			newent.think = e.splash_func;
		}
		setsize (newent, '-8 -8 -8', '8 8 8'); //Added Per Nib--splash effect??
		splash_count = splash_count + 1;
	}
};
float (entity e) inWater =
{
	pc2 = pointcontents(e.origin);
	if (!(pc2 == CONTENT_WATER || pc2 == CONTENT_SLIME || pc2 == CONTENT_LAVA))
		pc2 = NOT_IN_WATER;
	return (pc2);
};
void() CheckWaterLevels =
{
	local entity e;
	e = find (world, water_notify, "yes");
	while (e != world)
	{
		if (inWater(e) != e.inwater)
		{
			if (e.classname == "drop")
			{
				sound (self, CHAN_AUTO, "misc/drip/drip_1.wav", 1, ATTN_NORM);
				remove (e);
			}
			else
			{
				if (!(stof(infokey(world, "options")) & PK_TP_SPARKSFLASH))
					MakeSplash(e);
				e.inwater = pc2;
				if (pc2 == CONTENT_LAVA)
				{
					if (e.classname == "beartrap")
					{
						e.think = beartrapDie;
						e.nextthink = time + 0.1;
					}
					else
					if (e.classname == "turret")
					{
						e.think = turret_deathAnim;
						e.nextthink = time + 0.1;
					}
				}
			}
		}
		e = find (e, water_notify, "yes");
	}
};
void (entity e) AddToSplash =
{
	e.inwater = inWater(e);
	e.water_notify = "yes";
	e.splash_func = do_small_splash1;
};
void (entity e) AddToSplashBig =
{
	e.inwater = inWater(e);
	e.water_notify = "yes";
	e.splash_func = do_large_splash1;
};
void() player_run = [6, player_run]
{
	local float rnum;
	rnum = random();
	check_shot_idle ();		// BTF Sub
	if ( (self.mtf_items & #MTFITEM_LIGHTGUN && self.current_weapon == 128) || self.current_weapon == #WEAP_ZEROGRAVITY )
		self.weaponframe = 7;
	else
	self.weaponframe = TF_FLARE_LIT;
	if ((self.Aircraft_Owner || (self.probe_active == 1)))
	{
		return;
	}
	if (!(self.velocity_x) && !(self.velocity_y))
	{
		self.walkframe = TF_FLARE_LIT;
		player_stand1();
		return;
	}
	if (self.monster_type > 0)
	{
		monster_run();
		return;
	}
	if (self.is_squating == 1)
	{
		setsize(self, '-16 -16 -24', '16 16 32');
		VWEPS_SetModel();
	}
	if (self.current_weapon <= 16)
	{
		if (self.walkframe == 6)
		{
			self.walkframe = TF_FLARE_LIT;
		}
		self.frame = TF_FLARE_LIT + self.walkframe;
	}
	else
	{
		if (self.walkframe == 6)
		{
			self.walkframe = TF_FLARE_LIT;
		}
		self.frame = self.frame + self.walkframe;
	}
	if (footsteps == 1 && checkbottom(self) == 1 && self.playerclass != TF_FLARE_LIT)
	{
		if (self.velocity_x > 200 || self.velocity_y > 200 || (self.velocity_x < -200 || self.velocity_y < -200))
		{
			if (self.playerclass == 8 && self.undercover_skin == TF_FLARE_LIT)
			{
				self.walkframe = self.walkframe + 1;
				return;
			}
			if (self.walkframe == 1)
			{
				if (self.vision == 1)
				{
					TeamFortress_NightVision();
				}
				if (self.waterlevel == TF_FLARE_LIT)
				{
					if (rnum < 0.6)
					{
						sound(self, 4, "player/step1l.wav", 0.8, 1);
					}
					else
					{
						sound(self, 2, "player/step2l.wav", 0.8, 1);
					}
				}
				if (self.waterlevel == 1)
				{
					sound(self, 2, "player/h2ojump.wav", 0.8, 1);
				}
				if (self.waterlevel == 2)
				{
					sound(self, 2, "player/inh2o.wav", 0.8, 1);
				}
			}
			if (self.walkframe == 4)
			{
				if (self.waterlevel == TF_FLARE_LIT)
				{
					if (rnum < 0.5)
					{
						sound(self, 2, "player/step1r.wav", 0.8, 1);
					}
					else
					{
						sound(self, 2, "player/step2r.wav", 0.8, 1);
					}
				}
				if (self.waterlevel == 1)
				{
					sound(self, 2, "player/h2ojump.wav", 0.8, 1);
				}
				if (self.waterlevel == 2)
				{
					sound(self, 2, "player/inh2o.wav", 0.8, 1);
				}
			}
		}
	}
	self.walkframe = self.walkframe + 1;
};
void () check_shot_idle =
{
	if ((self.weaponframe == 21))
	{
		if ((self.tools != (self.tools | 32)))
		{
			self.weaponmodel = "";
		}
		self.weaponframe = 0;
		return;
	}
};
void() TeamFortress_NightVision = 
{
	local entity te;
	local entity tl;
	sound(self, TF_FLARE_LIT, "items/nightvis.wav", 0.5, TF_FLARE_OFF);
	te = find(world, classname, "player");
	while (te)
	{
		if (self != te)
		{
			if (te.team_no != TF_FLARE_LIT)
			{
				if (te.health > TF_FLARE_OFF)
				{
					if (visible(te))
					{
						msg_entity = self;
						tl = spawn();
						tl.owner = self;
						tl.origin = te.origin;
						tl.origin_z = tl.origin_z + 32;
						WriteByte(TF_FLARE_OFF, 23);
						WriteByte(TF_FLARE_OFF, 9);
						WriteEntity(TF_FLARE_OFF, tl);
						WriteCoord(TF_FLARE_OFF, tl.origin_x);
						WriteCoord(TF_FLARE_OFF, tl.origin_y);
						WriteCoord(TF_FLARE_OFF, tl.origin_z);
						WriteCoord(TF_FLARE_OFF, te.origin_x);
						WriteCoord(TF_FLARE_OFF, te.origin_y);
						WriteCoord(TF_FLARE_OFF, te.origin_z + 5);
						dremove(tl);
					}
				}
			}
		}
		te = find(te, classname, "player");
	}
	te = find(world, classname, "building_sentrygun");
	while (te)
	{
		if (self != te)
		{
			if (te.team_no != TF_FLARE_LIT)
			{
				if (te.health > TF_FLARE_OFF)
				{
					if (visible(te))
					{
						msg_entity = self;
						tl = spawn();
						tl.owner = self;
						tl.origin = te.origin;
						tl.origin_z = tl.origin_z + 32;
						WriteByte(TF_FLARE_OFF, 23);
						WriteByte(TF_FLARE_OFF, 9);
						WriteEntity(TF_FLARE_OFF, tl);
						WriteCoord(TF_FLARE_OFF, tl.origin_x);
						WriteCoord(TF_FLARE_OFF, tl.origin_y);
						WriteCoord(TF_FLARE_OFF, tl.origin_z);
						WriteCoord(TF_FLARE_OFF, te.origin_x);
						WriteCoord(TF_FLARE_OFF, te.origin_y);
						WriteCoord(TF_FLARE_OFF, te.origin_z + 5);
						dremove(tl);
					}
				}
			}
		}
		te = find(te, classname, "building_sentrygun");
	}
	te = find(world, classname, "bot");
	while (te)
	{
		if (self != te)
		{
			if (te.team_no != TF_FLARE_LIT)
			{
				if (te.health > TF_FLARE_OFF)
				{
					if (visible(te))
					{
						msg_entity = self;
						tl = spawn();
						tl.owner = self;
						tl.origin = te.origin;
						tl.origin_z = tl.origin_z + 32;
						WriteByte(TF_FLARE_OFF, 23);
						WriteByte(TF_FLARE_OFF, 9);
						WriteEntity(TF_FLARE_OFF, tl);
						WriteCoord(TF_FLARE_OFF, tl.origin_x);
						WriteCoord(TF_FLARE_OFF, tl.origin_y);
						WriteCoord(TF_FLARE_OFF, tl.origin_z);
						WriteCoord(TF_FLARE_OFF, te.origin_x);
						WriteCoord(TF_FLARE_OFF, te.origin_y);
						WriteCoord(TF_FLARE_OFF, te.origin_z + 5);
						dremove(tl);
					}
				}
			}
		}
		te = find(te, classname, "bot");
	}
};
void() ambient_suck_wind = 
{
	suckwind = suckwind + 1;
	if (suckwind > 4)
		dremove(self);
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	precache_sound2 ("ambience/suck1.wav");
	ambientsound(self.origin, "ambience/suck1.wav", TF_FLARE_OFF, 3);
};
void() ambient_drip = 
{
	dripsnd += 1;
	if (dripsnd > 3)
		dremove(self);
	if (CheckExistence() == TF_FLARE_LIT)
	{
		dremove(self);
		return;
	}
	if (!(self.volume))
	{
		self.volume = TF_FLARE_OFF;
	}
	precache_sound2 ("ambience/drip1.wav");
	ambientsound(self.origin, "ambience/drip1.wav", self.volume, 3);
};
void() SUB_Null =
{};
void() SUB_RemoveClearGround =
{
	if(self.flags & FL_ONGROUND)
	while(turret_clearGround(self))
{}
	remove (self);
};
void() InitTrigger =
{
	if (self.angles != '0 0 0')
	{
		SetMovedir();
	}
	self.solid = SOLID_TRIGGER;
	setmodel (self, self.model); // set size and link into world
	self.movetype = MOVETYPE_NONE;
	self.modelindex = 0;
	self.model = "";
};
void (entity ent, vector tdest, float tspeed, void() func) SUB_CalcMoveEnt =
{
	local entity stemp;
	stemp = self;
	self = ent;
	SUB_CalcMove (tdest, tspeed, func);
	self = stemp;
};
void() SUB_CalcMoveDone =
{
	setorigin (self, self.finaldest);
	self.velocity = '0 0 0';
	self.nextthink = -1;
	if (self.think1)
	{
		self.think1();
	}
};
void (entity ent, vector destangle, float tspeed, void() func) SUB_CalcAngleMoveEnt =
{
	local entity stemp;
	stemp = self;
	self = ent;
	SUB_CalcAngleMove (destangle, tspeed, func);
	self = stemp;
};
void (vector destangle, float tspeed, void() func) SUB_CalcAngleMove =
{
	local vector destdelta;
	local float len, traveltime;
	if (!tspeed)
	{
		objerror ("No speed is defined!");
	}
	destdelta = destangle - self.angles;
	len = vlen (destdelta);
	traveltime = len / tspeed;
	self.nextthink = self.ltime + traveltime;
	self.avelocity = destdelta * (1 / traveltime);
	self.think1 = func;
	self.finalangle = destangle;
	self.think = SUB_CalcAngleMoveDone;
};
void() SUB_CalcAngleMoveDone =
{
	self.angles = self.finalangle;
	self.avelocity = '0 0 0';
	self.nextthink = -1;
	if (self.think1)
	{
		self.think1();
	}
};
void() DelayThink =
{
	activator = self.enemy;
	SUB_UseTargets();
	remove (self);
};
void() SUB_UseTargets =
{
	local entity t, stemp, otemp, act;
	if (self.delay)
	{
		t = spawn();
		t.classname = "DelayedUse";
		t.nextthink = time + self.delay;
		t.think = DelayThink;
		t.enemy = activator;
		t.message = self.message;
		t.killtarget = self.killtarget;
		t.target = self.target;
		return;
	}
	if (activator.classname == "player" && self.message != "")
	{
		centerprint (activator, self.message);
		if (!self.noise)
		{
			sound (activator, CHAN_VOICE, "misc/talk.wav", 1, ATTN_NORM);
		}
	}
	if (self.killtarget)
	{
		t = world;
		do
		{
			t = find (t, targetname, self.killtarget);
			if (!t)
				return;
			remove (t);
		}
		while (1);
	}
	if (self.target)
	{
		act = activator;
		t = world;
		do
		{
			t = find (t, targetname, self.target);
			if (!t)
				return;
			stemp = self;
			otemp = other;
			self = t;
			other = stemp;
			if (self.use != SUB_Null)
			{
				if (self.use)
				{
					self.use();
				}
			}
			self = stemp;
			other = otemp;
			activator = act;
		}
		while (1);
	}
};
float (entity mnst) Is_Monster =
{
	local string mname;
	mname = mnst.classname;
	if (mname == "monster_shambler")
		return 1;
	if (mname == "monster_zombie")
		return 1;
	if (mname == "monster_ogre")
		return 1;
	if (mname == "monster_knight")
		return 1;
	if (mname == "monster_demon1")
		return 1;
	if (mname == "monster_wizard")
		return 1;
	if (mname == "monster_tarbaby")
		return 1;
	if (mname == "monster_vomit")
		return 1;
	if (mname == "monster_enforcer")
		return 1;
	if (mname == "monster_dragon")	// um.. we got dragons in quake? ah well!
		return 1;
	if (mname == "monster_army")
		return 1;
	return 0;
};
void (void() thinkst) SUB_CheckRefire = 
{
	if (skill < 3)
	{
		return;
	}
	if (self.cnt == TF_FLARE_OFF)
	{
		return;
	}
	if (!visible(self.enemy))
	{
		return;
	}
	self.cnt = TF_FLARE_OFF;
	self.think = thinkst;
};
void() SUB_Remove = 
{
	dremove(self);
};
void() SetMovedir = 
{
	if (self.angles == '0 -1 0')
	{
		self.movedir = '0 0 1';
	}
	else
	{
		if (self.angles == '0 -2 0')
		{
			self.movedir = '0 0 -1';
		}
		else
		{
			makevectors(self.angles);
			self.movedir = v_forward;
		}
	}
	self.angles = '0 0 0';
};
void(vector tdest, float tspeed, void() func) SUB_CalcMove = 
{
	local vector vdestdelta;
	local float len;
	local float traveltime;
	if (!tspeed)
	{
		objerror("No speed is defined!");
	}
	self.think1 = func;
	self.finaldest = tdest;
	self.think = SUB_CalcMoveDone;
	if (tdest == self.origin)
	{
		self.velocity = '0 0 0';
		self.nextthink = self.ltime + 0.1;
		return;
	}
	vdestdelta = tdest - self.origin;
	len = vlen(vdestdelta);
	traveltime = len / tspeed;
	if (traveltime < 0.030000)
	{
		traveltime = 0.030000;
	}
	self.nextthink = self.ltime + traveltime;
	self.velocity = vdestdelta * (TF_FLARE_OFF / traveltime);
};
void(float normal) SUB_AttackFinished = 
{
	self.cnt = TF_FLARE_LIT;
	if (skill < 3)
	{
		self.attack_finished = time + normal;
	}
};
void (entity rank_ent) Rank_FindStats =
{
	local string rank;
	local string frgs;
	local string fers;
	local string dths;
	local float file;
	local string lin;
	local string h;
	local string filename;
	if (!rank_ent.netname || rank_ent.netname == "")
		return;
	filename = strcat(rank_ent.netname,".txt");
	filename = strzone(filename);
	file = fopen(filename, FILE_READ);
	if (file == -1)	// file not found -- lets make the player a new one!
	{
		fclose(file);
		rank_ent.global_rank = 0;
		rank_ent.global_frags = 0;
		rank_ent.global_fers = 0;
		rank_ent.global_dths = 0;
		file = fopen(filename, FILE_WRITE);
		fputs(file, "Rankings for player");
		fputs(file, "\n");
		h = ftos(0);
		fputs(file, h);
		fputs(file, "\n");
		h = ftos(0);
		fputs(file, h);
		fputs(file, "\n");
		h = ftos(0);
		fputs(file, h);
		fputs(file, "\n");
		h = ftos(0);
		fputs(file, h);
		fputs(file, "\n");
		fclose(file);
	}
	else
	{
		fclose(file);
		file = fopen(filename, FILE_READ);
		lin = fgets(file);	// This is the comment, skip it
		lin = fgets(file);	// this is the rank
		lin = strzone(lin);
		rank = lin;
		rank = strzone(rank);
		strunzone(lin);
		lin = fgets(file);	// this is the frag count
		lin = strzone(lin);
		frgs = lin;
		frgs = strzone(frgs);
		strunzone(lin);
		lin = fgets(file);	// this is the fer count
		lin = strzone(lin);
		fers = lin;
		fers = strzone(fers);
		strunzone(lin);
		lin = fgets(file);	// this is the death count
		lin = strzone(lin);
		dths = lin;
		dths = strzone(dths);
		strunzone(lin);
		fclose(file);
		rank_ent.global_rank = stof(rank);
		rank_ent.global_frags = stof(frgs);
		rank_ent.global_fers = stof(fers);
		rank_ent.global_dths = stof(dths);
		strunzone(rank);
		strunzone(frgs);
		strunzone(fers);
		strunzone(dths);
	}
	strunzone(filename);
};
void (entity rank_ent) Rank_UpdateStats =
{
	local float file;
	local string h;
	file = fopen(strcat(rank_ent.netname,".txt"), FILE_WRITE);
	fputs(file, strcat("Rankings for: ",rank_ent.netname," Rank -- Frags -- fers -- deaths :\n"));
	h = ftos(rank_ent.global_rank);
	h = strzone(h);
	fputs(file, h);
	fputs(file, "\n");
	strunzone(h);
	h = ftos(rank_ent.global_frags);
	h = strzone(h);
	fputs(file, h);
	fputs(file, "\n");
	strunzone(h);
	h = ftos(rank_ent.global_fers);
	h = strzone(h);
	fputs(file, h);
	fputs(file, "\n");
	strunzone(h);
	h = ftos(rank_ent.global_dths);
	h = strzone(h);
	fputs(file, h);
	fputs(file, "\n");
	strunzone(h);
	fclose(file);
};
void () Rank_UpdateStatsGlobal =
{
	if (Ranks_Updated == 1)
		return;
	Ranks_Updated = 1;
	local entity head;
	head = nextent(world);
	while (head != world)
	{
		if (head.classname == "player")
{ Rank_UpdateStats(head); }
		head = nextent(head); 
	}
};
void () Rank_ShowStats =
{
	sprint(self, 2, "Your ranks:\n");
	sprint(self, 2,"Rank: ");
	sprint(self, 2, ftos(self.global_rank));
	sprint(self, 2," Frags: ");
	sprint(self, 2, ftos(self.global_frags));
	sprint(self, 2," Fers: ");
	sprint(self, 2, ftos(self.global_fers));
	sprint(self, 2," Deaths: ");
	sprint(self, 2, ftos(self.global_dths));
	sprint(self, 2, "\n");
};
void (entity rank_ent, float addscore) Rank_AddRank =
{
	rank_ent.global_rank = rank_ent.global_rank + addscore;
	bprint(2, strcat(rank_ent.netname," has earned rank ",ftos(rank_ent.global_rank),"!\n"));
	Rank_UpdateStats(rank_ent);
};
void (entity rank_ent, float addscore) Rank_AddFrags =
{
	rank_ent.global_frags = rank_ent.global_frags + addscore;
	if (rank_ent.global_rank == 0 && rank_ent.global_frags >= RANK_ONE)
		Rank_AddRank(rank_ent, 1);
	else 
	if (rank_ent.global_rank == 1 && rank_ent.global_frags >= RANK_TWO)
		Rank_AddRank(rank_ent, 1);
	else
	if (rank_ent.global_rank == 2 && rank_ent.global_frags >= RANK_THREE)
		Rank_AddRank(rank_ent, 1);
	else
	if (rank_ent.global_rank == 3 && rank_ent.global_frags >= RANK_FOUR)
		Rank_AddRank(rank_ent, 1);
};
void (entity rank_ent, float addscore) Rank_AddFers =
{
	rank_ent.global_fers = rank_ent.global_fers + addscore;
};
void (entity rank_ent, float addscore) Rank_AddDeaths =
{
	rank_ent.global_dths = rank_ent.global_dths + addscore;
};
void (entity plyr, float addfrags) Rank_FragIncrease =
{
	local float file;
	local float flt;
	local string h;
	local string lin;
	local string lin2;
	local string frgs;
	file = fopen(strcat(self.netname,".txt"), FILE_READ);
	if (file == -1)	// file not found -- lets make the player a new one!
	{
		bprint(2," NOT FOUND \n");
		file = fopen(strcat(self.netname,".txt"), FILE_WRITE);
		fputs(file, strcat("Rankings for: ",self.netname," Rank -- Frags -- fers -- deaths :\n"));
		h = ftos(addfrags);
		fputs(file, h);
		fputs(file, "\n");
		fclose(file);
	}
	else
	{
		bprint(2,"FOUND \n");
		file = fopen(strcat(self.netname,".txt"), FILE_READ);
		lin = fgets(file);	// This is the comment, skip it
		lin = fgets(file);	// this is the rank
		lin = strzone(lin);
		frgs = lin;
		strunzone(lin);
		fclose(file);
		file = fopen(strcat(self.netname,".txt"), FILE_WRITE);
		fputs(file, strcat("Rankings for: ",self.netname," Rank -- Frags -- fers -- deaths :\n"));
		flt = stof(frgs) + addfrags;
		lin2 = ftos (flt);
		fputs(file, lin2);
		fputs(file, "\n");
		fclose(file);
	}
};
void () missing_precaches =
{
	precache_model ("progs/medexp.spr");
	precache_sound2 ("items/inv1.wav");
	precache_sound2 ("items/inv2.wav");
	precache_sound2("wall/push.wav");
	precache_model2("progs/ammobox2.mdl");
	precache_sound2 ("items/inv3.wav");
	precache_model2("progs/proxbomb.mdl");
	precache_model2("progs/s_splava.spr");
	precache_sound2 ("items/protect.wav");
	
};
void() beartrapDie =
{
	local float numOfGibs;
	beartrap_throwGib ("progs/beargib1.mdl", -50);
	beartrap_throwGib ("progs/beargib2.mdl", -50);
	beartrap_throwGib ("progs/beargib3.mdl", -50);
	numOfGibs = random() * 5;
	local float dam;
	while (numOfGibs > 0)
	{
		dam = random() * -50;
		beartrap_throwGib ("progs/beargib4.mdl", dam);
		numOfGibs = numOfGibs - 1;
	}
	sound (self, CHAN_AUTO, "weapons/btrap/btrap_3.wav", 1, ATTN_NORM);
	remove (self);
};
$frame bear01 bear02 bear03
void (string gibname, float dm) beartrap_throwGib =
{
	local entity new;
	new = spawn();
	new.origin = self.origin;
	setmodel (new, gibname);
	setsize (new, '0 0 0', '0 0 0');
	new.pk_currentitem = PK_IT_BEARTRAP; // Doc changed == to =
	new.velocity = VelocityForDamage (dm);
	new.movetype = MOVETYPE_BOUNCE;
	new.solid = SOLID_NOT;
	new.avelocity_x = random() * 600;
	new.avelocity_y = random() * 600;
	new.avelocity_z = random() * 600;
	new.think = SUB_Remove;
	new.ltime = time;
	new.nextthink = time + 3;
	new.frame = 0;
	new.flags = 0;
	new.classname = "beartrap_gib";
	new.team_no = other.team_no; // Just to be anal, it's their beartrap now.
	new.owner = other.owner; 
	new.think = SUB_Remove;
	AddToSplash (new);
};
void() beartrapFollow =
{
	if (!(self.beartrap_target.beartrap_time) || self.disconnectPlayer || self.beartrap_target.deadflag)
	{
		remove (self);
		return;
	}
	if (self.origin != self.beartrap_target.origin || self.angles != self.owner.angles)
	{
		setorigin (self, self.beartrap_target.origin);
		self.dodmg = 1;
		if (self.angles != self.owner.angles)
			self.angles = self.owner.angles;
	}
	self.beartrap_time = self.beartrap_time + 0.1;
	self.beartrapdmg_time = self.beartrapdmg_time + 0.1;
	if (self.beartrapdmg_time >= 0.5)
	{
		if (self.dodmg)
		{
		deathmsg = 202; // Set death type for obituary. -arg
		T_Damage (self.beartrap_target, self, self.owner, PK_BT_DMG);
		self.dodmg = 0;
		}
		self.beartrapdmg_time = 0;
	}
	if (self.beartrap_time > PK_BT_TIMETOFOLLOW)
		self.think = beartrapDie;
};
void() btf =
{
	beartrapFollow();

	self.nextthink = time + 0.1;
};
void() btf_1 = [ $bear02, btf_2 ]
{
	beartrapFollow();
};
void() btf_2 = [ $bear03, btf ]
{
	setmodel (self, "progs/bearbld.mdl");
};
void() beartrapTouch =
{
	if ((other == self.owner) && (self.beartrap_time > time))
		return;
	if (other.bt_immune_time > time)
		return;
	if ((other.team_no == self.owner.team_no) && (self.owner.team_no != TF_FLARE_LIT))
	{
		return ;   //don't clamp things on the same team. includes minions
	}
if (other.takedamage)
	{
	other.beartrap_time = 1; 									// SWP: 14/05/97
	self.beartrap_target = other;  // was = other  Now it's the player who stepped on it ? -arg
	self.beartrap_time = 0;
	self.beartrapdmg_time = 0;
	self.think = btf_1;
	self.nextthink = time + 0.1;
	self.touch = SUB_Null;
	deathmsg = 202; // Set death type for obituary. -arg
	sound (self, CHAN_AUTO, "weapons/btrap/btrap_1.wav", 1, ATTN_NORM);
	}
};
void() beartrap_dropBearTrap =
{
	if (self.pk_beartrapammo <= 0)
	{
		return;
	}
	self.pk_beartrapammo = self.pk_beartrapammo - 1;
	bt = spawn();
	bt.owner = self;
	bt.movetype = MOVETYPE_TOSS;
	bt.solid = SOLID_TRIGGER;
	bt.classname = "beartrap";
	bt.takedamage = 1; //2 is self, you can't shoot it dead or off you.
	bt.health = 50; // was 50, testing to make it harder to rjump them off of player SH*
	bt.th_die = beartrapDie;
	bt.netname = "Bear Trap";
	bt.team_no = self.team_no; // set the beartrap team number same the players.
	bt.pk_currentitem = PK_IT_BEARTRAP;
	bt.beartrap_time = time + 1.6; 																									// was 3  SH* Grace period
	bt.think = beartrapDie;
	bt.nextthink = time + 90; //changed from 360 -arg
	setmodel (bt, "progs/beartrap.mdl");
	setsize (bt, '-16 -16 -0', '16 16 8');
	makevectors (self.angles);
	setorigin (bt, self.origin + self.view_ofs + v_forward * 12); // trap needs to start a little higher and a bit infront of player
	makevectors (self.v_angle);
	bt.velocity = aim (self, 800);
	bt.velocity = bt.velocity * (700 + random() * 20) + '0 0 200';
	bt.angles_y = vectoyaw (bt.velocity); // orient the trap in the direction of flight.
	bt.touch = beartrapTouch;
	deathmsg = 202; // Set death type for obituary. -arg
	sound (self, CHAN_AUTO, "weapons/btrap/bdrop_1.wav", 1, ATTN_NORM);
	//AddToSplash (bt);
	if (pointcontents(self.origin) == #CONTENT_SKY)  // If it touches the sky or gets stuck there, remove it. Borrowed code from weapons.qc Fusion_Touch - arg 11/2013
	{
		remove(self);
		return;
	}
};
void() BTF_Precache =
{
	if (BTF_Cached != 1)
	{
		precache_model("progs/bullet.mdl");
		precache_sound ("helo/achit.wav");
		precache_sound ("helo/acpain1.wav");
		precache_sound ("helo/acpain2.wav");
		precache_sound ("helo/acpain3.wav");
		precache_sound ("helo/voice1.wav");
		precache_sound ("helo/voice2.wav");
		precache_sound ("helo/voice3.wav");
		precache_sound ("helo/voice4.wav");
		precache_sound ("helo/fuellow.wav");
		precache_sound ("helo/eject2.wav");
		precache_sound ("engines/chopper.wav");
		precache_sound ("weapons/ffar2.wav");
		precache_sound2 ("weapons/gat2.wav");
		precache_sound2 ("weapons/bombdrop.wav");
		precache_sound ("misc/metal2.wav");
		precache_model("progs/cockpit.mdl");
		precache_model("progs/ffar.mdl");
		precache_model2 ("progs/acgib1.mdl");  // These were already being precached with model2 in weapons.pqc -arg
		precache_model2 ("progs/acgib2.mdl");
		precache_model2 ("progs/acgib3.mdl");
		precache_model2 ("progs/acgib4.mdl");
		precache_model2 ("progs/acgib5.mdl");
		precache_model2 ("progs/acgib6.mdl");
		precache_model2 ("progs/acgib7.mdl");
		precache_model2 ("progs/acgib8.mdl");
		precache_model2 ("progs/bomb.mdl");
		precache_model2 ("progs/rocket2.mdl");
		precache_model2 ("progs/torpedo.mdl");
		precache_model2 ("progs/subpit.mdl");
		precache_model2 ("progs/sight.mdl");
		precache_sound ("sub/throttle.wav");
		precache_sound ("sub/ping.wav");
		precache_sound ("damage/subpain.wav");
		precache_sound ("utils/hoveron.wav");
		precache_sound ("weapons/torpedo.wav");
		precache_sound ("sub/locked.wav");
		precache_sound ("sub/lockon.wav");
		BTF_Cached = 1;
	}
};
float ( float pclass ) COOP_GetMaxGrensForClass =
{
	float rtrn;
rtrn = ((self.ammo_attr + 1) * 3);  // 6 times the attribute for ammo is the number of grens you get.
self.no_grenades_1 = rtrn;
self.no_grenades_2 = rtrn;
	return (rtrn);
};
string (float anum) Achievements_GetName =
{
	switch(anum)
	{
		case ACHIEVEMENT_BLADERUNNER:
			return "Blade Runner";
			break;
		case ACHIEVEMENT_HEAVYMETAL:
			return "Heavy Metal";
			break;
		case ACHIEVEMENT_LOOTBAGGER:
			return "Loot Bagger";
			break;
		case ACHIEVEMENT_BIGCANNON:
			return "Assault Junkie";
			break;
		case ACHIEVEMENT_COMPLETIONIST:
			return "Completionist";
			break;
		case ACHIEVEMENT_FLAWLESS:
			return "Flawless Junkie";
			break;
		case ACHIEVEMENT_ATOMICPUNK:
			return "Atomic Punk";
			break;
		case ACHIEVEMENT_KILLINGMACHINE:
			return "Killing Machine";
			break;
		case ACHIEVEMENT_HEADSHOT:
			return "Boom Headshot";
			break;
		case ACHIEVEMENT_BAT:
			return "Boink!";
			break;
		case ACHIEVEMENT_HEAL:
			return "Mr. Medkit";
			break;
		case ACHIEVEMENT_REPAIR:
			return "Mr. Fixit";
			break;
		case ACHIEVEMENT_RESURRECT:
			return "Helping Hand";
			break;
		case ACHIEVEMENT_LMS:
			return "Last Man Standing";
			break;
		case ACHIEVEMENT_SHAMBLER:
			return "Shambler Medic";
			break;
		case ACHIEVEMENT_MULTI:
			return "Combo Meal";
			break;
		case ACHIEVEMENT_MRGRINCH:
			return "Mr. Grinch";
			break;
		case ACHIEVEMENT_EPISODE1:
			return "Shareware Hippie (E1)";
			break;
		case ACHIEVEMENT_EPISODE2:
			return "Black Magic Woman (E2)";
			break;
		case ACHIEVEMENT_EPISODE3:
			return "Off To Never-Netherworld (E3)";
			break;
		case ACHIEVEMENT_EPISODE4:
			return "Fantastic Four (E4)";
			break;
		case ACHIEVEMENT_HELPER:
			return "Santa's Little Helper";
			break;
		case ACHIEVEMENT_JUGGLER:
			return "Court Bard";
			break;
		case ACHIEVEMENT_LEVELTWENTY:
			return "Master of Quake";
			break;
		case ACHIEVEMENT_GAMBLER:
			return "Gamblin' Man";
			break;
		case ACHIEVEMENT_TREASURE:
			return "Treasure Hunter (wolf3d)";
			break;
		case ACHIEVEMENT_SPEEDY:
			return "Speed Runner";
			break;
		case ACHIEVEMENT_RECORD:
			return "Record Setter";
			break;
		default:
			return "noname";
			break;
	}
	return "noname";
};
float (float anum) Achievements_CheckComplete =
{
	switch(anum)
	{
		case ACHIEVEMENT_BLADERUNNER:
			return 2000;
			break;
		case ACHIEVEMENT_HEAVYMETAL:
			return 500;
			break;
		case ACHIEVEMENT_LOOTBAGGER:
			return 50;
			break;
		case ACHIEVEMENT_BIGCANNON:
			return 1000;
			break;
		case ACHIEVEMENT_COMPLETIONIST:
			return 500;
			break;
		case ACHIEVEMENT_FLAWLESS:
			return 100;
			break;
		case ACHIEVEMENT_ATOMICPUNK:
			return 2500;
			break;
		case ACHIEVEMENT_KILLINGMACHINE:
			return 50000;
			break;
		case ACHIEVEMENT_HEADSHOT:
			return 2500;
			break;
		case ACHIEVEMENT_BAT:
			return 1500;
			break;
		case ACHIEVEMENT_HEAL:
			return 2500;
			break;
		case ACHIEVEMENT_REPAIR:
			return 2000;
			break;
		case ACHIEVEMENT_RESURRECT:
			return 5000;
			break;
		case ACHIEVEMENT_LMS:
			return 100;
			break;
		case ACHIEVEMENT_SHAMBLER:
			return 2000;
			break;
		case ACHIEVEMENT_MULTI:
			return 2500;
			break;
		case ACHIEVEMENT_MRGRINCH:
			return 200;
			break;
		case ACHIEVEMENT_EPISODE1:
			return 127;
			break;
		case ACHIEVEMENT_EPISODE2:
			return 127;
			break;
		case ACHIEVEMENT_EPISODE3:
			return 127;
			break;
		case ACHIEVEMENT_EPISODE4:
			return 127;
			break;
		case ACHIEVEMENT_HELPER:
			return 2000;
			break;
		case ACHIEVEMENT_JUGGLER:
			return 700;
			break;
		case ACHIEVEMENT_LEVELTWENTY:
			return 80;
			break;
		case ACHIEVEMENT_GAMBLER:
			return 100;
			break;
		case ACHIEVEMENT_TREASURE:
			return 511;
			break;
		case ACHIEVEMENT_SPEEDY:
			return 100;
			break;
		case ACHIEVEMENT_RECORD:
			return 100;
			break;
		default:
			return 50000;			// some insane amount.. because something is wack
			break;
	}
	return 5000;
};
float ( float anum ) Achievements_GetExp =
{
	switch(anum)
	{
		case ACHIEVEMENT_BLADERUNNER:
			return 2500;
			break;
		case ACHIEVEMENT_HEAVYMETAL:
			return 4000;
			break;
		case ACHIEVEMENT_LOOTBAGGER:
			return 7500;
			break;
		case ACHIEVEMENT_BIGCANNON:
			return 1000;
			break;
		case ACHIEVEMENT_COMPLETIONIST:
			return 2500;
			break;
		case ACHIEVEMENT_FLAWLESS:
			return 7500;
			break;
		case ACHIEVEMENT_ATOMICPUNK:
			return 2500;
			break;
		case ACHIEVEMENT_KILLINGMACHINE:
			return 10000;
			break;
		case ACHIEVEMENT_HEADSHOT:
			return 3000;
			break;
		case ACHIEVEMENT_BAT:
			return 2750;
			break;
		case ACHIEVEMENT_HEAL:
			return 4000;
			break;
		case ACHIEVEMENT_REPAIR:
			return 3050;
			break;
		case ACHIEVEMENT_RESURRECT:
			return 8500;
			break;
		case ACHIEVEMENT_LMS:
			return 4500;
			break;
		case ACHIEVEMENT_SHAMBLER:
			return 6500;
			break;
		case ACHIEVEMENT_MULTI:
			return 4750;
			break;
		case ACHIEVEMENT_MRGRINCH:
			return 1987;
			break;
		case ACHIEVEMENT_EPISODE1:
			return 5500;
			break;
		case ACHIEVEMENT_EPISODE2:
			return 6500;
			break;
		case ACHIEVEMENT_EPISODE3:
			return 7000;
			break;
		case ACHIEVEMENT_EPISODE4:
			return 7500;
			break;
		case ACHIEVEMENT_HELPER:
			return 7000;
			break;
		case ACHIEVEMENT_JUGGLER:
			return 4500;
			break;
		case ACHIEVEMENT_LEVELTWENTY:
			return 666;
			break;
		case ACHIEVEMENT_GAMBLER:
			return 10000;
			break;
		case ACHIEVEMENT_TREASURE:
			return 15000;
			break;
		case ACHIEVEMENT_SPEEDY:
			return 7500;
			break;
		case ACHIEVEMENT_RECORD:
			return 14000;
			break;
		default:
			return 2500;
			break;
	}
	return 2500;
};
float (entity t_plyr) Achievements_Setup =
{
	local string a;
	local string filenamee, oopsname;
	local float filee;
	local float i;
	local string tstr;
	if ( t_plyr.connect_name == "" || !t_plyr.connect_name )
	{
		return ( -1 );
	}
	filenamee = frik_strcat( "ranks/inv/", t_plyr.connect_name, "_awd.tfi" );
	filenamee = strzone(filenamee);
	if ( invalid_exp_name(filenamee) == 1 )
	{
		strunzone(filenamee);
		return ( -1 );
	}
	achievements_enabled = #TRUE;
	if ( checkfilename(filenamee) != 1 )
	{	// done in C - makes sure the file name is writable
		strunzone(filenamee);
		if (checkfilename( "ranks/inv/test" ) == #FALSE)
			achievements_enabled = #FALSE;
			bprint( 2, "WARNING: Folder /inv cannot be found! Server admin needs to create /fortress/ranks/inv/ folder!\n" );
		return ( -1 );
	}
	oopsname = frik_strcat( "ranks/inv/", self.connect_name, "_awd.tfi" );
	oopsname = strzone(oopsname);
	if (filenamee != oopsname || self.has_disconnected == 1)
	{
		bprint(2, "!!!!!!!!!!!!! AWARDS BUG ERROR IN READ!!! filenamee IS NOT THE SAME AS CONNECT NAME !!!!!!!!!!!!! \n");
		bprint(2, "CNAME: ");
		bprint(2, self.connect_name);
		bprint(2, " filenamee: ");
		bprint(2, filenamee);
		bprint(2, " oopsname: ");
		bprint(2, oopsname);
		bprint(2,"\n");
		strunzone(filenamee);
		strunzone(oopsname);
		return ( -1 );
	}
	strunzone(oopsname);
	filee = open (filenamee, 0);
	a = read (filee);	// lets see if the awards file exists for the player..
	if (!a)		// nope!
	{
		close(filee);
		filee = open (filenamee, 2);
		write (filee, "// MegaTF Coop awards and achievements Team Fortress Information file\n");
		write (filee, "// The three fields explained:\n");
		write (filee, "// First line is achievement name\n// Second line is player's progress in earning the achievement\n// Third line is how many of that achievement the player has\n");
		write (filee, "// ADDME: use this line for something?\n");
		while (i < MAXLINES_ACHIEVEMENTS + #FIRST_AWD_LINE)
		{
			tstr = Achievements_GetName(i);
			if (tstr == "noname")
				write (filee, "0\n");
			else
			if (tstr == "endname")
				break;
			else
			{
				write (filee, tstr);
				write (filee, "\n");
			}
			i++;
		}
		close (filee);
		strunzone(filenamee);
		return ( 0 );
	}
	close (filee);
	strunzone(filenamee);
	return #TRUE;
};
void ( float p_type, entity t_plyr ) Achievements_Print =
{
	local float file, i, infa, infb;
	if (!t_plyr.connect_name)
		return;
	if (t_plyr.coop_exp == -1)
		return;
	if (p_type == 0)
		sprint(self, 2, "Your achievements:\n");
	else
	if (p_type == 1)
	{
		stuffcmd(self, "say \"My achievements\n");
	}
	else
	if (p_type == 2)
		sprint(self, 2, "Your achievements (detailed):\n");
	i = 1;
	file = open (frik_strcat( "ranks/inv/", t_plyr.connect_name, "_awd.tfi" ), 0);
	while ( i < (#MAXLINES_ACHIEVEMENTS + #FIRST_AWD_LINE + 1) )
	{
		if (i >= #FIRST_AWD_LINE)
		{
			if (Achievements_GetName(i - #FIRST_AWD_LINE) != "noname")
			{
				read(file);
				infa = stof( read(file) );
				infb = stof( read(file) );
				if (infb > 0)
				{
					if (p_type == 0)
					{
						sprint(self, 2, Achievements_GetName(i - #FIRST_AWD_LINE));
						sprint(self, 2, "(" );
						sprint(self, 2, ftos(infb));
						sprint(self, 2, ")\n");
					}
					else
					if (p_type == 1)
					{
						bprint(2, Achievements_GetName(i - #FIRST_AWD_LINE));
						bprint(2, "(" );
						bprint(2, ftos(infb));
						bprint(2, ") ");
					}
				}
				if (p_type == 2)
				{
					sprint(self, 2, Achievements_GetName(i - #FIRST_AWD_LINE));
					sprint(self, 2, "(" );
					sprint(self, 2, ftos(infb));
					sprint(self, 2, ") - your progress: ");
					sprint(self, 2, ftos(infa));
					sprint(self, 2, " of ");
					sprint(self, 2, ftos(Achievements_CheckComplete(i - #FIRST_AWD_LINE)));
					sprint(self, 2, ".\n");
				}
				
				i = i+2;
			}
			else
				read(file);
		}
		else
			read(file);
		i++;
	}
	close(file);
	
	if (p_type == 1)
		bprint(2, "\n");
};
void () Achievements_Set =
{
	local entity t_plyr, t_other, oself;
	local float s_type, a_type, a_var;
	local float new_achievement;
	local string a;
	local float ach_total;			// total achievement points, and also used for total times an achievement has been earned
	local float file, dummyfile;
	local float i;
	i=1;
	oself = self;
	t_plyr = self.owner;
	t_other = self.enemy;
	s_type = self.health;
	a_type = self.ammo_shells;
	a_var = self.armorvalue;
	if (t_plyr.coop_exp != -1 && t_plyr != other && t_plyr.has_disconnected != 1)
	{
	}
	else
	{
		bprint(2, "Achievements_Set: Tried to set on world or disconnected player or something\n");
		dremove(self);
		return;
	}
	file = open (frik_strcat( "ranks/inv/", t_plyr.connect_name, "_awd.tfi" ), 0);
	dummyfile = open ("dummy_awd.tfi", 2);
	while ( i < (#MAXLINES_ACHIEVEMENTS + #FIRST_AWD_LINE + 1) )
	{
		if (i == (#FIRST_AWD_LINE + a_type))
		{
			write( dummyfile, Achievements_GetName(a_type) );
			write( dummyfile, "\n" );
			read(file);
		}
		else
		if (i == (#FIRST_AWD_LINE + a_type + 1))
		{
			a = read(file);
			if (s_type == ACHIEVEMENTS_ADD)
			{
				ach_total = stof(a) + a_var;
				if (ach_total < 0)		// since you can add negatives
					ach_total = 0;
			}
			else
			if (s_type == ACHIEVEMENTS_ADDBIT)
			{
				ach_total = stof(a);
				if ((!ach_total) & (a_var))
					ach_total += a_var;
				if (ach_total < 0)		// since you can add negatives
					ach_total = 0;
			}
			else
			if (s_type == ACHIEVEMENTS_SET)
			{
					ach_total = a_var;
			}
			else
				ach_total = 0;
			if (Achievements_CheckComplete(a_type) <= ach_total)
			{
				bprint(2, "Achievement earned! ");
				bprint(2, t_plyr.connect_name);
				bprint(2, " has earned the achievement: ");
				bprint(2, Achievements_GetName(a_type) );
				bprint(2, "\n");
				ach_total = 0;
				new_achievement = 1;
				write( dummyfile, ftos( ach_total ) );
				write( dummyfile, "\n" );
				a = read(file);
				ach_total = stof(a) + 1;
				write( dummyfile, ftos( ach_total ) );
				write( dummyfile, "\n" );
				i++;
			}
			else
			{
				write( dummyfile, ftos( ach_total ) );
				write( dummyfile, "\n" );
			}
		}
		else
		{
			write( dummyfile, read(file) );
			write( dummyfile, "\n" );
		}
		i++;
	}
	close ( dummyfile );
	close (file);
	CopyFile( "dummy_awd.tfi", frik_strcat( "ranks/inv/", t_plyr.connect_name, "_awd.tfi" ), 0, string_null, #MAXLINES_ACHIEVEMENTS + #FIRST_AWD_LINE);
	if (new_achievement)
		MTF_Coop_AddServiceExp( t_plyr, world, Achievements_GetExp(a_type), #SRV_ACHIEVEMENT );
	dremove(self);
};
void ( entity t_plyr, entity t_other, float s_type, float a_type, float a_var ) Achievements_Change =
{
	local entity ach_ent, te;
	if (achievements_enabled == #FALSE)
		return;
	if (s_type == ACHIEVEMENTS_GLOBALADD)
	{			// add to every player in the game (used for flawless, completionist, lms, etc.)
		te = find ( world, classname, "player" );
		while (te)
		{
			if (te.coop_exp != -1 && te.has_disconnected != 1)
			{
				Achievements_Change( te, world, ACHIEVEMENTS_ADD, a_type, a_var );
			}
			te = find (te, classname, "player");
		}	
		return;
	}
	if (t_plyr == world && t_other == world)
		return;
	if (t_plyr.coop_exp == -1)
		return;
	ach_ent = spawn();
	ach_ent.owner = t_plyr;
	ach_ent.enemy = t_other;
	ach_ent.health = s_type;
	ach_ent.ammo_shells = a_type;
	ach_ent.armorvalue = a_var;
	ach_ent.think = Achievements_Set;
	ach_ent.nextthink = time + .6 + random();
};
float (string mpn) GetEP1MapBit = 
{
	if (mpn  == "e1m1")
		return 1;
	else
	if (mpn  == "e1m2")
		return 2;
	else
	if (mpn  == "e1m3")
		return 4;
	else
	if (mpn  == "e1m4")
		return 8;
	else
	if (mpn  == "e1m5")
		return 16;
	else
	if (mpn  == "e1m6")
		return 32;
	else
	if (mpn  == "e1m8")			// meh, forget e1m7 :D
		return 64;
		
	return -1;
};
float (string mpn) GetEP2MapBit = 
{
	if (mpn  == "e2m1")
		return 1;
	else
	if (mpn  == "e2m2")
		return 2;
	else
	if (mpn  == "e2m3")
		return 4;
	else
	if (mpn  == "e2m4")
		return 8;
	else
	if (mpn  == "e2m5")
		return 16;
	else
	if (mpn  == "e2m6")
		return 32;
	else
	if (mpn  == "e2m7")
		return 64;
	return -1;
};
float (string mpn) GetEP3MapBit = 
{
	if (mpn  == "e3m1")
		return 1;
	else
	if (mpn  == "e3m2")
		return 2;
	else
	if (mpn  == "e3m3")
		return 4;
	else
	if (mpn  == "e3m4")
		return 8;
	else
	if (mpn  == "e3m5")
		return 16;
	else
	if (mpn  == "e3m6")
		return 32;
	else
	if (mpn  == "e3m7")
		return 64;
	return -1;
};
float (string mpn) GetEP4MapBit = 
{
	if (mpn  == "e4m1")
		return 1;
	else
	if (mpn  == "e4m2")
		return 2;
	else
	if (mpn  == "e4m3")
		return 4;
	else
	if (mpn  == "e4m4")
		return 8;
	else
	if (mpn  == "e4m5")
		return 16;
	else
	if (mpn  == "e4m6")
		return 32;
	else
	if (mpn  == "e4m7")
		return 64;
	return -1;
};
float (string mpn) GetW3DMapBit = 
{
	if (mpn  == "e1f1")
		return 1;
	else
	if (mpn  == "e1f2")
		return 2;
	else
	if (mpn  == "e1f3")
		return 4;
	else
	if (mpn  == "e1f4")
		return 8;
	else
	if (mpn  == "e1f5")
		return 16;
	else
	if (mpn  == "e1f6")
		return 32;
	else
	if (mpn  == "e1f7")
		return 64;
	else
	if (mpn  == "e1f8")
		return 128;
	else
	if (mpn  == "e1f9")
		return 256;
	return -1;
};
void (entity plyr, float amnt, float rcrd) Record_Check =
{
	if (plyr.classname != "player")
		return;
	if (rcrd == #RECORD_FER)
	{
		if (!record_fer)
			return;
		if (amnt > record_fer)
		{
			bprint(2, "NEW RECORD! ");
			bprint(2, plyr.netname);
			bprint(2, " has BROKEN the last FER record of ");
			bprint(2, ftos(record_fer));
			bprint(2, " by getting a ");
			bprint(2, ftos(amnt));
			bprint(2, "fer!\n");
			Record_Add(#RECORD_FER, amnt, plyr);
		}
	}
	else
	if (rcrd == #RECORD_FRAGS)
	{
		if (!record_frags)
			return;
		if (amnt > record_frags)
		{
			if (record_fragholder != plyr.netname)
			{
				bprint(2, "New RECORD! ");
				bprint(2, plyr.netname);
				bprint(2, " has BROKEN the last FRAG record of ");
				bprint(2, ftos(record_frags));
				bprint(2, " by getting a frag score of ");
				bprint(2, ftos(amnt));
				bprint(2, " frags!\n");
				record_fragholder = plyr.netname;
				sound (self, 4, "misc/secret.wav", 1, 0);
			}
			Record_Add(#RECORD_FRAGS, amnt, plyr);
		}
	}
};
void (float rcrd, float amnt, entity plyr) Record_Add =
{
	if (rcrd == #RECORD_FER)
		{
		localcmd("localinfo r_fer ");
		}
	else
	 if (rcrd == #RECORD_FRAGS)
		{
		localcmd("localinfo r_frags ");
		}
	else
	if (rcrd == #RECORD_DEATHS)
	{
	localcmd("localinfo r_deaths ");
	}
	else
	if (rcrd == #RECORD_CAPS)
	{
	localcmd("localinfo r_caps ");
	localcmd(ftos(amnt));
	localcmd("\n");
	}
	if (rcrd == #RECORD_FER)
	{
		record_fer = amnt;
	}
	else
 if (rcrd == #RECORD_FRAGS)
	{
		record_frags = amnt;
	}
};
void ( entity to_summon ) BeginSummon =
{
	local entity newmon, goalie;
	if (self.health <= 0 || self.has_disconnected == 1)
		return;
	to_summon.#is_summoned = #TRUE;
	newmon = spawn();
	newmon.#is_minion = #TRUE;
	SetSpawnFunc ( newmon, to_summon.classname );
	self.#minions += 1;
	newmon.owner = self;
	newmon.origin = to_summon.origin + '0 0 25';
	newmon.nextthink = time + 1;
	newmon.think = summon_respawn_think;
	newmon.lives = -1;
	newmon.team_no = self.team_no; //Same team number as summoner -arg
	newmon.monster_string = "false";		// not "off".. so we can't re-resurrect 
	newmon.is_monster = 1;
	newmon.effects = #EF_GREEN; // color the summoned monsters green to easily spot them for Fortress One, older clients.
	goalie = spawn();
	goalie.classname = "monster_goalie";
	goalie.owner = newmon;
	goalie.real_owner = self;
	goalie.health = 30 + ( 7 * self.minion_attr );		// max time a minion can stay alive was 12+ -arg
	goalie.max_health = self.minion_attr * 180;		// max minion health was 90 -arg
	goalie.armorvalue = time + goalie.health;
	goalie.think = summon_think;
	goalie.nextthink = time + .1;
	goalie.team_no = self.team_no; //Set the same team number as summoner -arg
//TODO: reset team number as the user changes teams for frag count and targeting.
//Currently the summoned won't target you even if you change to red team. :}
	goalie.touch = Coop_MinionMonsterTouch;
	setmodel (goalie, "progs/thedot.spr");
	goalie.frame = self.team_no - 1;  
	sprint( self, 2, "You are attempting to summon a minion...\n" );
	self.#allow_next_summon_time = (time + 5) - self.minion_attr; // was 18 but we need armies of summons to fight within multi-team mode. -arg
};
void () MTF_Coop_SummonMinion =
{
	local entity te, tgood;
	local float maxminions, bestdist;
	if (self.health <= 0 || self.playerclass == 0)
		return;
	if (self.#allow_next_summon_time > time)
	{
		sprint( self, 2, "It's too soon to summon another minion.\n" );
		return;
	}
	maxminions = ceil(self.minion_attr * .7); // was .34 -arg
	if (self.#minions >= maxminions)
	{
		sprint(self, 2, "You need more minion attributes to summon more minions.\n");
		return;
	}
	bestdist = 450;
	te = findradius(self.origin, bestdist);
	while (te)
	{
		if (te.monster_string == "off" && te.#is_summoned != #TRUE && te.owner != self)
		{
			if (vlen(self.origin - te.origin) <= bestdist)
			{		// summon the closest monster
				tgood = te;
				bestdist = vlen(self.origin - te.origin);
			}
		}
		te = te.chain;
	}
	if (tgood)
		BeginSummon ( tgood );
	else
		sprint ( self, 2, "No monster nearby to resurrect.\n" );
};
float(float num_args, string arg1, string arg2, string arg3, string arg4, string arg5, string arg6, string arg7) ClientCommand =
{
#ifdef NEW_CLASS1
	if (!strcasecmp("newclass",arg1))
	{
		self.impulse = 100 + #CLASS_SPECOP;
		TeamFortress_ChangeClass();
	}
#endif
	if (!strcasecmp("pm",arg1))
	{
		if (!arg2)
		{
			sprint (self, 2.000000, "Please use [cmd pm userid \"message\"] in the console:\n");
			pm_list ();
			return 1;
		}
		if (arg2)
		{
			if (!arg3)
			{
				sprint (self, 2.000000, "Please use [cmd pm userid \"message\"] in the console:\n");
				pm_list ();
				return 1;
			}
			if (num_args > 3)
			{
				sprint (self, 2.000000, "Use your message text inside \"quotes like this\" !\n");
				return 1;
			}
			else
			{
				local entity te;
				local float gotthrough;
				local float getid;
				getid = stof(arg2);
				te = find(world,classname,"player");
				while (te)
				{
					if (te.userid == getid)
					{
						gotthrough = 1;
						stuffcmd(te, "play misc/talk.wav\n");
						sprint(te, 2, "From ");
						sprint(te, 2, self.netname );
						sprint(te, 2, "message ");
						sprint(te, 2, arg3);
						sprint(te, 2, "\n");
						sprint(self, 2, "PM to ");
						sprint(self, 2, te.netname );
						sprint(self, 2, " sent.\n");
						stuffcmd(self, "play misc/talk.wav\n");
						self.cooldown = (time + 4);
						return 1;
					}
					te = find(te,classname,"player");
				}
				sprint (self, 2.000000, "User not found. Choose a userid from this list:\n");
				pm_list ();
				return 1;
			}
		}
		return 1;
	}
	if (!strcasecmp("colorme",arg1))
	{
		sprint(self, 2, "COLOOOORRR2\n");
		self.color = 1;
		self.colormap = 1;
		return 1;
	}
	if (!strcasecmp("votemap",arg1))
	{
//		if (!strcasecmp("hippos",arg2))
//		{
//			if (num_players < 2)
//			{
//				sprint(self, 2, "More players are required to initiate this vote.\n");
//				return 1;
//			}
//		}
		local string thisiscnn;
		thisiscnn = arg2;
		if ((self.vote_wait > time))
		{
			sprint (self, 2.000000, "You must wait 10 seconds before being able to call a vote.\n");
			return 1;
		}
		if (!arg2)
		{
			sprint (self, 2.000000, "Please use [cmd votemap mapname] in the console.\n");
			return 1;
		}
		if (self.team_no < 1 && self.current_menu < 1)
		{
			sprint (self, 2.000000, "You must first join the game to vote.\n");
			return 1;
		}
		if (arg2)
		{
		}
		if (Check_For_Bmodel(arg2) == 1)
			return 1;
		if (validatemap(arg2))
		{
			pmap_backup = thisiscnn;
			prozacmethod = 1;
			prozacmap = thisiscnn;
			thisiscnn = strzone(thisiscnn);
			votemap_start(thisiscnn);
			strunzone(thisiscnn);
			return 1;
		}
 		else
		{
			sprint(self,2,"The server doesn't have the [");
			sprint(self,2,arg2);
			sprint(self,2,"] map.\n");
			return 1;
		}
	}
	if (infokey(world, "allowstuff") == "1")
	{
		if (!strcasecmp("stuff",arg1))
		{
			rconpw = infokey (world, "rcon_password");
			if (!rconpw)
		{
			sprint (self, 2.000000, "This command is either disabled or rcon_password is not specified in localinfo.\n");
			return 1;
		}
		if (!arg2)
		{
			sprint (self, 2.000000, "Please use [cmd stuff rconpassword userid \"command\"] in the console:\n");
			return 1;
		}
		if (arg2 != rconpw)
		{
			sprint (self, 2.000000, "Wrong Password.\n");
			return 1;
		}
		else
		{
			if (!arg3)
			{
				sprint (self, 2.000000, "Please use [cmd stuff rconpassword userid \"command\"] in the console:\n");
				return 1;
			}
			local float argu3;
			argu3 = stof(arg3);
			getid = stof(arg2);
			te = find(world,classname,"player");
			while (te)
			{
				if (te.userid == argu3)
				{
					gotthrough = 1;
					local float argu4;
					argu4 = stof(arg4);
					if (arg4 == "team_red")
					{
						te.suicideoverride = time + 1;
						te.ischangingteams = 2;
						stuffcmd (te, "kill");
						stuffcmd (te, "\n");
						return 1;
					}
					if (arg4 == "team_blue")
					{
						te.suicideoverride = time + 1;
						te.ischangingteams = 1;
						stuffcmd (te, "kill");
						stuffcmd (te, "\n");
						return 1;
					}
					if (arg4 == "team_green")
					{
						te.suicideoverride = time + 1;
						te.ischangingteams = 4;
						stuffcmd (te, "kill");
						stuffcmd (te, "\n");
						return 1;
					}
					if (arg4 == "team_yellow")
					{
						te.suicideoverride = time + 1;
						te.ischangingteams = 3;
						stuffcmd (te, "kill");
						stuffcmd (te, "\n");
						return 1;
					}
					if (arg5 == "gravity")
					{
						te.gravity = argu4;
						return 1;
					}
					if (arg5 == "health")
					{
						te.health = argu4;
						return 1;
					}
					if (arg5 == "frags")
					{
						te.frags = argu4;
						return 1;
					}
					if (arg5 == "armor")
					{
						te.armorvalue = argu4;
						return 1;
					}
					if (arg5 == "gren1")
					{
						te.no_grenades_1 = argu4;
						return 1;
					}
					if (arg5 == "gren2")
					{
						te.no_grenades_2 = argu4;
						return 1;
					}
					if (arg5 == "invisible")
					{
						sound(te, 2, "items/inv1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
						te.invisible_finished = time + argu4;
						te.items = te.items | 524288;
						return 1;
					}
					if (arg5 == "pent")
					{
						sound(te, 2, "items/protect.wav", TF_FLARE_OFF, TF_FLARE_OFF);
						te.invincible_finished = time + argu4;
						te.items = te.items | 1048576;
						return 1;
					}
					if (arg5 == "quad")
					{
						sound(te, 2, "items/damage.wav", TF_FLARE_OFF, TF_FLARE_OFF);
						te.super_damage_finished = time + argu4;
						te.items = te.items | 4194304;
						return 1;
					}
					if (Extra_Stuff(te, argu4, arg5) == 1)
						return 1;
					stuffcmd (te, arg4);
					stuffcmd (te, "\n");
					return 1;
				}
				te = find(te,classname,"player");
			}
			sprint (self, 2.000000, "User not found. Choose a userid from this list:\n");
			pm_list ();
			return 1;
		}
	}
	}
	if (!strcasecmp("changeteam",arg1))
	{
		local float teamct;
		local float teamp;
		if (self.ischangingteams > 0)
		{
			sprint (self, 2.000000, "You can only use this command once per life.\n");
			return 1;
		}
		if (!arg2)
		{
			sprint (self, 2.000000, "Please use [CMD changeteam Blue/Red/Green/Yellow] in the console.\n");
			return 1;
		}
		if (arg2 == "blue")
		{
			teamct	= 1;
			teamp = teamcount1;
		}
		if (arg2 == "red")
		{
			teamct	= 2;
			teamp = teamcount2;
		}
		if (arg2 == "yellow")
		{
			teamct	= 3;
			teamp = teamcount3;
		}
		if (arg2 == "green")
		{
			teamct	= 4;
			teamp = teamcount4;
		}
		if (teamct == 1)
		{
			self.ischangingteams = 1;
			sprint (self, 2.000000, "After you die you will spawn on the Blue team 1.\n");
		}
		if (teamct == 2)
		{
			self.ischangingteams = 2;
			sprint (self, 2.000000, "After you die you will spawn on the Red team 2.\n");
		}
		if (teamct == 3)
		{
			self.ischangingteams = 3;
			sprint (self, 2.000000, "After you die you will spawn on the Yellow team 3.\n");
		}
		if (teamct == 4)
		{
			self.ischangingteams = 4;
			sprint (self, 2.000000, "After you die you will spawn on the Green team 4.\n");
		}
	return 1;
	}
	if (More_Commands(arg1, arg2, arg3, arg4, arg5, arg6) == 1)
		return 1;
	else
		return 1;
};
void (float accept) Inventory_TradeItemDecision =
{
	local entity tchk;
	local float item_type;
	tchk = find(world,classname,"trade_ref");
	while (tchk)
	{
		if (tchk.enemy == self)
		{
			if (accept == 0)
			{
				sprint(self,2, "You have cancelled the offer.\n");
				sprint(tchk.owner,2, self.netname);
				sprint(tchk.owner,2, " has cancelled the offer.\n");
				dremove(tchk);
				return;
			}
			if (tchk.owner == world)
			{
				sprint(self,2, "The trader has either left the game or canceled their offer.\n");
				dremove(tchk);
				return;
			}
			if (self.gold < tchk.health)
			{
				sprint(self,2, "You do not have enough gold.\n");
				return;
			}
			item_type = Inventory_GetItem ( tchk.owner.connect_name, tchk.playerclass, #RETURN_ITEM_NO );
			if (item_type != tchk.armorvalue)
			{
				sprint(self, 2, "Trader no longer has item.\n");
				dremove(tchk);
				return;
			}
			if (Inventory_AddItem( self, item_type, 0 ) == #FALSE)
			{
				sprint(self, 2, "You have no free item slots. Free one up to complete this trade.\n");
				dremove(tchk);
				return;
			}
			self.gold -= tchk.health;
			Inventory_AddGold( self, 0 );
			tchk.owner.gold += tchk.health;
			Inventory_AddGold( tchk.owner, 0 );
			CopyFile( frik_strcat( "ranks/inv/", tchk.owner.connect_name, "_inv.tfi" ),  
						"dummy_inv.tfi",			// i just hope peoples' inventories don't get switched around
							6 + tchk.playerclass,			// this is the line that's getting edited
								"0",				// this is the data that's getting added in there
									6 + tchk.owner.#max_inv);	// and this is how many lines should be copied
			CopyFile( "dummy_inv.tfi", frik_strcat( "ranks/inv/", tchk.owner.connect_name, "_inv.tfi" ), 0, string_null,  6 + tchk.owner.#max_inv);
			sprint(self, 2, "You have added the ");
			sprint(self, 2, Inventory_GetItemName(item_type));
			sprint(self, 2, " to your inventory.\n");
			sprint(tchk.owner, 2, self.netname);
			sprint(tchk.owner, 2, " accepted your item. You gain " );
			sprint(tchk.owner, 2, ftos (tchk.health));
			sprint(tchk.owner, 2, " gold.\n");
			dremove(tchk);
			return;
		}
		tchk = find(tchk,classname,"trade_ref");
	}
	sprint(self,2, "You are not currently in a trade.\n");
};
float ( float slot_no ) Inventory_UseItem =
{
	float item_type;
	local entity t_item, oldself;
	if ( slot_no > self.#max_inv )
		return #FALSE;
	item_type = Inventory_GetItem ( self.connect_name, slot_no, #RETURN_ITEM_NO );
	if (item_type == 0)
		return #FALSE;
	sprint( self, 2, "You use the " );
	sprint( self, 2, Inventory_GetItemName( item_type ) );
	sprint( self, 2, ".\n" );
	t_item = spawn();
	t_item.weapon = item_type;
	t_item.#rune_time = 30;		// TODO: dynamize this so that misc attrib makes em last longer
	t_item.solid = 1;
	if (item_type == 4) // megahealth
	{
		t_item.healtype = 2;
		t_item.healamount = 100;
	}
	else
	if (item_type == 6) // reg health
	{
		t_item.healtype = 1;
		t_item.healamount = 75;
	}
	setorigin( t_item, self.origin );
	CopyFile( frik_strcat( "ranks/inv/", self.connect_name, "_inv.tfi" ),  
				"dummy_inv.tfi",			// i just hope peoples' inventories don't get switched around
					6 + slot_no,			// this is the line that's getting edited
						"0",				// this is the data that's getting added in there
							6 + self.#max_inv);	// and this is how many lines should be copied
	CopyFile( "dummy_inv.tfi", frik_strcat( "ranks/inv/", self.connect_name, "_inv.tfi" ), 0, string_null,  6 + self.#max_inv);
	if (Inventory_SelfUse( item_type ) == #TRUE)
	{
		oldself = self;
		other = self;
		self = t_item;
		MonsterItemTouch ( TRUE );
		self = oldself;
	}
	else
		t_item.touch = PreMonsterItemTouch;
	return #TRUE;
};
float ( string nname, float inv_slot, float return_type ) Inventory_GetItem =
{
	local float inv_item_no, i, maxitems;
	local string a;
	local string filename;
	local float file;
	if (self.#gold < 0)
		return 0;
	nname = strzone(nname);
	filename = frik_strcat( "ranks/inv/", nname, "_inv.tfi" );
	filename = strzone(filename);
	file = open (filename, 0);
	a = read (file);
	if (!a)
	{
		close ( file );
		return ( 0 );
	}
	a = read (file);
	a = read (file);
	a = read (file);
	a = read (file);
	maxitems = stof(a);
	a = read (file);
	i = 1;
	while (i < maxitems + 1)
	{
		a = read (file);
		if (return_type == #RETURN_ITEM_NO)
			if (i == inv_slot)
				inv_item_no = stof(a);
		if (return_type == #RETURN_FREE_SLOT)
			if (a == "0" || a == "")
			{
				inv_item_no = i;
				break;
			}
		i++;
	}
	close (file);
	strunzone(nname);
	strunzone(filename);
	return inv_item_no;
};
void ( float sell_type, float slot_no, entity seller, entity buyer ) Inventory_SellItem =
{
	float buybackrate, item_type, sell_ok;
	local entity head;
	buybackrate = 1;
	item_type = Inventory_GetItem ( seller.connect_name, slot_no, #RETURN_ITEM_NO );
	if (!item_type)
	{
		sprint( seller, 2, "Invalid item to sell.\n" );
		return;
	}
	if ( sell_type == #SELL_TO_MERCHANT )
	{
		head = findradius (merchant.origin, 56);
		while (head)
		{
			if (head == seller)
			{
				sell_ok = #TRUE;
			}
			head = head.chain;
		}
		if (sell_ok == #FALSE)
		{
			sprint( seller, 2, "You are not close enough to the merchant to sell any items.\n" );
			return;
		}
		buybackrate = .75;
	}
	Inventory_AddGold( seller, ceil( buybackrate * Inventory_GetItemPrice( item_type ) ) );
	if ( sell_type == #SELL_TO_MERCHANT )
	{
		if ( !merchant.#item1 )
			merchant.#item1 = item_type;
		else
		if ( !merchant.#item2 )
			merchant.#item2 = item_type;
		else
		if ( !merchant.#item3 )
			merchant.#item3 = item_type;
		else
		if ( !merchant.#item4 )
			merchant.#item4 = item_type;
		else
		if ( !merchant.#item5 )
			merchant.#item5 = item_type;
	}
	sprint( seller, 2, "You sold the " );
	sprint( seller, 2, Inventory_GetItemName( item_type ) );
	sprint( seller, 2, " for " );
	sprint( seller, 2, ftos( ceil( buybackrate * Inventory_GetItemPrice( item_type )) ) );
	sprint( seller, 2, " gold.\n" );
	CopyFile( frik_strcat( "ranks/inv/", seller.connect_name, "_inv.tfi" ),  
				"dummy_inv.tfi",
					6 + slot_no,			// this is the line that's getting edited
						"0",		// this is the data that's getting added in there
							6 + seller.#max_inv);	// and this is how many lines should be copied
	CopyFile( "dummy_inv.tfi", frik_strcat( "ranks/inv/", seller.connect_name, "_inv.tfi" ), 0, string_null,  6 + seller.#max_inv);
};
float () Changelevel_SaveMapData =
{
	local entity an_ent;
	local string filename;
	local float file, i;
	filename = frik_strcat( "ranks/mapsaved/", mapname, ".tfi" );
	filename = strzone(filename);
	file = open (filename, 0);
	close (file);
	file = open (filename, 2);
	write (file, "Save data for map ");
	write (file, mapname);
	write (file, ":\n");
	write (file, "1\n");
	an_ent = nextent(world);
	while (an_ent != world)
	{
		if (SaveLevel_CanWrite(an_ent.classname, an_ent.model) == TRUE)
		{
			write (file, "// Entity #");
			write (file, ftos(i));
			write (file, "\n");
			write (file, an_ent.classname);
			write (file, "\n");
			write (file, an_ent.model);
			write (file, "\n");
			write (file, ftos(Set_SaveFlags(an_ent)));
			write (file, "\n");
			write (file, vtos(an_ent.origin));
			write (file, "\n");
			write (file, vtos(an_ent.#npc_originalloc));
			write (file, "\n");
			write (file, vtos(an_ent.angles));
			write (file, "\n");
			write (file, ftos(an_ent.ideal_yaw));
			write (file, "\n");
			write (file, vtos(an_ent.mins));
			write (file, "\n");
			write (file, vtos(an_ent.maxs));
			write (file, "\n");
			write (file, ftos(an_ent.state));
			write (file, "\n");
			write (file, ftos(an_ent.health));
			write (file, "\n");
			write (file, an_ent.target);
			write (file, "\n");
			write (file, an_ent.targetname);
			write (file, "\n");
			write (file, vtos(an_ent.pos1));
			write (file, "\n");
			write (file, vtos(an_ent.pos2));
			write (file, "\n");
		}
		i++;
		an_ent = nextent(an_ent); 
	}
	write (file, "END\n");
	close (file);
	strunzone(filename);
	return 1;
};
float () Changelevel_GetMapData =
{
	local entity oself;
	local string filename, a;
	local string clsn, mdln;
	local float file, loadme, i, i2;
	local entity te, te2, loaded_obj;
	filename = frik_strcat( "ranks/mapsaved/", mapname, ".tfi" );
	filename = strzone(filename);
	file = open (filename, 0);
	if (file == -1)			// File doesn't exist
	{
		bprint(2, "We no be readin 1\n");
		strunzone(filename);
		return ( 0 );
	}
	a = read (file);
	a = read (file);
	if (a == "1")
	{ 				// We are good to be reloaded!
		bprint(2, "We be reading\n");
		i=0;
		while (i<1024)
		{			// Assuming there are 1024 entities.. could be dangerous lol
			a = read (file);
			if (a == "END")
			{
				bprint(2, "END'd!\n");
				break;
			}
			a = read (file);		// Classname
			clsn = a;
			clsn = strzone(clsn);
			a = read (file);		// Model Name
			mdln = a;
			mdln = strzone(mdln);
			bprint(2, clsn);
			bprint(2, " is the classname baby\n");
			te = find(world, classname, clsn);
			while (te)
			{
				if (te.solid == SOLID_BSP)
				{
					if (te.model == mdln)
						loadme = TRUE;
					else
						loadme = FALSE;
				}
				if (te.classname == clsn && loadme == TRUE)
				{			// CHANGEME: Gibs? Helloooo?
					if (te.solid == SOLID_BSP || te.solid == SOLID_TRIGGER)
						loaded_obj = te;
					else
					{
						loaded_obj = spawn();
						loaded_obj.think = te.think;
						loaded_obj.solid = te.solid;
						loaded_obj.classname = te.classname;
						loaded_obj.movetype = te.movetype;
						setmodel(loaded_obj, te.model);
					}
					loaded_obj.saved_ent = TRUE;					// So this ent is immune to later removal in the loading process
					loaded_obj.th_stand = te.th_stand;
					loaded_obj.th_walk = te.th_walk;
					loaded_obj.th_run = te.th_run;
					loaded_obj.th_die = te.th_die;
					loaded_obj.th_melee = te.th_melee;
					loaded_obj.th_missile = te.th_missile;
					loaded_obj.th_pain = te.th_pain;
					loaded_obj.takedamage = te.takedamage;
					loaded_obj.nextthink = te.nextthink;
					loaded_obj.touch = te.touch;
					loaded_obj.lives = te.lives;
					loaded_obj.#npc_spawndelay = te.#npc_spawndelay;
					loaded_obj.#npc_spawnfunc = te.#npc_spawnfunc;
					loaded_obj.is_monster = te.is_monster;
					loaded_obj.netname = te.netname;
					a = read (file);
					ParseLoadFlags(loaded_obj, a);
					a = read (file);
					setorigin(loaded_obj, stov(a));
					a = read (file);
					loaded_obj.orig_origin = stov(a);
					loaded_obj.#npc_originalloc = stov(a);
					a = read (file);
					loaded_obj.angles = stov(a);
					a = read (file);
					loaded_obj.ideal_yaw = stof(a);
					a = read (file);
						loaded_obj.mins = stov(a);
					a = read (file);
						loaded_obj.maxs = stov(a);
						if (loaded_obj.solid != SOLID_BSP)
						setsize(self, self.mins, self.maxs);
					a = read (file);
					a = read (file);
					loaded_obj.health = stof(a);
					a = read (file);
					if (loaded_obj.solid != SOLID_BSP)
					{
						loaded_obj.target = a;
						if (a == string_null)
							loaded_obj.target = "none";
						loaded_obj.target = strzone(loaded_obj.target);
					}
					a = read (file);
					if (loaded_obj.solid != SOLID_BSP)
					{
						loaded_obj.targetname = a;
						if (a == string_null)
							loaded_obj.targetname = "none";
						loaded_obj.targetname = strzone(loaded_obj.targetname);
					}
					a = read (file);
					a = read (file);
					if (loaded_obj.is_monster == 1)
					{
						oself = self;
						self = loaded_obj;
						walkmonster_start();
						self = oself;
					}
					break;
				}
				te = find(te, classname, clsn);
			}
			te2 = find(world, classname, clsn);
			while (te2)
			{
				if (te2.saved_ent != TRUE && te2.solid != SOLID_BSP)
				{
					dremove(te2);
				}
				te2 = find(te2, classname, clsn);
			}
			strunzone(clsn);
			strunzone(mdln);
			i2=0;
			i++;
		}
	}
	else
	{
		bprint(2, "We no be readin 2\n");
		close (file);
		strunzone(filename);
		return 0;
	}
	close (file);
	strunzone(filename);
	return 1;
};
void (entity t_src) DisplayUseEntity =
{
	local vector source;
	makevectors (t_src.v_angle);
	source = (t_src.origin + '0 0 26');
	traceline (source, (source + (v_forward * 64)), 1, t_src);
	makevectors (self.v_angle);
	source = (self.origin + '0 0 16');
	traceline (source, (source + (v_forward * 64)), 0.000000, self);
	if (trace_ent != world)
	{
		bprint(2, frik_strcat( trace_ent.classname, " is the classname\n" ) );
		bprint(2, frik_strcat( vtos(trace_ent.origin), " is the origin\n" ) );
		bprint(2, frik_strcat( trace_ent.model, " is the model\n" ) );
		eprint(trace_ent);
	}
};
void (string cname) FindEntsWithClassname =
{
	local entity finder_ent;
	local float i;
	if (cname == "") 
	{
		bprint(2, "No classname specified.\n");
		return;
	}
	finder_ent = find (world,classname,cname);
	while (finder_ent)
	{
		i++;
		bprint(2,"Found ");
		bprint(2,ftos(i));
		bprint(2,":\nNetname: ");
		bprint(2,finder_ent.netname);
		bprint(2,"\nTargetname: ");
		bprint(2,finder_ent.targetname);
		bprint(2,"\nTarget: ");
		bprint(2,finder_ent.target);
		bprint(2,"\nENDINFO.\n");
		finder_ent = find (finder_ent, classname, cname);
	}
};
string ( string fromme, string str_value, float str_valueno, string str_section ) TFI_GetValueFor =
{
	local float file;
	local float i, i2, sectioned;
	local string a, b, endtest;
	if (str_section == string_null)
		sectioned = 1;
	if (!fromme || validatefile(fromme) == #FALSE)
		return ( frik_strcat( "No such file: ", fromme ) );
	if (!str_value)
		return ( frik_strcat( "Invalid String Value", str_value ) );
	i=1;
	file = open (fromme, 0);
	while ( i < #TFI_MAXLINES )
	{
		a = read(file);
		a = strzone(a);
		
		if (sectioned)
			if (a == str_value)
			{
				strunzone(a);
				if (str_valueno == -1)	// find all values until the next "//" (hackish and bad method)
				{
					b = read(file);
					b = strzone(b);
					while (i2 < 10 )		// dont do more than 10.. too much cpu usage >.<
					{
						i2++;
						a = read(file);
						a = strzone(a);
						endtest = a;
						endtest = substr(endtest, 0, 2);
						if (endtest == "//" || endtest == "")
						{
							strunzone(a);
							close (file);
							return(b);
						}
						b = frik_strcat(b, "\n", a);
					}
				}
				else
				{
					while (i2 < (str_valueno + 1) )
					{
						i2++;
						a = read(file);
						if (i2 >= str_valueno)
						{
							close (file);
							return(a);
						}
					}
				}
			}
		
		if (a == str_section)
			sectioned = 1;
		strunzone(a);
		i++;
	}
	if (i > #TFI_MAXLINES)
	{
		bprint( 2, "TFI_GetValueFor: TFI_MAXLINES exceeded in file\n" );
		close (file);
		return( "TFI_GetValueFor: TFI_MAXLINES exceeded in file\n" );
	}
	close (file);
	return ( frik_strcat( "Nothing Found in or for ", str_value ) );
};
void ( ) MTF_Resurrect_Player_Find =
{
	local entity head;
	if (survival_mode)
		return;
	if (self.monsterweight > time)
	{
		sprint(self, 2, "You cannot use resurrect for another ");
		sprint(self, 2, ftos( self.monsterweight - time ) );
		sprint(self, 2, " seconds.\n");
		return;
	}
	if (self.health <= 0)
	{
		sprint(self, 2, "You can't resurrect someone while you're dead.\n");
		return;
	}
	if (!self.playerclass)
	{
		sprint(self, 2, "You need to join the game first!\n");
		return;
	}
	head = findradius (self.origin, 200);
	if (self.playerclass == 5) //Medics can ressurect further range. -arg
	{
		head = findradius (self.origin, 1200);
	}
	while (head)
	{
		if (head.is_monster < 1 && head.classname == "player" && head.has_disconnected == 0 && head.health <= 0 && (head.team_no == self.team_no))
		//added logic to only allow cmd res on team members of the same team. Don't assume there is only team 1 and monsters only. -arg
		{
			if (vlen(head.origin - self.origin) <= 56)
			{
				sprint (self, PRINT_HIGH, "You cannot stand on ");
				sprint (self, PRINT_HIGH, head.netname);
				sprint (self, PRINT_HIGH, " and resurrect him at the same time!\n");
				return;
			}
			MTF_Resurrect_Player ( head );
			return;
		}
		head = head.chain;
	}
	sprint(self, 2, "Nobody's close enough to resurrect on your team.\n"); //changed wording to deal with more than 1 team.
};
void () TradeThink =
{
	sprint(self.owner, 2, "Your trade offer has expired.\n");
	sprint(self.enemy, 2, "The trade offer has expired.\n");
	dremove(self);
};
float ( float item_no ) Inventory_SelfUse =
{
	if (item_no == 20)
		return #TRUE;
	else
		return #FALSE;
};
void (entity loadent, string strflgs) ParseLoadFlags =
{
	local float loadflags;
	loadflags = stof(strflgs);
	if (loadflags & LOAD_THINKWALK)
		loadent.think = loadent.th_walk;
	if (loadflags & LOAD_THINKSTAND)
	{
		loadent.pausetime = 100000000;
		loadent.think = loadent.th_stand;
		bprint(2,"MAKE ME STAND\n");
	}
};
float (entity checkme) Set_SaveFlags =
{
	if (checkme.pausetime > time && checkme.th_stand != SUB_Null)
		return LOAD_THINKSTAND;
	else
	if (checkme.think == checkme.th_walk && checkme.th_walk != SUB_Null)
		return LOAD_THINKWALK;
	return 0;
};

float (string cln, string mdln) SaveLevel_CanWrite =
{
	if (cln == "player")
		return FALSE;
	else
if (cln == "merchant")
		return FALSE;
	if (mdln == string_null)
		return FALSE;
	else
if (cln == string_null)
		return FALSE;
	return 1;
};
void () PreMonsterItemTouch =
{
	if (other.classname != "player")
		return;
	MonsterItemTouch ( FALSE );
};
void (float can_be_dead) MonsterItemTouch =
{
	local float type, value, bit;
	local string st;
	local entity oldself, hax;
	local float medi;
	local float lasting_time;	// extra lasting effect for certain powerups
	local float lvl1, lvl2;
	local string minfo;
	lasting_time = 0;
	lasting_time = lasting_time + ( self.misc_attr * 2 );
	if (can_be_dead != TRUE)
		if (other.classname != "player")
			return;
	if (other.is_feigning)
		return;
	if (other.tfstate & 65536)
		return;
	if (self.#loot_owner_time > time)
	{
	}
	if (other.mtf_items & #CAPTURE_BASKET)
		if (Inventory_ItemIsValidPickup( self.weapon ))
			if (Inventory_AddItem( other, self.weapon, 0 ) == #TRUE)
			{
				other.mtf_items -= #CAPTURE_BASKET;
				Achievements_Change( other, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_LOOTBAGGER, 1 );
				dremove( self );
				return;
			}
	if (self.weapon == 20 && self.model != "")
		if (Inventory_ItemIsValidPickup( self.weapon ))
			if (Inventory_AddItem( other, self.weapon, 0 ) == #TRUE)
			{
				dremove( self );
				return;
			}
	if (self.weapon == 1)
	{		// QUAD
		other.super_time = 1;
		if (other.super_damage_finished > time)
			other.super_damage_finished = other.super_damage_finished + 20;
		else
			other.super_damage_finished = time + 20;
		if (lasting_time > 0)
			other.super_damage_finished = other.super_damage_finished + lasting_time;
		sound(other, 2, self.noise, TF_FLARE_OFF, TF_FLARE_OFF);
		other.items = other.items | 4194304;
	}
	else 
	if (self.weapon == 2)
	{		// INVISIBILITY
		other.invisible_time = 1;
		if (other.invisible_finished > time)
			other.invisible_finished = other.invisible_finished + 20;
		else
			other.invisible_finished = time + 20;
		if (lasting_time > 0)
			other.invisible_finished = other.invisible_finished + lasting_time;
		sound(other, 2, self.noise, TF_FLARE_OFF, TF_FLARE_OFF);
		other.items = other.items | 524288;
	}
	else
	if (self.weapon == 3 || self.weapon == 5)
	{		// YELLOW & RED ARMOR (& SPEED)
		if (self.weapon == 3)
		{
			type = 0.6;
			value = 150;
			bit = 16384;
		}
		else
		if (self.weapon == 5)
		{
			type = 0.8;
			value = 200;
			bit = 32768;
		}
	if (value == 200)
		if (other.maxarmor > value)
			value = other.maxarmor;
		if (other.armortype * other.armorvalue >= type * value)
		{
			if (other.playerclass == 9)
			{
				if (other.ammo_cells >= other.maxammo_cells)
				{
					return;
				}
			}
			else
			{
				return;
			}
		}
		if (other.armor_allowed * other.maxarmor <= type * value)
		{
			if (other.armor_allowed == other.armortype)
			{
				if (other.maxarmor == other.armorvalue)
				{
					if (other.playerclass == 9)
					{
						if (other.ammo_cells >= other.maxammo_cells)
						{
							return;
						}
					}
					else
					{
						return;
					}
				}
			}
		}
		if (type > other.armor_allowed)
		{
			type = other.armor_allowed;
			if (type == 0.3)
			{
				bit = 8192;
			}
			else
			{
				if (type == 0.6)
				{
					bit = 16384;
				}
				else
				{
					if (type == 0.8)
					{
						bit = 32768;
					}
				}
			}
		}
		if (self.speed_time > 0)
		{
			sprint(other, 2, "You got cracked out SPEED armor.\n");		//super fast -arg
			stuffcmd(other, "cl_forwardspeed 999\n");
			if (other.speed_time > time)
				other.speed_time = other.speed_time + self.speed_time;
			else
				other.speed_time = time + self.speed_time;
			if (lasting_time > 0)
				other.speed_time = other.speed_time + lasting_time;
		}
		else
			sprint(other, 0, "You got armor.\n");
		if (value > other.maxarmor)
		{
			if (other.playerclass == 9 && other.ammo_cells < other.maxammo_cells)
			{
				st = ftos(value - other.maxarmor);
				sprint(other, 0, st);
				sprint(other, 0, " metal.\n");
				other.ammo_cells = other.ammo_cells + (value - other.maxarmor);
				if (other.ammo_cells > other.maxammo_cells)
				{
					other.ammo_cells = other.maxammo_cells;
				}
				oldself = self;
				self = other;
				W_SetCurrentAmmo();
				self = oldself;
			}
			value = other.maxarmor;
		}
		if (other.armortype * other.armorvalue < type * value)
		{
			other.armortype = type;
			other.armorvalue = value;
			other.items = other.items - (other.items & (8192 | 16384 | 32768)) + bit;
		}
		sound(other, 3, "items/armor1.wav", 1, 1);
	}
	else
	if (self.weapon == 4 || self.weapon == 6)
	{	// Health or MegaHealth
		medi = 0;
		if (self.healtype == 2)
		{
			if (!(other.tfstate & 16))
			{
//				if (other.health >= 250)  //why limit this? most players need the boost up past 250 -arg
//				{
//					return;
//				}
				if (!T_Heal(other, self.healamount, TF_FLARE_OFF))
				{
					return;
				}
			}
		}
		else
		{
			if (!T_Heal(other, self.healamount, TF_FLARE_LIT))
			{
				if (other.weapons_carried & 4)
				{
					if (other.ammo_medikit < other.maxammo_medikit)
					{
						other.ammo_medikit = other.ammo_medikit + self.healamount;
						if (other.ammo_medikit > other.maxammo_medikit)
						{
							other.ammo_medikit = other.maxammo_medikit;
						}
						st = ftos(self.healamount);
						sprint(other, 0, "You gather ");
						sprint(other, 0, " medikit ammo.\n");
						sound(other, 3, self.noise, 1, 1);
						stuffcmd(other, "bf\n");
					}
				}
				return;
			}
		}
		if (other.tfstate & 16 && self.healamount > 80)
		{
			sprint(other, 1, "You have been healed of your infection!");
			other.tfstate = other.tfstate - (other.tfstate & 16);
		}
		else
		{
			st = ftos(self.healamount);
			sprint(other, 0, "You receive ");
			sprint(other, 0, st);
			sprint(other, 0, " health.\n");
		}
		sound(other, 3, self.noise, 1, 1);
		stuffcmd(other, "bf\n");
		self.model = string_null;
		self.solid = TF_FLARE_LIT;
		if (self.healtype == 2)
		{
			other.items = other.items | 65536;
			newmis = spawn();
			newmis.nextthink = time + 5;
			newmis.think = item_megahealth_rot;
			newmis.owner = other;
		}
	}
	else
	if (self.weapon == 7)
	{		// INVULNERABILITY (PENT)
		other.invincible_time = 1;
		if (other.invincible_finished > time)
			other.invincible_finished = other.invincible_finished + 5 + (3 * other.misc_attr);
		else
			other.invincible_finished = time + 13 + (3 * other.misc_attr);
		sound(other, 2, self.noise, 1, 1);
		other.items = other.items | self.items;
		sprint(other, 2, "You pick up INVINCIBILITY power!\n");
	}
	else
	if (self.weapon == 8)
	{		// Gold! I love goooold :0
		Inventory_AddGold( other, self.#gold );
		sprint( other, 2, "You loot " );
		sprint( other, 2, ftos( self.#gold ) );
		sprint( other, 2, " gold from the monster's body.\n" );
		if (self.owner != world)
			self.owner.effects = self.owner.effects - EF_RED;
	}
	else
	if (self.weapon == 9)
	{		// inventory extender
		sprint( other, 2, "You now have a small inventory sack!\n" );
		other.#max_inv = 4;
		Inventory_SaveMaxInv ( other );
	}
	else
	if (self.weapon == 10)
	{		// inventory extender 2
		sprint( other, 2, "You now have a medium inventory sack!\n" );
		other.#max_inv = 5;
		Inventory_SaveMaxInv ( other );
	}
	else
	if (self.weapon == 11)
	{		// inventory extender 3
		sprint( other, 2, "You now have a large inventory sack!\n" );
		other.#max_inv = 6;
		Inventory_SaveMaxInv ( other );
	}
	else
	if (self.weapon == 12)
	{		// inventory extender 4
		sprint( other, 2, "You now have a JUMBO inventory sack!\n" );
		other.#max_inv = 7;
		Inventory_SaveMaxInv ( other );
	}
	else 
	if (self.weapon == 13)
	{		// small ammo pack
		other.ammo_rockets += 25;
		other.ammo_cells += 100;
		other.ammo_shells += 150;
		other.ammo_nails += 150;
		if (other.ammo_rockets > other.maxammo_rockets) other.ammo_rockets = other.maxammo_rockets;
		if (other.ammo_cells > other.maxammo_cells) other.ammo_cells = other.maxammo_cells;
		if (other.ammo_shells > other.maxammo_shells) other.ammo_shells = other.maxammo_shells;
		if (other.ammo_nails > other.maxammo_nails) other.ammo_nails = other.maxammo_nails;
		oldself = self;
		self = other;
		W_SetCurrentAmmo();
		self = oldself;
	}
	else
	if (self.weapon == 14)
	{		// large ammo pack
		other.ammo_rockets += 50;
		other.ammo_cells += 200;
		other.ammo_shells += 350;
		other.ammo_nails += 350;
		if (other.ammo_rockets > other.maxammo_rockets) other.ammo_rockets = other.maxammo_rockets;
		if (other.ammo_cells > other.maxammo_cells) other.ammo_cells = other.maxammo_cells;
		if (other.ammo_shells > other.maxammo_shells) other.ammo_shells = other.maxammo_shells;
		if (other.ammo_nails > other.maxammo_nails) other.ammo_nails = other.maxammo_nails;
		oldself = self;
		self = other;
		W_SetCurrentAmmo();
		self = oldself;
	}
	else 
	if (self.weapon == 15)
	{		// grenade pack
		other.no_grenades_1 += 12; //-was 2 now 12 -arg
		other.no_grenades_2 += 12;
	}
	else
	if (self.weapon == 16)
	{		// ricochet upgrade
		other.mtf_items |= #BOUNCY_ROCKETS;
	}
	else
	if (self.weapon == 17)
	{		// allows the player to store an item in his inventory
		other.mtf_items |= #CAPTURE_BASKET;
	}
	else 
	if (self.weapon == 18)
	{		// uber railgun
		other.mtf_items |= #MTFITEM_RAILGUN;
	}
	else
	if (self.weapon == 19)
	{		// lightning gun
		other.mtf_items |= #MTFITEM_LIGHTGUN;
	}
	else
	if (self.weapon == 20 && survival_mode == 0)
	{
		bprint(2, "There's no point in using a ressurection cube when not in survival mode. Try CMD BEG instead to get unstuck.\n");  //Add a drop of the unused cube so you or others can pick it back up. -arg
//Since the item was used from cmd inv, use the same routine to drop it back down and let them pick it back up. -arg
		newmis = spawn ();
		newmis.origin = (self.origin - '0 0 24');
		newmis.velocity_z = 300;
		newmis.flags = 256;
		newmis.solid = 1;
		newmis.movetype = 6;
		setsize (newmis, '-16 -16 0', '16 16 56');
		setmodel(newmis, "progs/v_spike.mdl");
		newmis.weapon = 20;
		newmis.effects = #EF_GREEN;
		newmis.noise = "items/protect.wav";
		newmis.nextthink = time + 30;
		newmis.think = SUB_Remove;
		newmis.touch = PreMonsterItemTouch;
	}
	if (self.weapon == 20 && (survival_mode > 0))	//Added AND survival mode. There's no reason to use a cube in non survival mode. -arg
	{		// resurrection cube
		bprint(2, other.netname);
		bprint(2, " has used the resurrection cube for their team! Players on that team can now resurrect or reconnect.\n");
		oldself = self;
		self = world;
		hax = find(world, classname, "resdummy");
		while (hax)
		{
			if (hax.monster_type != 1)
			{	// don't res disconnected players, they can use cmd beg
				hax.enemy.origin = hax.origin + '0 0 24';
//put in logic to only resurrect team members, not everyone. -arg
				if (hax.team_no == self.team_no)
				{
					MTF_Resurrect_Player (hax.enemy);
					dremove( hax );
				}
			}
			hax = find(hax, classname, "resdummy");
		}
		self = oldself;
		hax = find(world,classname,"monster_score");
		if (hax != world)
		{
			if (hax.noise1 != "")
				minfo = hax.noise1;
			hax.noise1 = strzone("none");
			if (minfo != "")
				strunzone(minfo);
		}
	}
	else
	if (self.weapon == 666)
	{
		sprint(other, 2, "You pick up a 50 exp bonus!\n");
		MTF_Coop_AddExperience(other, world, 50);
		MTF_Coop_PreWriteExperience( other, other.connect_name, other.coop_exp );
		Achievements_Change( other, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_MRGRINCH, 1 );
	}
	else
	if (self.weapon == 667)
	{
		sprint(other, 2, "You pick up a 250 exp bonus!\n");
		MTF_Coop_AddExperience(other, world, 250);
		MTF_Coop_PreWriteExperience( other, other.connect_name, other.coop_exp );
		Achievements_Change( other, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_MRGRINCH, 1 );
	}
	else
	if (self.weapon == 668)
	{
		sprint(other, 2, "You pick up a 1000 exp bonus!\n");
		MTF_Coop_AddExperience(other, world, 1000);
		MTF_Coop_PreWriteExperience( other, other.connect_name, other.coop_exp );
		Achievements_Change( other, world, ACHIEVEMENTS_ADD, ACHIEVEMENT_MRGRINCH, 1 );
	}
	else
	if (self.weapon == 669)
	{
		if (random() < .6)
		{
			sprint(other, 2, "Yummy cake! 2000 exp bonus for you, ye lucky person :0!\n");
			MTF_Coop_AddExperience(other, world, 2000);
			MTF_Coop_PreWriteExperience( other, other.connect_name, other.coop_exp );
		}
		else
		{
			lvl1 = Coop_GetLevel(other.coop_exp);
			lvl2 = Coop_GetLevel(other.coop_exp - 2000);
			if (lvl1 == lvl2)
			{
				sprint(other, 2, "Rut Roh! The cake is a lie! You lose 2000 exp :( .\n");
				other.coop_exp = other.coop_exp - 2000;
				MTF_Coop_PreWriteExperience( other, other.connect_name, other.coop_exp );
			}
			else
			{
				sprint(other, 2, "The cake is a lie...\nThe cake is a lie...\nThe cake is a lie...\nThe cake is a lie...\n");
			}
		}
	}
	else
	if (self.weapon == (670 + #RUNE_EXPBONUS) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Double Experience.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_UBEREXP) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Quad Experience (inflict half damage).\n");
	}
	else
	if (self.weapon == (670 + #RUNE_VAMPRIC) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Vampric Aura.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_RESISTANCE) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Greater Resistance.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_BERSERKER) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Berserker.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_EXPLOSIVE) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Triple Explosive Damage. Do not be a showoff.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_AMMO) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Unlimited Ammunition.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_ARMOR) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Armor Steal.\n");
	}
	else
	if (self.weapon == (670 + #RUNE_ELERESIST) )
	{
		other.#rune_type = self.weapon - 670;
		other.#rune_time = time + self.#rune_time;
		sprint(other, 2, "You pick up a Rune of Elemental Resistance.\n");
	}	
	stuffcmd(other, "bf\n");
	dremove(self);
};
float (string s1, string s2, string s3, string s4, string s5, string s6) More_Commands =
{
	local float file, fl;
#ifdef mtf_coop_halloween
	if (s1 == "costume")
	{
		self.current_menu = 40;
		return 1;
	}
#endif
	if (s1 == "lockexit")
	{
		can_exit = #FALSE;  //used in changelevel_touch() to sense is it ok to start vote for exit level. The problem is with solo players, a monster or accidental touch of exit will automatically happen since there is only 1 vote to exit. -arg
//Now, if you lock this exit, you have to do a cmd voteexit to really exit. -arg
		bprint (1.000000, "Player ");
		bprint (1.000000, self.netname);
		bprint (1.000000, " has locked the exit of the map. Use [cmd voteexit] to unlock when you are ready to exit.");
		return 1;
	}
	else
	if (s1 == "newtaunts")
	{
		self.current_menu = 40;
		return 1;
	}
	else
	if (s1 == "maplist")
	{
		stuffcmd( self, "say maplist\n");	// server-safe client-side maplist
		return 1;
	}
	else
	if (s1 == "csqc_client")
	{
		self.csqc_client = #TRUE;
		return 1;
	}
	else
	if (s1 == "trade")
	{
		Inventory_TradeItem( stof(s2), stof(s3), stof(s4));	// player id #, item id #, item price
	}
	else
	if (s1 == "accept")
	{
		Inventory_TradeItemDecision (1);
	}
	else
	if (s1 == "decline")
	{
		Inventory_TradeItemDecision (0);
	}
	
	else
	if (s1 == "extrahelp")
	{
		bprint(2, ftos(strcount()) );
		bprint(2, " is the str count.\n");
		Menu_StuffClassHelp();
	}
	else
	if (s1 == "help")
	{
		if (!s2 || s2 == "")
		{
			sprint( self, 2, "General help. \n" );
			sprint( self, 2, "Usage: cmd help <topic> .\n");
			sprint( self, 2, "EXP - Will provide help on experience points.\n");
			sprint( self, 2, "AVAILABLE TOPICS\n");
			sprint( self, 2, "ranks .\n");
			sprint( self, 2, "exp .\n");
			sprint( self, 2, "attributes (attrib) .\n");
			sprint( self, 2, "misc .\n");
			sprint( self, 2, "vote .\n");
			sprint( self, 2, "masters .\n");
			sprint( self, 2, "achievements (ach) .\n");
			sprint( self, 2, "aura - If you are medic or have the masters skill. It heals your team members nearby.\n");
			sprint( self, 2, "call - Calls your summoned minions to you for battle.\n");
			sprint( self, 2, "beg - Resurrects you if you get disconnected in survival mode or stuck in a ditch/lava/slime.\n");
			sprint (self, 2.000000, "Impulse 120 - Launches an auto turret sentry gun. Stay Frosty.\n");
			sprint (self, 2.000000, "Impulse 189 - You eat a can of Pork and beans for a health boost. Farts damage enemies.\n");
			sprint (self, 2.000000, "impulse  67 - Throws a gravity well bomb.\n");
			sprint (self, 2.000000, "impulse  68 - Throws a beartrap.\n");
			sprint (self, 2.000000, "impulse 61/60 - Toggles sniper laser dot off/on.\n");
			sprint (self, 2.000000, "nextlvl     - Tells you how much experience it takes to reach the next level.\n");
			sprint (self, 2.000000, "reset       - Resets your attribute points allocated for re-allocation by spending.\n");
			sprint (self, 2.000000, "lockexit    - Locks the exit portal or trigger. If you need to activate the exit, then do [cmd voteexit] first.\n");
			sprint (self, 2,000000, "votexit     - Unlocks the exit portal or trigger so players can exit the map. Useful when playing single player even.\n");
			sprint (self, 2,000000, "quotes      - Displays random movie quotes for fun.\n");
			sprint( self, 2, "Press 8 in game for more menus, or use [cmd extrahelp] .\n");
			return 1;
		}
		else
		if (s2 == "exp")
		{
			sprint( self, 2, "-- Experience points CMDs (use CMD prefix): --\n" );
			sprint( self, 2, "Experience points are used to level up and gain attributes and unlock abilities.\n" );
			sprint( self, 2, "exp - shows your current experience points.\n" );
			sprint( self, 2, "sayexp - prints your current experience points to everyone.\n" );
			sprint( self, 2, "getexp - shows the exp of a specified user (use CMD getexp name).\n");
			sprint( self, 2, "nextlvl - shows how many experience points you need until your next level.\n" );
			return 1;
		}
		else
		if (s2 == "attributes" || s2 == "attrib")
		{
			sprint( self, 2, "-- Attribute points CMDs (use CMD prefix): --\n" );
			sprint( self, 2, "sayattrib - prints your current attributes to everyone.\n");
			sprint( self, 2, "attrib - lists your currently available & spent attribute points.\n");
			sprint( self, 2, "spend - used to spend free attrib points (see above cmd).\n");
			sprint( self, 2, "reset - resets all your attributes and sets them free.\n");
		}
		else
		if (s2 == "ach" || s2 == "achievements")
		{
			sprint( self, 2, "-- Achievements: CMD prefix + command --\n" );
			sprint( self, 2, "Players gain achievements for doing certain\n" );
			sprint( self, 2, "actions (usually killing a monster or helping\n" );
			sprint( self, 2, "out a team-mate), which rewards with a large\n" );
			sprint( self, 2, "exp boost when accomplished.\nCommands:" );
			sprint( self, 2, "ach - prints to you your current achievements (undetailed).\n");
			sprint( self, 2, "ach 1 - prints to everyone your current achievements.\n");
			sprint( self, 2, "ach 2 - prints to you all achievements (detailed).\n");
		}
		else
		if (s2 == "ranks")
		{
			sprint( self, 2, "-- Persistent player and map ranks --\n");
			sprint( self, 2, "Example usage: ??d s???t?p ²° - shows top 20 players.\n");
			sprint( self, 2, "showtop # - shows top players on the server (sorted by exp).\n");
			sprint( self, 2, "showvoted # - shows top voted maps on the server (sorted by vote count).\n");
			sprint( self, 2, "showmaptop - shows the top player time and score for the current map.\n");
		}
		else
		if (s2 == "misc")
		{
			sprint( self, 2, "-- Miscellaneous UBERTF Features --\n");
			sprint( self, 2, "customskin (skinname)> - Allows players to use a custom skin. Contact admin of server to upload yours.\n");
			sprint( self, 2, "res - Resurrects a nearby player for medic class only.\n");
			sprint( self, 2, "beg - Resurrects you if you get disconnected in survival mode.\nDo not use it non-survival mode(penalty applies).\n");
			sprint( self, 2, "powerleft - Shows your invicibility, quad, and invisbility time left.\n");
			sprint (self, 2.000000, "Impulse 120 - Launches an auto turret sentry gun.\n");
			sprint (self, 2.000000, "Impulse 121 - Sprinkles some caltrops if you are Scout, Medic, or Spy. It costs you a type one grenade.\n");
			sprint (self, 2.000000, "Impulse 189 - You eat a can of Pork and beans for a health boost.\n");
			sprint (self, 2.000000, "impulse  67 - Throws a gravity well bomb.\n");
			sprint (self, 2.000000, "impulse  68 - Throws a beartrap.\n");
			sprint (self, 2.000000, "tm - Reports total monsters in map.\n");
			sprint (self, 2.000000, "telem - Teleports to monsters in game. Not players. If there are 10% or more monsters leftm 50 EXP will be subtracted per teleport.\n");
			sprint (self, 2.000000, "ttime - Tells you how much time till the next monster spawn.\n");
			sprint (self, 2.000000, "ts - Total map secrets found so far.\n");
			sprint (self, 2.000000, "nextlvl - How much experience points it takes for the next level gained.\n");
		}
		else
		if (s2 == "vote")
		{
			sprint( self, 2, "-- Vote CMDs --\n");
			sprint( self, 2, "votemap <mapname> - Votes to switch to another map immediately.\n");
			sprint( self, 2, "lockexit - Locks the exit until all players agree to exit the map to prevent accidental exiting.\n");
			sprint( self, 2, "voteexit - Votes to enable the map exit without map completion.\n");
			sprint( self, 2, "voteuse  - Uses the entity immediately in front of the vote starter.\n");
			sprint( self, 2, "votenext - Vote for the next map to be played after someone exits.\n");
			sprint( self, 2, "votemode - Change game mode to Survival for the next played map.\n");
			sprint( self, 2, "votekick <userid> - Kick a user in the game based on userid (cmd pm).\n");
			sprint( self, 2, "There is a minimum ten second interval per user vote.\n However, multiple plyers can start a vote after the first vote succeeds.\n");
			sprint( self, 2, "voteprogs <progsname> - Vote on playing a different version of megatf on the next map.\n");
		}
		else
		if (s2 == "masters")
		{
			sprint( self, 2, "-- Master Skills CMDs --\n");
			sprint( self, 2, "Certain skills are acquired when you have ");
			sprint( self, 2, ftos(#MAX_SPEND));
			sprint( self, 2, " points on any single attribute.\n");
			sprint( self, 2, "aura - req. 7 Health: Heals all nearby players and gives you a bonus. All of medic class players can do this as a skill.\n");
			sprint( self, 2, "call - req. 7 Minion: Teleports your furthest minion to a local point.\n");
			sprint( self, 2, "7 Quick Shot: Lightning Gun replaces the single barrel shotgun.\n");
			sprint( self, 2, "7 Ammo: Engineer can build 2 sentry devices at a time.\n");
		}
		return 1;
	}
	else
	if (s1 == "ach")
	{
		Achievements_Print( stof(s2), self );
	}
	else
	if (s1 == "inv")
	{
		if (self.playerclass == 0)
			return 1;
		if (s2 == "use")
		{
			if ( self.health < 0 )
				return 1;
			if ( Inventory_UseItem( stof(s3) ) == #FALSE )
			{
				sprint( self, 2, "Invalid or unknown item specified.\n" );
				return 1;
			}
		}
		else
		if (s2 == "sell")
		{
			Inventory_SellItem( #SELL_TO_MERCHANT, stof(s3), self, merchant );
		}
		else
		if (s2 != string_null)
		{
			stuffcmd( self, frik_strcat( "cmd inv use ", s2, "\n" ) );
			return 1;
		}
		else
		{
			sprint( self, 2, "Your current inventory:\n");
			sprint( self, 2, "Gold: " );
			sprint( self, 2, ftos( self.#gold ) );
			sprint( self, 2, ".\nMax Carry Limit: ");
			sprint( self, 2, ftos( self.#max_inv) );
			sprint( self, 2, ".\nYour inventory items:\n" );
			Inventory_PrintItems( self.connect_name, #P_TO_SELF );
			return 1;
		}
	}
	else
	if (s1 == "aura")
		Coop_UseMasterSkill( self, #ATTRIB_HEALTH, 0 );
	else
	if (s1 == "call")
		Coop_UseMasterSkill( self, #ATTRIB_MINION, 0 );
	else
	if (s1 == "org")
	{
		sprint(self, 2, vtos(self.origin) );
		sprint(self, 2, "\n");
	}
	else
	if (s1 == "org2")
	{
		bprint(2, "\"origin\" \"");
		bprint(2, ftos(self.origin_x));
		bprint(2, " ");
		bprint(2, ftos(self.origin_y));
		bprint(2, " ");
		bprint(2, ftos(self.origin_z));
		bprint(2, "\"\n");
	}
	else
	if (s1 == "ang")
	{
		sprint(self, 2, vtos(self.angles) );
		sprint(self, 2, "\n");
	}
	else 
	if (s1 == "ang2")
	{
		bprint(2, "\"angles\" \"");
		bprint(2, ftos(self.angles_x));
		bprint(2, " ");
		bprint(2, ftos(self.angles_y));
		bprint(2, " ");
		bprint(2, ftos(self.angles_z));
		bprint(2, "\"\n");
	}
	else
	if (s1 == "tm")
	{
	local entity te;
	local float tm;
	te = find(world, monster_string, "on");
	while (te)
	{
		if (te.health > 0)
		{
			tm = tm + 1;
		}
		te = find(te, monster_string, "on");
	}
	sprint(self, 2,"total spawned monsters: ");
	sprint(self, 2, ftos(tm));
	sprint(self, 2,".\n");
	}
	else
	if (s1 == "tm2")
	{
	te = find(world, monster_string, "on");
	while (te)
	{
		tm = tm + 1;
		te = find(te, monster_string, "on");
	}
	sprint(self, 2,"total monsters: ");
	sprint(self, 2, ftos(tm));
	sprint(self, 2,".\n");
	}
	else
	if (s1 == "savemaptest")
	{
		Changelevel_SaveMapData ();
	}
	else
	if (s1 == "savemaptest2")
	{
		Changelevel_GetMapData ();
	}
	else
	if (s1 == "ts")
	{
		sprint(self, 2,"remaining secrets: ");
		sprint(self, 2, ftos(total_secrets - found_secrets));
		sprint(self, 2,".\n");
	}
	else
	if (s1 == "killpete")
	{
	sprint(self, 2, "Killing Pete the undead monster/head...searching...\n");
	local entity head;
	head = findradius (self.origin, 120);
	if ((head.classname != "player") || (head.classname != "merchant" ) && (head.classname != "world" ) )
	{
		dremove(head); // would 
		sprint(self, 2, "poof!..done.\n");
	}
	}
	else
	if (s1 == "ttime")
	{
		te = find(world, monster_string, "on");
		while (te)
		{
			if (te.health <= 0)
			{
				sprint(self, 2, "A dead monster will respawn in ");
				sprint(self, 2, ftos(te.nextthink - time));
				sprint(self, 2, " seconds.\n");
				te.nextthink = time + 1;
				break;
			}
			te = find(te, monster_string, "on");
		}
	}
	else
	if (s1 == "tent")
	{
		te = nextent(world);
		while (te != world)
		{
			tm+= 1;
			te = nextent(te); 
		}
		sprint(self, 2, "Total entity count: ");
		sprint(self, 2, ftos(tm));
		sprint(self, 2, ".\n");
		if (tm >= 512) 
		{
		sprint(self, 2, "Entities are over 512, bad karma, things will go wrong. Fixing.");
					te = find(world,classname,"monster");
			while (te)
			{
				dremove(te);
				te = find(te,classname,"monster");
			}
		}
		EntityCount(); // call this and see what the xavior count is? -arg
	}
	else
	if (s1 == "pentleft")
	{
		sprint(self, 2, "Invincibility time left: ");
		sprint(self, 2, ftos(self.invincible_finished-time));
		sprint(self, 2, " seconds.\n");
	}	
	else
		if (s1 == "quotes") // Starts random movie quotes in 40 second intervals. Also can be done by setting infokey(world,"moviequotes") in the server.cfg file.
	{
		newmis = spawn();
		newmis.classname = "timer";
		newmis.nextthink = time + 40;
		newmis.think = display_quote;
	}	
	else
	if (s1 == "ringleft" || s1 == "invisleft" )
	{
		sprint(self, 2, "Ring invisibility time left: ");
		sprint(self, 2, ftos(self.invisible_finished-time));
		sprint(self, 2, " seconds.\n");
	}		
	else
	if (s1 == "quadleft")
	{
		sprint(self, 2, "Quad time left: ");
		sprint(self, 2, ftos(self.super_damage_finished-time));
		sprint(self, 2, " seconds.\n");
	}		
	else
	if (s1 == "powerleft")
	{
		sprint(self, 2, "Invincibility time left: ");
		sprint(self, 2, ftos(self.invincible_finished-time));
		sprint(self, 2, " seconds.\n");
		sprint(self, 2, "Quad time left: ");
		sprint(self, 2, ftos(self.super_damage_finished-time));
		sprint(self, 2, " seconds.\n");
		sprint(self, 2, "Ring invisibility time left: ");
		sprint(self, 2, ftos(self.invisible_finished-time));
		sprint(self, 2, " seconds.\n");
	}
	else
#ifdef hats
	if (s1 == "hatsoff")
	{
		setmodel(self.hat, string_null);
		sprint(self,2, "Hat display disabled.\n		Use CMD hatson to re-enable.\n");
		return 1;
	}
	else
	if (s1 == "hatson")
	{
		setmodel(self.hat, #HAT_MODEL);
		sprint(self,2, "Hat display enabled.\n		Use CMD hatsoff to disable hat display.\n");
		return 1;
	}
	else
#endif
	if (s1 == "sendpacket")
	{
//		QC_SendPacket(s2, "fewwww \n\n\n asf\n");  // disabled until there are more servers- arg
		return 1;
	}
	else
	if (s1 == "fixmon")
	{
		return 1;  // Code was removed, didn't work and is not needed.
	}
	else
	if (s1 == "entinf")
	{
		DisplayUseEntity (self);
	}
	else
	if (s1 == "findclassname")
	{
		FindEntsWithClassname ( s2 );
	}
	else
	if (s1 == "uncrouch")
	{
		stuffcmd(self, "say hl_crouch1_off\n");
	}
	else
	if (s1 == "setorg")
	{
		self.origin_x = stof(s2);
		self.origin_y = stof(s3);
		self.origin_z = stof(s4);
	}
	else
	if (s1 == "meh")
	{
		bprint(2, frik_strcat(vtos(self.view_ofs), " yeah.\n" ));
		bprint(2, frik_strcat(vtos(self.mins), vtos(self.maxs), " yeah.\n" ));
	}
	else
	if (s1 == "telem")
	{
//Search for a live monster in the world. -arg
	te = find(world, monster_string, "on");
	while (te)
	{
		if (te.health > 0)
		{
			self.origin = te.origin;
//TODO:perhaps move the player neat the monster and that way you are not stuck inside them? But not teleport into a wall or below the floor..			
//If monster count is less than 10% planned to spawn don't punish the players with -50 exp.
//calc punishemnt or not:
			return 1;
		}
		te = find(te, monster_string, "on");
	}
	bprint(2, ftos(tm));
	bprint(2,"\n");
	}
	else
	if (s1 == "nextlvl")
	{
		sprint( self, 2, "You need " );
		sprint( self, 2, ftos( Coop_ExpForNextLevel(self.coop_exp) ) );
		sprint( self, 2, " more exp for your next level.\n" );
		return 1;
	}
	else
	if (s1 == "showexp" || s1 == "exp")
	{
		sprint( self, 2, "You have " );
		sprint( self, 2, ftos(self.coop_exp));
		sprint( self, 2, " experience points.\n");
		return 1;
	}
	else
	if (s1 == "sayexp")
	{
		stuffcmd( self, "say I have " );
		stuffcmd( self, ftos(self.coop_exp));
		stuffcmd( self, " experience points!\n");
		return 1;
	}
	else
	if (s1 == "sayattrib")
	{
		stuffcmd( self, "say My attributes are:\n");
		stuffcmd( self, "say Health: ");
		stuffcmd( self, ftos(self.health_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Armor: ");
		stuffcmd( self, ftos(self.armor_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Rage: ");
		stuffcmd( self, ftos(self.damage_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Ammo: ");
		stuffcmd( self, ftos(self.ammo_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Crit. Strike: ");
		stuffcmd( self, ftos(self.crit_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Quick Reload: ");
		stuffcmd( self, ftos(self.reload_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Minion Summon: ");
		stuffcmd( self, ftos(self.minion_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Quick Shot: ");
		stuffcmd( self, ftos(self.quickshot_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Clip Extension: ");
		stuffcmd( self, ftos(self.clipex_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Projectile Speed: ");
		stuffcmd( self, ftos(self.proj_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Misc: ");
		stuffcmd( self, ftos(self.misc_attr));
		stuffcmd( self, ", ");
		stuffcmd( self, "Free: ");
		stuffcmd( self, ftos(self.attribute_points));
		stuffcmd( self, "\n");
		return 1;
	}
	else
	if (s1 == "reset")
	{
		Coop_ResetAttributes ( self );
		sprint ( self, 2, "Your attributes have been reset.\n" );
		ClientKill();
		TF_T_Damage (self, self, self, 999, 2, 8);
	}
	else
	if (s1 == "dfob")
	{
	sprint ( self, 2, "Player color fob marker for your team disabled.\n" );
	self.is_fob_disabled = 1;		//This sets the colored playerfob like the spy feign for those who find it annoying. -arg
	}
	else
	if (s1 == "efob")
	{
	sprint ( self, 2, "Player color fob marker for your team enabled.\n" );
	self.is_fob_disabled = 0 ;		//This sets the colored playerfob like the spy feign for those who find it annoying. -arg
	}
	else
	if (s1 == "summon")
	{
		MTF_Coop_SummonMinion ();
	}
	else
	if (s1 == "customskin")
	{
		MTF_Coop_SetCustomSkin(self, s2);
	}
	else
	if (s1 == "getexp")
	{
		if (!s2 || s2 == "")
		{
			sprint(self, 2, "Invalid usage. Please use: CMD getexp name.\n");
			return 1;
		}
		fl = MTF_Coop_GetUserExperience (s2);
		if (fl == -1)
		{
			sprint(self, 2, "Specified user account does not exist on this server.\n");
			return 1;
		}
		else
		{
			sprint(self, 2, s2);
			sprint(self, 2, " has ");
			sprint(self, 2, ftos(fl));
			sprint(self, 2, " exp.\n");
			return 1;
		}
	}
	else
	if (s1 == "saymhp")
	{
		stuffcmd( self, "say I have " );
		stuffcmd( self, ftos(self.max_health));
		stuffcmd( self, " max hp!\n");
		return 1;
	}
	else
	if (s1 == "showtop")
	{
		MTF_Coop_ViewTopRanks ( stof(s2) );
		return 1;
	}
	else
	if (s1 == "showvoted")
	{
		MTF_Coop_ViewVoteTopRanks ( stof(s2) );
		return 1;
	}
	else
	if (s1 == "beg")
	{
	if ((self.deadflag) && survival_mode) //For survival mode and dead in a ditch, under slime, not disintegrating, or out of map area, can't be reached by other players -arg
	{
		sprint(self, 2, self.netname);
		sprint(self, 2, " begs for forgiveness from dropping connection, and is resurrected.\n");
		self.ammo_cells = 666; // set to respawn at beginning -arg
		MTF_Resurrect_Player (self);
		return 1;
	}
	if (!(self.deadflag) && survival_mode)	//For survival modem and not dead, just move them back to start, for example to get around a shut door at the middle and you need to go back to start. -arg
	//Or you left your engineer builds at spawn start, and need them, and you can't get ammo where you are shut behind a one way door/tunnel/wind tunnel. -arg
	{
		sprint(self, 2, self.netname);
		sprint(self, 2, " asked to be moved to the start of the map in survival mode. Done.\n");
		self.ammo_cells = 666;	// set to respawn at beginning -arg
		spawn_tfog (self.origin);	//wink them out -arg
		PutClientInServer();	//wink them back in without killing them and ending survival mode if they are the only player. -arg :}
		return 1;
	}
	else
	{
	sprint(self, 2, self.netname);	//Not in survival mode and being a jerk. -arg
	sprint(self, 2, " was alive. The server killed him and respawned him for being a wuss begging to leave combat. -6 points. Only use this in survival mode.\n");
	self.real_frags = self.real_frags - (TF_FLARE_OFF *5 ); // The player should just kill instead. I had to code this in to deal with users using cmd beg in non survival and not dead states. So be it. -arg
	ClientKill();
	respawn();
		return 1;
	}
	}
	else
	if (s1 == "saymdl")
	{
		bprint(2,self.model);
		bprint(2," is my model and ");
		bprint(2,ftos(self.modelindex));
		bprint(2," is my modelindex.\n");
		return 1;
	}
	else
	if (s1 == "showmaptop")
	{
		MTF_Coop_ViewTopMapRanks ();
		return 1;
	}
	else
	if (s1 == "attrib")
	{
		MTF_Coop_ShowAttrib ();
	}
	else
	if (s1 == "spend")
	{
		MTF_Coop_SpendAttrib ( stof(s2) );
	}
	else
	if (s1 == "expedit")
	{
		rconpw = infokey (world, "rcon_password");
		if (s2 != rconpw || !rconpw)
		{
			sprint(self, 2, "You have no access to this function.\n");
			return 1;
		}
		else
		{
			if (s3 == "exse")
			{
				if (!s4 || !s5 || s4 == "" || s5 == "")
				{
					sprint(self, 2, "Invalid user or parameters.\n");
					return 1;
				}
				sprint(self, 2, s4);
				sprint(self, 2, "'s experience points are set to ");
				sprint(self, 2, s5);
				sprint(self, 2, " .\n");
				MTF_Coop_ForceWriteExperience( s4, stof(s5) );
				if (s6 != "")
					MTF_Coop_WriteNewRank( stof(s6), s4, stof(s5));
				return 1;
			}
			else
			if (s3 == "prune_top10")
			{
				file = open ("topranks.tfi", 2);
				fl = 0;
				while (fl < 10)
				{
					write( file, "nobody\n" );
					write( file, ftos(10 - fl) );
					write( file, "\n" );
					fl += 1;
				}
				close(file);
				return 1;
			}
			local float getid;
			getid = stof(s3);
			te = find(world,classname,"player");
			while (te)
			{
				if (te.userid == getid)
				{
					if (s4 == "" || !s4)
					{
						sprint(self, 2, "Usage: cmd expedit password userid# ra/sa/se/pse amount# .\n");
						sprint(self, 2, "ra = reset all attributes to 0.\n");
						sprint(self, 2, "sa = set free attributes.\n");
						sprint(self, 2, "se = set experience points.\n");
						sprint(self, 2, "pse = set exp & showtop position to last.\n");
						return 1;
					}
					else
					{
						if (s4 == "ra")
						{
							Coop_ResetAttributes ( te );
							sprint(self, 2, te.netname);
							sprint(self, 2, "'s attribute points have been reset - tell this user to reconnect.\n");
							MTF_Coop_PreWriteExperience( te, te.connect_name, te.coop_exp );
						}
						else
						if (s4 == "sa")
						{
							sprint(self, 2, te.netname);
							sprint(self, 2, "'s free attribute points are set to ");
							sprint(self, 2, s5);
							sprint(self, 2, " from ");
							sprint(self, 2, ftos(te.attribute_points));
							sprint(self, 2, ".\n");
							te.attribute_points = stof(s5);
							MTF_Coop_PreWriteExperience( te, te.connect_name, te.coop_exp );
						}
						else
						if (s4 == "se")
						{
							sprint(self, 2, te.netname);
							sprint(self, 2, "'s experience points are set to ");
							sprint(self, 2, s5);
							sprint(self, 2, " from ");
							sprint(self, 2, ftos(te.coop_exp));
							sprint(self, 2, ".\n");
							te.coop_exp = stof(s5);
							MTF_Coop_PreWriteExperience( te, te.connect_name, te.coop_exp );
						}
						else
						if (s4 == "pse")
						{
							sprint(self, 2, te.netname);
							sprint(self, 2, "'s experience points are set to ");
							sprint(self, 2, s5);
							sprint(self, 2, " from ");
							sprint(self, 2, ftos(te.coop_exp));
							sprint(self, 2, ".\n");
							te.coop_exp = stof(s5);
							MTF_Coop_PreWriteExperience( te, te.connect_name, te.coop_exp );
							MTF_Coop_WriteNewRank( #MAX_RANKS + 1, s4, stof(s5));
						}
						else
						if (s4 == "sg")
						{
							sprint(self, 2, te.netname);
							sprint(self, 2, "'s gold is set to ");
							sprint(self, 2, s5);
							sprint(self, 2, " from ");
							sprint(self, 2, ftos(te.gold));
							sprint(self, 2, ".\n");
							Inventory_AddGold( te, -1 * te.gold );	// subtract all the player's gold..
							Inventory_AddGold( te, stof(s5) );		// now set the gold to whatever's specified..
						}
					}
					return 1;
				}
				te = find(te,classname,"player");
			}
			sprint (self, 2.000000, "User not found. Please choose a userid from this list:\n");
			pm_list ();
			return 1;
		}
	}
	else
	if (s1 == "vwi")
	{
			sprint(self, 2, "List of current VW indeces:\n");
			te = find(world,classname,"player");
			while (te)
			{
				sprint(self, 2, te.connect_name);
				sprint(self, 2, " - ");
				sprint(self, 2, ftos(te.vw_index));
				sprint(self, 2, ".\n");
				te = find(te,classname,"player");
			}
	}
	else
	if (s1 == "gvf")
	{
			sprint( self, 2, "Resulting value:\n" );
			sprint( self, 2, TFI_GetValueFor(s2, s3, stof(s4), s5) );
			sprint( self, 2, ".\n" );
	}
#ifdef DEBUG
	else
	if (s1 == "omg")
	{
		bprint(2, ftos(illegalclasses));
		bprint(2, " are ILLEGAL.\n");
		bprint(2, ftos(illegalclasses2));
		bprint(2, " are CLASS ILLEGAL.\n");
	}
#endif
	else
	if (s1 == "voteyes")
	{
		voteyes ();
	}
	else
	if (s1 == "votenext" || s1 == "votenextmap")
	{
		if (s2 == "hippos")
		{
			if (num_players < 300)
			{
				sprint(self, 2, "More players are required to initiate this vote.\n");
				return 1;
			}
		}
		Vote_StartVote( #VOTE_NEXTMAP, s2, world );
	}
//	else
// if (s1 == "voteprogs")   // This is for non-coop mode, not sure how to rework -arg
//		Vote_StartVote( #VOTE_PROGS, s2, world );
	else
	if (s1 == "voteexit")
		Vote_StartVote( #VOTE_EXIT, "", world );
	else
	if (s1 == "voteuse")
		Vote_StartVote( #VOTE_USE, "", world );
	else
	if (s1 == "votekick")
		Vote_StartVote( #VOTE_KICK, s2, world );
	else
	if (s1 == "votemode")
		Vote_StartVote( #VOTE_SURVIVAL_NEXT, "", world );
	else
	if (s1 == "res")
	{
		MTF_Resurrect_Player_Find();
	}
	else
	if (s1 == "eh")
	{
		bprint(2, "well lets see.. \n");
		if (self.flags & #FL_FINDABLE_NONSOLID)
		{
			bprint(2, "thou art findable ");
			bprint(2, ".\n");
		}
	}
	else
	if (s1 == "sayl")
	{
		stuffcmd( self, "say I'm at " );
		stuffcmd( self, ftos(self.lastruntime));
		stuffcmd( self, " seconds!\n");
		return 1;
	}
	else
		return 0;
};
void (float playerid, float item_slot, float item_price) Inventory_TradeItem =
{
	local entity te, tchk;
	local float userfound, item_type;
	if (self.classname != "player")
	{
		bprint(self, "You need to join to trade\n");
		return;
	}
	te = find(world,classname,"player");
	while (te)
	{
		if (te.userid == playerid)
		{
			userfound = 1;
			break;
		}
		te = find(te,classname,"player");
	}
	if (te == self)
	{
		sprint(self,2, "You cannot trade with yourself, Doc.\n");
		return;
	}
	if (!userfound)
	{
		sprint(self,2, "User not found. Use CMD trade userid# slot# price#.\n");
		pm_list ();
		return;
	}
	tchk = find(world,classname,"trade_ref");
	while (tchk)
	{
		if (tchk.enemy == te || tchk.owner == te)
		{
			sprint(self, 2, te.netname);
			sprint(self, 2, " is already in a trade.\n");
			return;
		}
		if (tchk.enemy == self || tchk.owner == self)
		{
			sprint(self, 2, "You are already in a trade with someone.\n");
			return;
		}
		tchk = find(tchk,classname,"trade_ref");
	}
	item_type = Inventory_GetItem ( self.connect_name, item_slot, #RETURN_ITEM_NO );
	if (!item_type)
	{
		sprint( self, 2, "Invalid item to sell.\n" );
		return;
	}
	if (item_price < 0 || item_price > 1000000)
	{
		sprint( self, 2, "Invalid item price.\n" );
		return;
	}
	if (te.gold < item_price)
	{
		sprint(self, 2, "Cannot trade with that player.\n");
	}
	newmis = spawn();
	newmis.owner = self;			// this is who started the trade
	newmis.enemy = te;				// this is who is being traded with
	newmis.health = item_price;		// the price the item is being sold for
	newmis.armorvalue = item_type;	// name of item
	newmis.playerclass = item_slot;	// item slot where the item is located for the seller
	newmis.classname = "trade_ref";
	newmis.think = TradeThink;
	newmis.nextthink = time + 60;	// offer expires in 60 seconds
	sprint(self, 2, "Your request to sell your ");
	sprint(self, 2, Inventory_GetItemName(item_type));
	sprint(self, 2, " for ");
	sprint(self, 2, ftos(item_price));
	sprint(self, 2, " gold has been sent to ");
	sprint(self, 2, te.netname);
	sprint(self, 2, ".\n");
	sprint(te, 2, self.netname);
	sprint(te, 2, " wants to sell you a ");
	sprint(te, 2, Inventory_GetItemName(item_type));
	sprint(te, 2, " for ");
	sprint(te, 2, ftos(item_price));
	sprint(te, 2, " gold.\n");
	sprint(te, 2, "Type \"CMD accept\" to accept the offer. Type \"CMD decline\" to decline.\n");
};
void() walkmonster_start = 
{
	if (self.nextthink < time && self.nextthink != 0)
	{
		bprint(2,"walkmonster_start: something with nextthink is a little screwy here.\n");
		self.nextthink = time;
	}
	self.nextthink = self.nextthink + random() * 0.5;
	self.think = walkmonster_start_go;
	if (!self.takedamage && self.health > 0)
	{
		self.takedamage = 2;
	}
	set_monster_health();
};
void() item_megahealth_rot = 
{
	other = self.owner;
	if (other.health > other.max_health)
	{
		other.health = other.health - TF_FLARE_OFF;
		self.nextthink = time + TF_FLARE_OFF;
		return;
	}
	other.items = other.items - (other.items & 65536);
	if (self.classname == "medikit_rot")
	{
		dremove(self);
		return;
	}
	if (deathmatch != 2)
	{
		self.nextthink = time + 20;
		self.think = SUB_regen;
	}
};
void() walkmonster_start_go = 
{
	self.origin_z = self.origin_z + TF_FLARE_OFF;
	droptofloor(0, 0);
	if (!walkmove(TF_FLARE_LIT, TF_FLARE_LIT))
	{
		dprint("walkmonster in wall at: ");
		dprint(vtos(self.origin));
		dprint("\n");
	}
	self.takedamage = 2;
	self.ideal_yaw = self.angles * '0 1 0';
	if (!(self.yaw_speed))
	{
		self.yaw_speed = 20;
	}
	self.view_ofs = '0 0 16';
	self.use = monster_use;
	self.flags = self.flags | 32;
	if (self.#is_minion == 1)
	{
		self.th_walk();
		self.nextthink = self.nextthink + random() * 0.5;
		return;
	}
	if (self.target)
	{
		self.goalentity = self.movetarget = find(world, targetname, self.target);
		self.ideal_yaw = vectoyaw(self.goalentity.origin - self.origin);
		if (!(self.movetarget))
		{
			dprint("Monster can't find target at ");
			dprint(vtos(self.origin));
			dprint("\n");
		}
		if (self.movetarget.classname == "path_corner")
		{
			self.th_walk();
		}
		else
		{
			self.pausetime = 100000000;
		}
		self.th_stand();
	}
	else
	{
		self.pausetime = 100000000;
		self.th_stand();
	}
	self.nextthink = self.nextthink + random() * 0.5;
};
void() set_monster_health = 
{
	skill = cvar("skill");
	if (skill > 2)
	{
		skill = 3;
	}
};
void() monster_use = 
{
	if (self.enemy)
	{
		return;
	}
	if (self.health <= TF_FLARE_LIT)
	{
		return;
	}
	if (activator.items & 524288)
	{
		return;
	}
	if (activator.flags & 128)
	{
		return;
	}
	if (activator.classname != "player" && activator.classname != "bot")
	{
		return;
	}
	if (activator.team_no == self.team_no)
	{
		self.enemy = world;
		return;
	}
	self.enemy = activator;
	self.nextthink = time + 0.1;
	self.think = FoundTarget;
};
void() FoundTarget = 
{
	if (IsBuilding(self.enemy) || self.enemy.classname == "player" || self.enemy.classname == "bot" || self.enemy.classname == "monster_dog" || self.enemy.classname == "monster_fish" || Coop_Attackable(self.enemy) == #TRUE || self.enemy.classname == "func_monstergoal")
	{
		sight_entity = self;
		sight_entity_time = time;
	}
	self.show_hostile = time + TF_FLARE_OFF;
	SightSound();
	if (self.enemy.playerclass == 8 && self.enemy.#spy_visible_time < time) // spy..
	{
		self.enemy.#spy_visible_time = time + 2;
	}
	HuntTarget();
};
void() SightSound = 
{
#ifndef mtf_coop_halflife
	if (cvar("sv_map_halflife") == 1)
	{
		if (self.classname == "monster_guard")
			sound (self, CHAN_VOICE, "001.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_officer")
			sound (self, CHAN_VOICE, "071.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_ss")
			sound (self, CHAN_VOICE, "015.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_dog")
			sound (self, CHAN_VOICE, "002.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_boss")
			sound (self, CHAN_VOICE, "017.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_gretel")
			sound (self, CHAN_VOICE, "112.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_gift")
			sound (self, CHAN_VOICE, "096.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_fat")
			sound (self, CHAN_VOICE, "102.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_schabbs")
			sound (self, CHAN_VOICE, "065.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_fake")
			sound (self, CHAN_VOICE, "054.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_mecha")
			sound (self, CHAN_VOICE, "040.wav", 1, ATTN_NORM);
		else
		if (self.classname == "monster_hitler")
			sound (self, CHAN_VOICE, "040.wav", 1, ATTN_NORM);
	}
#endif
	local float rsnd;
	if (self.classname == "monster_ogre")
	{
		sound(self, 2, "ogre/ogwake.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	}
	else
	{
		if (self.classname == "monster_knight")
		{
			sound(self, 2, "knight/ksight.wav", TF_FLARE_OFF, TF_FLARE_OFF);
		}
		else
		{
			if (self.classname == "monster_shambler")
			{
				sound(self, 2, "shambler/ssight.wav", TF_FLARE_OFF, TF_FLARE_OFF);
			}
			else
			{
				if (self.classname == "monster_demon1")
				{
					sound(self, 2, "demon/sight2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
				}
				else
				{
					if (self.classname == "monster_wizard")
					{
						sound(self, 2, "wizard/wsight.wav", TF_FLARE_OFF, TF_FLARE_OFF);
					}
					else
					{
						if (self.classname == "monster_zombie")
						{
#ifdef decemberween
							sound(self, 2, "zombie/snowman_sight.wav", TF_FLARE_OFF, TF_FLARE_OFF);
#else
							sound(self, 2, "zombie/z_idle.wav", TF_FLARE_OFF, TF_FLARE_OFF);
#endif
						}
						else
						{
							if (self.classname == "monster_dog")
							{
								sound(self, 2, "dog/dsight.wav", TF_FLARE_OFF, TF_FLARE_OFF);
							}
							else
							{
								if (self.classname == "monster_hell_knight")
								{
									sound(self, 2, "hknight/sight1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
								}
								else
								{
									if (self.classname == "monster_tarbaby")
									{
										sound(self, 2, "blob/sight1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
									}
									else
									{
										if (self.classname == "monster_vomit")
										{
											sound(self, 2, "blob/sight1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
										}
										else
										{
											if (self.classname == "monster_enforcer")
											{
												rsnd = rint(random() * 3);
												if (rsnd == TF_FLARE_OFF)
												{
													sound(self, 2, "enforcer/sight1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
												}
												else
												{
													if (rsnd == 2)
													{
														sound(self, 2, "enforcer/sight2.wav", TF_FLARE_OFF, TF_FLARE_OFF);
													}
													else
													{
														if (rsnd == TF_FLARE_LIT)
														{
															sound(self, 2, "enforcer/sight3.wav", TF_FLARE_OFF, TF_FLARE_OFF);
														}
														else
														{
															sound(self, 2, "enforcer/sight4.wav", TF_FLARE_OFF, TF_FLARE_OFF);
														}
													}
												}
											}
											else
											{
												if (self.classname == "monster_army")
												{
													sound(self, 2, "soldier/sight1.wav", TF_FLARE_OFF, TF_FLARE_OFF);
												}
												else
												{
													if (self.classname == "monster_shalrath")
													{
														sound(self, 2, "shalrath/sight.wav", TF_FLARE_OFF, TF_FLARE_OFF);
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
void() HuntTarget = 
{
	self.goalentity = self.enemy;
	self.think = self.th_run;
	self.ideal_yaw = vectoyaw(self.enemy.origin - self.origin);
	self.nextthink = time + 0.1;
	SUB_AttackFinished(TF_FLARE_OFF);
};
void () respawn_think =
{
	local entity head;
	if (self.classname == "monster_azoth")
		return;
	head = findradius (self.origin, 56);
	while (head)
	{
		if (head.takedamage && head.health > 0)
		{
			if (head.is_monster == 1)
			{
				head.deathtype = "monster_respawn";
				head.health = -60;
				Killed(head, self);
			}
			else
			if (head.classname == "player")
			{
				self.nextthink = time + 5;
				return;
			}
			else 
			if (head.th_die)
			{
				head.deathtype = "monster_respawn";
				head.health = -60;
				Killed(head, self);
			}
			else
			{
				if (self.invisible_finished < 3)
				{
					self.nextthink = time + 5;
					self.think = respawn_think;
					self.invisible_finished = self.invisible_finished + 1;
					return;
				}
				else
				{
					if (!self.th_die)
					{
						dprint("A monster tried to respawn and die without a death function!\nClassname :");
						dprint(self.classname);
						dprint(" and Netname: ");
						dprint( self.netname );
						dprint( "\n" );
					}
					else
					{
						self.flags = self.flags | FL_MONSTER;
						self.deathtype = "monster_respawn";
						self.health = -60;
						Killed (self, world);
						return;
					}
				}
			}
		}
		head = head.chain;
	}
	respawn_monster ();
};
void () respawn_monster =
{
	local float savedlives;
	self.touch = SUB_Null;
	if (self.old_owner != world)
		dremove(self.old_owner);
	spawn_tfog (self.origin);
	savedlives = self.lives;
	if (!self.think1)
	{
		bprint(2,"DEV: Do not try to summmon that type of monster.\n");
		dremove(self);
		return; //not sure to return or let it crash. defined InSolid as a fix here? -arg 
	}
	self.think1 ();
	self.lives = savedlives;
	if (InSolid(self))
	{
		// this is kind of like a hack, but it works to ensure monster count is bumped
		self.flags = self.flags | FL_MONSTER;
		self.deathtype = "monster_respawn";
		self.health = -60;
		Killed (self, world);
	}
};
void () attachplayerfob =
{
local entity playerfob;
	playerfob = spawn();
	playerfob.classname = "player_teamfob";
	playerfob.playerclass = self.playerclass; //so spies can have the fob removed
	playerfob.owner = self;
	playerfob.real_owner = self;
	playerfob.health = 999;
	playerfob.th_die = removeplayerfob;
	playerfob.armorvalue = time + playerfob.health;
	playerfob.think = playerfob_think;
	playerfob.nextthink = time + .1;
	playerfob.velocity = self.velocity; // move at the same rate as player. ?
	playerfob.team_no = self.team_no; //Same team number as the player -arg
	playerfob.origin = self.origin + '0 0 75'; //put fob above the player.
	playerfob.touch = SUB_Null; // it does nothing, if touched.
	self.playerfob_target = self; // for following with beartrap logic code.
	setmodel (playerfob, "progs/thedot.spr");
	playerfob.frame = self.team_no - 1; //color fob dot same as player's team color. except green team is a purple dot. go figure. maybe a new sprite someday. -arg
	//Updated 11/2/2020 the new model thedot.spr replaces the old newdot.spr from mega coop/classic from xavior. -arg
//end playerfob added -arg
};
void () playerfob_think =
{
    local float fls;
    local vector endp;
    if (self.owner.is_undercover)
    {
    self.frame = self.owner.undercover_team - 1; //the selected color undercover -arg
    self.nextthink = time + .01;
    }
	else
    {
	self.frame = self.owner.team_no -1;
    }
    if (self.owner.owner != self.real_owner)  //from summon_think for goalie. -arg
    {
        self.owner.owner = self.real_owner;
    }
    fls = self.owner.maxs_z * 1;
    endp = self.owner.origin;
    endp_z += fls;
//move with player. -arg
    if (self.origin != self.playerfob_target.origin || self.angles != self.owner.angles)
    {
        setorigin (self, (self.playerfob_target.origin));
    }
    if (self.angles != self.owner.angles) //follow in 3D space like the beartrap :} -arg
    {
            self.angles = self.owner.angles;
    }
        self.orig_origin = endp;
    if (self.owner.is_feigning || self.owner.is_fob_disabled)
    {
    setorigin (self, (endp + ' 900 900 950'));
    self.nextthink = time + 1;
    return;
    }
    if (self.owner.invisible_finished > time)
    {
        setorigin(self, (endp + ' 900 900 950'));
        self.nextthink = time + 1;
        return;
    }
    setorigin(self, endp);
    self.nextthink = time + .01;
};
void () removeplayerfob =
{
	dremove(self);
};
float (entity Top, entity bottom) IsOnTopOf; // from neh_defsfuncs.qc -arg for marioworld maps agent.
//.void() hl_use;				// half-life 1 Use properties for marioworld maps. -arg
//.vector rendercolor;		// from half life 1, for marioworld maps. -arg 
//.float rendermode;			// from half life 1, for marioworld maps. -arg 
//.float renderamt;			// from half life 1, for marioworld maps. -arg 
//.float buoyancy;			// for func_pushable hl for marioworld agent maps.
//.float material;			// from half life 1, for marioworld maps. -arg 
//.float spawnobject;			// spawn object on destruction
//#include "mega_coop/mega_halflife/hl_breakable.qc" //includes for marioworld maps for agent.
//#include "mega_coop/mega_halflife/hl_pushable.qc" // from half life 1, for marioworld maps. -arg 
void() NailGrenadeTouch = 
{
	if (other == self.owner)
	{
		return;
	}
	sound(self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if (self.velocity == '0 0 0')
	{
		self.avelocity = '0 0 0';
	}
};

//END