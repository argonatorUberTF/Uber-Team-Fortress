void() train_next;
void() func_train_find;
void() plat_center_touch;
void() plat_outside_touch;
void() plat_trigger_use;
void() plat_go_up;
void() plat_go_down;
void() plat_crush;

void() plat_spawn_inside_trigger = 
{
	local entity trigger;
	local vector tmin;
	local vector tmax;
	trigger = spawn();
	trigger.touch = plat_center_touch;
	trigger.movetype = 0;
	trigger.solid = 1;
	trigger.enemy = self;
	trigger.team_no = self.team_no;
	trigger.playerclass = self.playerclass;
	trigger.items_allowed = self.items_allowed;
	trigger.activate_goal_no = self.activate_goal_no;
	trigger.inactivate_goal_no = self.inactivate_goal_no;
	trigger.remove_goal_no = self.remove_goal_no;
	trigger.restore_goal_no = self.restore_goal_no;
	trigger.activate_group_no = self.activate_group_no;
	trigger.inactivate_group_no = self.inactivate_group_no;
	trigger.remove_group_no = self.remove_group_no;
	trigger.restore_group_no = self.restore_group_no;
	trigger.goal_activation = self.goal_activation;
	trigger.goal_effects = self.goal_effects;
	trigger.goal_result = self.goal_result;
	trigger.goal_group = self.goal_group;
	tmin = self.mins + '25 25 0';
	tmax = self.maxs - '25 25 -8';
	tmin_z = tmax_z - (self.pos1_z - self.pos2_z + 8);
	if (self.spawnflags & 1)
	{
		tmax_z = tmin_z + 8;
	}
	if (self.size_x <= 50)
	{
		tmin_x = (self.mins_x + self.maxs_x) / 2;
		tmax_x = tmin_x + 1;
	}
	if (self.size_y <= 50)
	{
		tmin_y = (self.mins_y + self.maxs_y) / 2;
		tmax_y = tmin_y + 1;
	}
	setsize(trigger, tmin, tmax);
};

void() plat_hit_top = 
{
	sound(self, 2, self.noise1, 1, 1);
	self.state = 0;
	self.think = plat_go_down;
	self.nextthink = self.ltime + 3;
};

void() plat_hit_bottom = 
{
	sound(self, 2, self.noise1, 1, 1);
	self.state = 1;
};

void() plat_go_down = 
{
	sound(self, 2, self.noise, 1, 1);
	self.state = 3;
	SUB_CalcMove(self.pos2, self.speed, plat_hit_bottom);
};

void() plat_go_up = 
{
	sound(self, 2, self.noise, 1, 1);
	self.state = 2;
	SUB_CalcMove(self.pos1, self.speed, plat_hit_top);
};

void() plat_center_touch = 
{
	local entity te;
	if (other.classname != "player")
	{
		return;
	}
#ifdef botprogs
	if (other.ishuman == 2 || other.ishuman == 0)		// avirox'd!
	{
		if (self.enemy.state != 1 && other.cooldown < time && other.groundentity.classname != "plat")
		{
			other.cooldown = time + .3;
			other.curr_wp = other.curr_wp - 1;
		}
	}
#endif
	if (!Activated(self, other))
	{
		if (self.else_goal != 0)
		{
			te = Findgoal(self.else_goal);
			if (te)
			{
				DoResults(te, other, self.goal_result & 2);
			}
		}
		return;
	}
	if (other.health <= 0)
	{
		return;
	}
	self = self.enemy;
	if (self.state == 1)
	{
		plat_go_up();
	}
	else
	{
		if (self.state == 0)
		{
			self.nextthink = self.ltime + 1;
		}
	}
};

void() plat_outside_touch = 
{
	local entity te;
	if (other.classname != "player")
	{
		return;
	}
	if (!Activated(self, other))
	{
		if (self.else_goal != 0)
		{
			te = Findgoal(self.else_goal);
			if (te)
			{
				DoResults(te, other, self.goal_result & 2);
			}
		}
		return;
	}
	if (other.health <= 0)
	{
		return;
	}
	self = self.enemy;
	if (self.state == 0)
	{
		plat_go_down();
	}
};

void() plat_trigger_use = 
{
	if (self.think)
	{
		return;
	}
	plat_go_down();
};

void() plat_crush = 
{
#ifdef mtf_coop
	if (other.is_monster == 1)
		T_Damage(other, self, self, 100);
	else
#endif
	T_Damage(other, self, self, 1);
	if (self.state == 2)
	{
		plat_go_down();
	}
	else
	{
		if (self.state == 3)
		{
			plat_go_up();
		}
		else
		{
			self.state = 3;
			plat_go_up();
		}
	}
};

void() plat_use = 
{
	self.use = SUB_Null;
	if (self.state != 2)
	{
		objerror("plat_use: not in up state");
	}
	plat_go_down();
};

void() func_plat = 
{
	if (CheckExistence() == 0)
	{
		dremove(self);
		return;
	}
	if (!(self.t_length))
	{
		self.t_length = 80;
	}
	if (!(self.t_width))
	{
		self.t_width = 10;
	}
	if (self.sounds == 0)
	{
		self.sounds = 2;
	}
	if (self.sounds == 1)
	{
		precache_sound("plats/plat1.wav");
		precache_sound("plats/plat2.wav");
		self.noise = "plats/plat1.wav";
		self.noise1 = "plats/plat2.wav";
	}
	if (self.sounds == 2)
	{
		precache_sound("plats/medplat1.wav");
		precache_sound("plats/medplat2.wav");
		self.noise = "plats/medplat1.wav";
		self.noise1 = "plats/medplat2.wav";
	}
	if (self.sounds == 4)
	{
		precache_sound("plats/track_st.wav");
		precache_sound("plats/track_e.wav");
		self.noise = "plats/track_st.wav";
		self.noise1 = "plats/track_e.wav";
	}
	self.mangle = self.angles;
	self.angles = '0 0 0';
	self.classname = "plat";
	self.solid = 4;
	self.movetype = 7;
	setorigin(self, self.origin);
	setmodel(self, self.model);
	setsize(self, self.mins, self.maxs);
	self.blocked = plat_crush;
	if (!(self.speed))
	{
		self.speed = 150;
	}
	self.pos1 = self.origin;
	self.pos2 = self.origin;
	if (self.height)
	{
		self.pos2_z = self.origin_z - self.height;
	}
	else
	{
		self.pos2_z = self.origin_z - self.size_z + 8;
	}
	self.use = plat_trigger_use;
	plat_spawn_inside_trigger();
	if (self.targetname)
	{
		self.state = 2;
		self.use = plat_use;
	}
	else
	{
		setorigin(self, self.pos2);
		self.state = 1;
	}
};

#define TRAIN_RETRIGGER		1 //johnfitz -- retriggerable trains

void() train_blocked = 
{
	if (time < self.attack_finished)
	{
		return;
	}
	self.attack_finished = time + 0.5;
	T_Damage(other, self, self, self.dmg);
};

void() train_use = 
{
#ifdef mtf_coop
	//johnfitz -- retriggerable trains
	if (self.spawnflags & TRAIN_RETRIGGER) {
		train_next();
		return;
	}
#endif
	if (self.think != func_train_find)
	{
		return;
	}
#ifdef mtf_coop_halflife
	if (#HL_MAP) {
		if (self.target == "waterpath2" || self.targetname == "water_door_move3") {
			self.solid = 1;
		}
	}
	self.has_tesla = 0;
#endif
	train_next();
};

#ifdef mtf_coop
void() train_moving_use =
{
	//still moving, so save it for later
	self.cnt = self.cnt + 1;
}
#endif

void() train_wait = 
{
#ifdef mtf_coop
	if (self.spawnflags & TRAIN_RETRIGGER) {
		if (self.cnt > 0) { //triggered early, so continue now
			self.cnt = self.cnt - 1;
			self.nextthink = self.ltime + 0.1;
			self.think = train_next;
			return;
		}
		self.use = train_use; //ready to be re-triggered
		sound (self, CHAN_VOICE, self.noise, 1, ATTN_NORM); //play stopping sound
		return;
	}
#endif
#ifdef mtf_coop_halflife
	if (self.has_tesla == 1) {
		self.use = train_use;
		self.think = func_train_find;
		self.has_tesla = 0;
		return;
	}
	if (self.message) {
		Delayed_Timer( self.message, 0 );
		self.message = "";
	}
#endif
#ifdef mtf_coop
	local string oldtarg;
	if (self.real_owner.pathtarget)
	{
		oldtarg = self.target;
		self.target = self.real_owner.pathtarget;
		SUB_UseTargets();
		self.target = oldtarg;
	}
#endif
	if (self.wait)
	{
		self.nextthink = self.ltime + self.wait;
		if (self.wait == -1)
		{
			self.think = func_train_find;
#ifdef mtf_coop
			if (self.spawnflags & 2) {
				self.use = train_use;
				return;
			}
#endif
		}
		self.sounds = 4;
			sound(self, 2, self.noise, 1, 0);
	}
	else
	{
#ifdef HALFLIFE
		if (#HL_MAP)
			train_next();
		else
#endif
		self.nextthink = self.ltime + 0.1;
	}
	self.think = train_next;
};

void() train_next = 
{
	local entity targ;
	
#ifdef mtf_coop
	if (self.spawnflags & TRAIN_RETRIGGER) {
		self.use = train_moving_use; //store up any premature triggerings until current movement is finished
	}
#endif
	
	targ = find(world, targetname, self.target);
	self.target = targ.target;
	if (!(self.target))
	{
#ifdef mtf_coop_halflife
		if (#HL_MAP)
		{
			if (targ == world  || !targ.classname || !targ.targetname)
				return;
		}
		else
#endif
#ifdef mtf_coop
		return;		// this may break hl support.. dunno lol (quake 2 thing)
#else
		objerror("train_next: no next target");
#endif
	}
	if (targ.wait)
	{
		self.wait = targ.wait;
	}
	else
	{
		self.wait = 0;
	}
	self.sounds = 4;
		sound(self, 2, self.noise1, 1, 1);
#ifdef mtf_coop_halflife
	if (self.mtf_items > 0) {
			self.speed = self.mtf_items;
		self.mtf_items = 0;
	}
	if (#HL_MAP) {//self.globalname)
		if (targ.speed > 0)			// change our speed to match the path_corner's
			self.mtf_items = targ.speed;
		if (targ.spawnflags & 1) {
			self.has_tesla = 1;		// wait till triggered again
		}
		if (targ.message)
			self.message = targ.message;

		if (targ.spawnflags & 2) {	// teleport there auto
			setorigin(self, targ.origin - ((self.mins+self.maxs)*.5));
			SUB_CalcMove(targ.origin - ((self.mins+self.maxs)*.5), 9999, train_wait);
		}
		else
			SUB_CalcMove(targ.origin - ((self.mins+self.maxs)*.5), self.speed, train_wait);
	}
	else
#endif
#ifdef mtf_coop
	// quake 2 stuff
	if (targ.spawnflags & 1) {
		// yeah in q2 it's spawnflags & 1 and in HL it's spawnflags & 2.. why can nobody make my life easy? :\
			setorigin(self, targ.origin - ((self.mins+self.maxs)*.5));
			SUB_CalcMove(targ.origin - ((self.mins+self.maxs)*.5), 9999, train_wait);
	}
	else
#endif
	SUB_CalcMove(targ.origin - self.mins, self.speed, train_wait);
#ifdef mtf_coop
	if (targ != world) {
		self.real_owner = targ;
	}
#endif
};

void() func_train_find = 
{
	local entity targ;
	targ = find(world, targetname, self.target);
	self.target = targ.target;
#ifdef mtf_coop_halflife
	if (targ.speed > 0)
		self.speed = targ.speed;
	if (#HL_MAP) {//self.globalname) {
		setorigin(self, targ.origin - ((self.mins + self.maxs)*.5));
	}
	else
#endif
	setorigin(self, targ.origin - self.mins);
	if (!(self.targetname))
	{
		self.nextthink = self.ltime + 0.1;
		self.think = train_next;
	}
};

void() followtrain = 
{
	setorigin(self, self.owner.origin);
	self.nextthink = time + 0.1;
	self.think = followtrain;
};

void() func_train = 
{
	if (CheckExistence() == 0)
	{
		dremove(self);
		return;
	}
	if (!(self.speed))
	{
		self.speed = 100;
	}
	if (!(self.target))
	{
#ifdef mtf_coop_halflife
		if (self.targetname == "c1a3_pole01") {
			dremove(self);
			return;
		}
#endif
		objerror("func_train without a target");
	}
	if (!(self.dmg))
	{
		self.dmg = 2;
	}
	if (self.sounds == 0)
	{
		self.noise = "misc/null.wav";
		precache_sound("misc/null.wav");
		self.noise1 = "misc/null.wav";
		precache_sound("misc/null.wav");
	}
	if (self.sounds == 1)
	{
		self.noise = "plats/train2.wav";
		precache_sound("plats/train2.wav");
		self.noise1 = "plats/train1.wav";
		precache_sound("plats/train1.wav");
	}
	if (self.sounds == 4)
	{
		precache_sound("plats/track_st.wav");
		precache_sound("plats/track_e.wav");
		self.noise = "plats/track_e.wav";
		self.noise1 = "plats/track_st.wav";
	}
#ifdef mtf_coop
	if (self.sounds == 2)
	{
		self.noise = "doors/hydro2.wav";
		precache_sound ("doors/hydro2.wav");
		self.noise1 = "doors/hydro1.wav";
		precache_sound ("doors/hydro1.wav");
	}
	if (self.spawnflags & TRAIN_RETRIGGER)
		self.cnt = 0; //johnfitz -- used to store premature trigger events when TRAIN_RETRIGGER is set
	else
#endif
	self.cnt = 1;
	self.solid = 4;
	self.movetype = 7;
	self.blocked = train_blocked;
	self.use = train_use;
	self.classname = "train";
	setmodel(self, self.model);
	setsize(self, self.mins, self.maxs);
	setorigin(self, self.origin);

#ifdef mtf_coop_halflife
	if (mapname == "c1a1b" || mapname == "c1a1c") {
		if (self.globalname == "c1a1b_zombie_vent1")
			dremove(self);
	}
	else if (mapname == "c1a1c") {
		self.globalname = "downward_vent";
	}
	else if (mapname == "c1a2c")
		if (self.target == "freezer_train_2")
			self.globalname = "halflife_thing";
	
	if (#HL_MAP) {
		if (self.spawnflags & 8) {	// swimmy!
			self.spawnflags = 8;
			self.solid = 1;
			setorigin (self, self.origin);
			self.touch = liquid_touch; // better swim function is required lol
		}
		else
			self.spawnflags = 0;		// halflife trains only have "8" for spawn flags afaik
	}
	if (#HL_MAP) {
		if (self.target == "waterpath2" || self.targetname == "water_door_move3") {
			self.solid = 0;
			setorigin(self, self.origin - '0 0 1000');
		}
	}
	HalfLife_DoRender();
#endif
	
	self.nextthink = self.ltime + 0.1;
	self.think = func_train_find;

#ifdef SVEN_COOP
	if (#HL_MAP)
		if (self.target && !self.targetname)
			self.use();
#endif
};

void() light_move = 
{
	if (CheckExistence() == 0)
	{
		dremove(self);
		return;
	}
	if (!(self.speed))
	{
		self.speed = 100;
	}
	if (!(self.target))
	{
		objerror("light_move without a target");
	}
	self.noise = "misc/null.wav";
	precache_sound("misc/null.wav");
	self.noise1 = "misc/null.wav";
	precache_sound("misc/null.wav");
	self.cnt = 1;
	if (!(self.effects))
	{
		self.effects = 4;
	}
	self.solid = 4;
	self.movetype = 7;
	self.classname = "movelight";
	precache_model("progs/s_null.spr");
	setmodel(self, "progs/s_null.spr");
	setsize(self, '0 0 0', '0 0 0');
	setorigin(self, self.origin);
	self.nextthink = self.ltime + 0.1;
	self.think = func_train_find;
};

void() misc_teleporttrain = 
{
	if (CheckExistence() == 0)
	{
		dremove(self);
		return;
	}
	if (!(self.speed))
	{
		self.speed = 100;
	}
	if (!(self.target))
	{
		objerror("func_train without a target");
	}
	self.cnt = 1;
	self.solid = 0;
	self.movetype = 7;
	self.blocked = train_blocked;
	self.use = train_use;
	self.avelocity = '100 200 300';
	self.noise = "misc/null.wav";
	precache_sound("misc/null.wav");
	self.noise1 = "misc/null.wav";
	precache_sound("misc/null.wav");
	precache_model2("progs/teleport.mdl");
	setmodel(self, "progs/teleport.mdl");
	setsize(self, self.mins, self.maxs);
	setorigin(self, self.origin);
	self.nextthink = self.ltime + 0.1;
	self.think = func_train_find;
};
//END
